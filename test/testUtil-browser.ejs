
sinon.stub(Obniz.prototype , 'wsOnClose');

var   serverDataCount = 0;
var   errorDataCount = 0;
var testUtil = {
  log: console.log,
  createServer: function (port, velify) {
    var wss = new WSServer({host: "localhost", port: port, clientTracking: true});

    if (velify === null || velify === undefined || velify === true) {
      wss.verifyClient = function (info, accept) {
        accept(true);
      };
    } else {
      wss.verifyClient = function (info, accept) {
        accept(false, velify.statusCode, velify.message);
      };
    }

    return wss;
  },

  createObniz: function (port, obnizId, options) {
    let binary =  options && options.binary !== undefined ? options.binary : false;
    return new Obniz(obnizId, {obniz_server: "ws://localhost:" + port, binary: binary});
  },

  setupNotConnectedYetObnizPromise: function(obj, done, options) {
    options = options || {};
    let stub = sinon.stub();
    stub.on = sinon.stub();
    stub.send = sinon.stub();
    stub.close = sinon.stub();
    stub.removeAllListeners = sinon.stub();
    stub.readyState = 1;

    sinon.stub(Obniz.prototype, 'wsconnect');
    obj.obniz = this.createObniz(100, '12345678', options);
    obj.obniz.socket = stub;
    obj.obniz.error = sinon.stub();
    obj.obniz.wsOnOpen();

    serverDataCount = 0;

    done();
  },

  setupObnizPromise: function(obj, done, options) {
    options = options || {};
    let stub = sinon.stub();
    stub.on = sinon.stub();
    stub.send = sinon.stub();
    stub.close = sinon.stub();
    stub.removeAllListeners = sinon.stub();
    stub.readyState = 1;

    sinon.stub(Obniz.prototype, 'wsconnect');
    obj.obniz = this.createObniz(100, '12345678', options);
    obj.obniz.socket = stub;
    obj.obniz.error = sinon.stub();
    obj.obniz.wsOnOpen();
    obj.obniz.wsOnMessage(JSON.stringify([{
      ws:{
        ready: true,
        obniz: {
          firmware: options.__firmware_ver || '1.1.0'
        }
      }
    }]))
    serverDataCount = 0;

    expect(obj.obniz).send([{"ws":{"reset_obniz_on_ws_disconnection":true}}]);

    done();
  },


  releaseObnizePromise: function (obj,done) {
    obj.obniz.close();
    obj.obniz = null;
    Obniz.prototype.wsconnect.restore();
    
    done();
  },
  
  waitForWebsocketCall : function(obj, n){
    return new Promise(function(resolve, reject){
      var count = 100;
      var wait = function(){
        if(obj.onServerMessage.callCount >= n ){
         resolve();
        }else{
          count--;
          if(count < 0){
            reject("waitForWebsocketCall timeout");return;
          }
          setTimeout(wait,10);
          
        }
      };
      setTimeout(wait,10);
    });
    
  },
  receiveJson: function(obniz, jsonVal){
    obniz.wsOnMessage(JSON.stringify(jsonVal));
  },


  isValidCommandRequestJson: function(jsonVal){
    //browser
    return  {valid : true};

  },

  isValidCommandResponseJson: function(jsonVal){
    //browser
    return  {valid : true};

  },

  obnizAssert : function(_chai, utils){
     _chai.Assertion.addProperty('obniz', function() {
       var obj = utils.flag(this, 'object');
       new _chai.Assertion(obj).to.be.instanceof(Obniz);
     });
     
     _chai.Assertion.addMethod('send', function(expected) {
       var count = serverDataCount;
       serverDataCount++;
       
       var obniz = utils.flag(this, 'object');
       var stub = obniz.socket.send;
       
       var message  = "[obniz.send] no more send data. (called " + stub.callCount  + " times, but you expect "+(count+1)+" times) ";
       new _chai.Assertion(stub.callCount,message ).to.be.above(count);
       
       new _chai.Assertion(stub.args[count][0],"[obniz.send]invalid json").is.json;
       var val = JSON.parse(stub.args[count][0]);
       new _chai.Assertion(val).to.deep.equal(expected);
     });


      _chai.Assertion.addMethod('sendBinary', function (expected) {
        var count = serverDataCount;
        serverDataCount++;

        var obniz = utils.flag(this, 'object');
        var stub = obniz.socket.send;

        var message = "[obniz.send] no more send data. (called " + stub.callCount + " times, but you expect " + (count + 1) + " times) ";
        new _chai.Assertion(stub.callCount, message).to.be.above(count);

        new _chai.Assertion(stub.args[count][0]).to.deep.equal(expected);
      });


_chai.Assertion.addProperty('finished', function(expected) {
       var obniz = utils.flag(this, 'object');
        var stub = obniz.socket.send;
       var message  = "[obniz.send] not finished. (send: called " + stub.callCount  + " times, but you expect "+(serverDataCount)+" times) ";
       new _chai.Assertion(stub.callCount, message ).to.be.equal(serverDataCount);
       
        
       var errorStub = obniz.error;
       var message  = "[obniz.send] not finished. (error: called " + errorStub.callCount  + " times, but you expect "+(errorDataCount)+" times) ";
       new _chai.Assertion(errorStub.callCount, message ).to.be.equal(errorDataCount);
       
     });
     
     
     _chai.Assertion.addMethod('error', function(expected) {
       var count = errorDataCount;
       errorDataCount++;
       
       var obniz = utils.flag(this, 'object');
       var stub = obniz.error;
       
       var message  = "[obniz.error] no more error data. (called " + stub.callCount  + " times, but you expect "+(count+1)+" times) ";
       new _chai.Assertion(stub.callCount,message ).to.be.above(count);
       
       if(expected){
         new _chai.Assertion(stub.args[count][0]).to.have.string(expected);
        }
     });
     
     _chai.Assertion.addProperty('json', function(expected) {
       var string = utils.flag(this, 'object');
       new _chai.Assertion(string).is.string;
       var resolve = null;
       try {
         JSON.parse(string);
         resolve = true;
       }catch(err){
         resolve = false;
       }
       new _chai.Assertion(resolve).to.be.true;
     });
     
     
  },
  
  browser : function (url) {
    var url = "file://" + url;
    options = {
      url,
    };
    const runner = new MochaChrome(options);
    const result = new Promise((resolve, reject) => {
      runner.on('ended', stats => {
        resolve(stats);
      });

      runner.on('failure', message => {
        reject(message);
      });
    });

    return runner.connect().then(function(){
      return runner.run();
    }).then(function(){
      return result;
    });
  },
  
  ejs : function(url, param){
    var data = fs.readFileSync(url,'utf8');
    html = ejs.render(data, param);
    var newFilename = url.replace(".","_") + ".html";
    
    return new Promise(function(resolve, reject){
      fs.writeFile(newFilename, html, function(err){
        if(err){
          reject(err);
        }else{
          resolve();
        }
      });
    }).then(function(){
      return testUtil.browser(newFilename);
    });
  },
 
  needBrowserTest : function(){
    if (typeof window === 'undefined' &&  process && !semver.satisfies(process.versions.node, '>=7.6.0')) {
      return false;
    }
    return true;
  },

  checkJsonToBinary: function(requestJson, binary, self) {
    if (typeof requestJson === 'string') {
      requestJson = JSON.parse(requestJson);
    }
    if (Array.isArray(binary) && binary.length > 0 && typeof binary[0] === 'string' ) {
      binary = binary.join(' ');
    }
    if (typeof binary === 'string') {
      binary = binary.split(' ').map(function(val, index) {
        return parseInt(val, 16);
      });

      expect(binary.length).to.be.above(2);
    }
    binary = new Uint8Array(binary);

    expect(requestJson.length).to.be.equal(1);

    let isValidCommand = testUtil.isValidCommandRequestJson(requestJson);
    expect(isValidCommand.valid).to.be.true;

    let compress = self.obniz.constructor.WSCommand.compress(
      self.obniz.wscommands,
      requestJson[0]
    );

    expect(compress).to.be.deep.equal(binary);
  },
  checkBinaryToJson: function(responseBinaryString, expectedJson, self) {
    let binaryArray = responseBinaryString.split(' ').map(function(val, index) {
    return parseInt(val, 16);
    });
    let binary = new Uint8Array(binaryArray);

    let json = self.obniz.binary2Json(binary);

    let isValidCommand = testUtil.isValidCommandResponseJson(json);
    expect(isValidCommand.valid).to.be.true;

    expect(json).to.be.deep.equal(expectedJson);
  },

};