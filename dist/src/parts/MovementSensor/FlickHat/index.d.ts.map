{"version":3,"sources":["../src/parts/MovementSensor/FlickHat/index.ts"],"names":[],"mappings":"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","file":"index.d.ts","sourcesContent":["import Obniz from \"../../../obniz\";\nimport PeripheralI2C from \"../../../obniz/libs/io_peripherals/i2c\";\nimport ObnizPartsInterface, {ObnizPartsInfo} from \"../../../obniz/ObnizPartsInterface\";\n\n/**\n * @category Parts\n */\nexport interface  FlickHatOptions {\n  vcc?: number;\n  sda: number;\n  scl: number;\n  reset: number;\n  ts: number;\n  gnd: number;\n  led1?: number;\n  led2?: number;\n}\n\nexport type FlickHat_Direction = \"west\" | \"east\" | \"north\" | \"south\";\nexport type FlickHat_Direction2 = \"west\" | \"east\" | \"north\" | \"south\" | \"center\";\n\n/**\n * @category Parts\n */\nexport interface  FlickHat_XYZ {\n  x: number;\n  y: number;\n  z: number;\n  seq: number;\n}\n\n/**\n * @category Parts\n */\nexport interface  FlickHat_Gesture {\n  action: \"gesture\";\n  from: FlickHat_Direction;\n  to: FlickHat_Direction;\n  seq: number;\n  raw: any;\n}\n\n/**\n * @category Parts\n */\nexport interface  FlickHat_Touch {\n  action: \"touch\";\n  positions: FlickHat_Direction2[];\n  seq: number;\n  raw: any;\n}\n\n/**\n * @category Parts\n */\nexport interface  FlickHat_Tap {\n  action: \"tap\";\n  positions: FlickHat_Direction2[];\n  seq: number;\n  raw: any;\n}\n\n/**\n * @category Parts\n */\nexport interface  FlickHat_DoubleTap {\n  action: \"doubletap\";\n  positions: FlickHat_Direction2[];\n  seq: number;\n  raw: any;\n}\n\n/**\n * @category Parts\n */\nexport interface  FlickHat_AirWheel {\n  delta: number;\n  rotation: number;\n  seq: number;\n  raw: any;\n}\n\n/**\n * @category Parts\n */\nexport default class FlickHat implements ObnizPartsInterface {\n\n  public static info(): ObnizPartsInfo {\n    return {\n      name: \"FlickHat\",\n    };\n  }\n\n  public keys: string[];\n  public requiredKeys: string[];\n  public displayIoNames: any;\n  public params: any;\n\n  public address: any;\n  public io_reset: any;\n  public io_ts: any;\n  public i2c!: PeripheralI2C;\n  public led1: any;\n  public led2: any;\n  public onfwinfo?: (fwInfo: any) => void;\n  public fwInfo: any;\n  public rotation: any;\n  public lastRotation: any;\n  public readSize: any;\n  public debugprint: any;\n  public xyz: any;\n  public onxyz?: (xyz: FlickHat_XYZ) => void;\n  public lastGesture: any;\n  public ongestureall: any;\n  public ongesture?: (gesture: FlickHat_Gesture) => void;\n  public lastTouch: any;\n  public ontouch?: (touch: FlickHat_Touch) => void;\n  public ontap?: ((tap: FlickHat_Tap) => void);\n  public ondoubletap: any;\n  public onairwheel?: (airwheel: FlickHat_AirWheel) => void ;\n  public statusInfo: any;\n\n  protected obniz!: Obniz;\n\n  constructor() {\n    this.keys = [\"vcc\", \"gnd\", \"sda\", \"scl\", \"reset\", \"ts\", \"led1\", \"led2\"];\n    this.requiredKeys = [\"gnd\", \"sda\", \"scl\", \"reset\", \"ts\"];\n\n    this.displayIoNames = {\n      // vcc: 'vcc', //5v\n      sda: \"sda\",\n      scl: \"scl\",\n      gnd: \"gnd\",\n      reset: \"reset\",\n      ts: \"ts\",\n    };\n  }\n\n  public wired(obniz: Obniz) {\n    this.obniz = obniz;\n\n    this.address = 0x42;\n\n    if (this.obniz.isValidIO(this.params.vcc)) {\n      this.obniz.getIO(this.params.vcc).drive(\"5v\");\n      this.obniz.getIO(this.params.vcc).output(true);\n    }\n    this.obniz.getIO(this.params.gnd).output(false);\n\n    this.io_reset = this.obniz.getIO(this.params.reset);\n    this.io_reset.drive(\"3v\");\n\n    this.io_ts = this.obniz.getIO(this.params.ts);\n    this.io_ts.drive(\"open-drain\");\n    this.io_ts.pull(\"3v\");\n\n    this.params.mode = \"master\";\n    this.params.pull = \"3v\";\n    this.params.clock = 100 * 1000; // 100KHz\n\n    // PeripheralI2C\n    this.i2c = this.obniz.getI2CWithConfig(this.params);\n\n    if (this.obniz.isValidIO(this.params.led1)) {\n      this.led1 = this.obniz.wired(\"LED\", {anode: this.params.led1});\n    }\n    if (this.obniz.isValidIO(this.params.led2)) {\n      this.led2 = this.obniz.wired(\"LED\", {anode: this.params.led2});\n    }\n  }\n\n  public async start(callback: (fwInfo: any) => void): Promise<void> {\n    this.io_ts.pull(\"3v\");\n\n    this.io_reset.output(false);\n    await this.obniz.wait(50);\n    this.io_reset.output(true);\n    await this.obniz.wait(50);\n\n    this.onfwinfo = callback;\n    this.fwInfo = {\n      fwValid: 0,\n      fwInfoReceived: false,\n    };\n    this.rotation = 0;\n    this.lastRotation = 0;\n    this.readSize = 132;\n\n    await this.polling();\n    await this.obniz.wait(200);\n\n    this.i2c.write(this.address, [\n      0x10,\n      0x00,\n      0x00,\n      0xa2,\n      0xa1,\n      0x00,\n      0x00,\n      0x00,\n      0x1f,\n      0x00,\n      0x00,\n      0x00,\n      0xff,\n      0xff,\n      0xff,\n      0xff,\n    ]);\n    await this.obniz.wait(100);\n\n    this.i2c.write(this.address, [\n      0x10,\n      0x00,\n      0x00,\n      0xa2,\n      0x80,\n      0x00,\n      0x00,\n      0x00,\n      0x3f,\n      0x00,\n      0x00,\n      0x00,\n      0x3f,\n      0x00,\n      0x00,\n      0x00,\n    ]);\n  }\n\n  public _dataArray2string(data: any) {\n    let result: any = \"\";\n    for (const n of data) {\n      result += String.fromCharCode(n);\n    }\n    return result;\n  }\n\n  public async polling(timeout?: any) {\n    timeout = timeout || 3000; // default: 3s\n\n    // DataOutputConfigMask\t2byte\n    // const maskDSPStatus = 1;\n    const maskGestureInfo: any = 1 << 1;\n    const maskTouchInfo: any = 1 << 2;\n    const maskAirWheelInfo: any = 1 << 3;\n    const maskXYZPosition: any = 1 << 4;\n\n    // SystemInfo\t1byte\n    const sysPositionValid: any = 1;\n    const sysAirWheelValid: any = 1 << 1;\n    // const sysDSPRunning = 1 << 7;\n\n    const startTime: any = new Date();\n    let ts: any = true;\n    while (ts && (new Date() as any) - startTime < timeout) {\n      ts = await this.io_ts.inputWait();\n    }\n    if (!ts) {\n      this.io_ts.pull(\"0v\");\n      // await this.obniz.wait(1);\n\n      const data: any = await this.i2c.readWait(this.address, this.readSize);\n      const size: any = data[0];\n      // let flag = data[1];\n      const seq: any = data[2];\n      const msgID: any = data[3];\n\n      if (size !== 0xff && size > 0) {\n        if (this.debugprint || this.obniz.debugprint) {\n          console.log(\n            \"flickHat: \" + data.slice(0, size).map((v: any) => \"0x\" + v.toString(16)),\n          );\n        }\n        let configmask: any;\n        let sysinfo: any;\n        let gesture: any;\n        let touch: any;\n        let airwheel: any;\n        let statusInfo: any;\n        let fwInfo: any;\n        switch (msgID) {\n          case 0x91: // sensor data output\n            configmask = data[4] | (data[5] << 8); // little endian\n            // let timestamp = data[6]; // 200hz, 8-bit counter, max ~1.25sec\n            sysinfo = data[7];\n            // let dspstatus = data.slice(8, 10);\n            gesture = data.slice(10, 14);\n            touch = data.slice(14, 18);\n            airwheel = data.slice(18, 20);\n            // let xyz = data.slice(20, 26);\n            // let noisepow = data.slice(27, 30);\n            if (\n              gesture[0] === 255 &&\n              gesture[1] === 255 &&\n              gesture[2] === 255 &&\n              gesture[3] === 255\n            ) {\n              break;\n            }\n\n            if (configmask & maskXYZPosition && sysinfo & sysPositionValid) {\n              const xyz: any = {\n                // little endian\n                x: (data[20] | (data[21] << 8)) / 65536,\n                y: (data[22] | (data[23] << 8)) / 65536,\n                z: (data[24] | (data[25] << 8)) / 65536,\n                seq,\n              };\n              this.xyz = xyz;\n              if (typeof this.onxyz === \"function\") {\n                this.onxyz(xyz);\n              }\n            }\n\n            if (configmask & maskGestureInfo && gesture[0] > 0) {\n              this.lastGesture = gesture[0];\n              const gestures: any = [\n                [\"\", \"\", \"\"], // no gesture\n                [\"garbage\", \"\", \"\"],\n                [\"flick\", \"west\", \"east\"], // 2\n                [\"flick\", \"east\", \"west\"], // 3\n                [\"flick\", \"south\", \"north\"], // 4\n                [\"flick\", \"north\", \"south\"], // 5\n                [\"circle\", \"clockwise\", \"\"],\n                [\"circle\", \"counter-clockwise\", \"\"],\n                [\"wave\", \"x\", \"\"],\n                [\"wave\", \"y\", \"\"],\n                [\"hold\", \"\", \"\"],\n              ];\n              for (const index in gestures) {\n                if (\n                  index === gesture[0] &&\n                  typeof this.ongestureall === \"function\"\n                ) {\n                  this.ongestureall({\n                    action: gestures[index][0],\n                    from: gestures[index][1],\n                    to: gestures[index][2],\n                    raw: gesture,\n                    seq,\n                  });\n                }\n                if (\n                  index === gesture[0] &&\n                  gestures[index][0] === \"flick\" &&\n                  typeof this.ongesture === \"function\"\n                ) {\n                  this.ongesture({\n                    action: \"gesture\",\n                    from: gestures[index][1],\n                    to: gestures[index][2],\n                    raw: gesture,\n                    seq,\n                  });\n                }\n              }\n            }\n\n            if (\n              configmask & maskTouchInfo &&\n              !(touch[0] === 0 && touch[1] === 0) &&\n              touch[3] === 0\n            ) {\n              // console.log('touch: ' + touch.map(v => '0x' + v.toString(16)));\n              const touchAction: any = touch[0] | (touch[1] << 8); // little endian\n              if (touchAction === 0xffff) {\n                break;\n              }\n              // let touchCount = touch[2] * 5; // touch counter value * 5[ms]\n              const actions: any = [\n                [\"touch\", \"south\"], // 0\n                [\"touch\", \"west\"], // 1\n                [\"touch\", \"north\"], // 2\n                [\"touch\", \"east\"], // 3\n                [\"touch\", \"center\"], // 4\n                [\"tap\", \"south\"], // 5\n                [\"tap\", \"west\"], // 6\n                [\"tap\", \"north\"], // 7\n                [\"tap\", \"east\"], // 8\n                [\"tap\", \"center\"], // 9\n                [\"doubletap\", \"south\"], // 10\n                [\"doubletap\", \"west\"], // 11\n                [\"doubletap\", \"north\"], // 12\n                [\"doubletap\", \"east\"], // 13\n                [\"doubletap\", \"center\"], // 14\n              ];\n\n              const touches: any = [];\n              const taps: any = [];\n              const doubletaps: any = [];\n              this.lastTouch = touchAction;\n\n              let comp: any = 1;\n              for (const index in actions) {\n                const value: any = actions[index];\n                if (touchAction & comp) {\n                  // console.log(`touchAction:${touchAction.toString(16)}, comp:${comp.toString(16)}, index:${index}, group:${group}`);\n                  switch (value[0]) {\n                    case \"touch\":\n                      touches.push(value[1]);\n                      break;\n                    case \"tap\":\n                      taps.push(value[1]);\n                      break;\n                    case \"doubletap\":\n                      doubletaps.push(value[1]);\n                      break;\n                    default:\n                  }\n                }\n                comp <<= 1;\n              }\n\n              if (touches.length > 0 && typeof this.ontouch === \"function\") {\n                this.ontouch({\n                  action: \"touch\",\n                  positions: touches,\n                  raw: touch,\n                  seq,\n                });\n              }\n\n              if (taps.length > 0 && typeof this.ontap === \"function\") {\n                this.ontap({\n                  action: \"tap\",\n                  positions: taps,\n                  raw: touch,\n                  seq,\n                });\n              }\n\n              if (\n                doubletaps.length > 0 &&\n                typeof this.ondoubletap === \"function\"\n              ) {\n                this.ondoubletap({\n                  action: \"doubletap\",\n                  positions: doubletaps,\n                  raw: touch,\n                  seq,\n                });\n              }\n            }\n\n            if (configmask & maskAirWheelInfo && sysinfo & sysAirWheelValid) {\n              const delta: any = (airwheel[0] - this.lastRotation) / 32.0;\n              this.rotation += delta * 360.0;\n              this.rotation %= 360;\n              if (delta !== 0 && delta > -0.5 && delta < 0.5) {\n                if (typeof this.onairwheel === \"function\") {\n                  this.onairwheel({\n                    delta: delta * 360.0,\n                    rotation: this.rotation,\n                    raw: airwheel,\n                    seq,\n                  });\n                }\n              }\n              this.lastRotation = airwheel[0];\n            }\n            break;\n\n          case 0x15: // system status\n            statusInfo = {\n              msgId: data[4],\n              maxCmdSize: data[5],\n              error: data[6] | (data[7] << 8), // little endian\n            };\n            this.statusInfo = statusInfo;\n            if (this.debugprint || this.obniz.debugprint) {\n              console.log(\n                `flickHat: system status: {msgId: ${\n                  statusInfo.msgId\n                }, maxCmdSize: ${statusInfo.maxCmdSize}, error: ${\n                  statusInfo.error\n                }}`,\n              );\n            }\n            break;\n\n          case 0x83: // farmware information\n            fwInfo = {\n              fwValid: data[4] === 0xaa,\n              hwRev: [data[5], data[6]],\n              paramStartAddr: data[7] * 128,\n              libLoaderVer: [data[8], data[9]],\n              libLoaderPlatform: data[10],\n              fwStartAddr: data[11] * 128,\n              fwVersion: this._dataArray2string(data.slice(12, 132)).split(\n                \"\\0\",\n              )[0],\n              fwInfoReceived: true,\n            };\n            this.fwInfo = fwInfo;\n            if (typeof this.onfwinfo === \"function\") {\n              this.onfwinfo(fwInfo);\n            }\n            this.readSize = 26;\n            break;\n\n          default:\n            console.error(\n              `unknown message: 0x${msgID.toString(16)}, data:${data\n                .slice(0, size)\n                .map((v: any) => \"0x\" + v.toString(16))}`,\n            );\n        }\n      }\n\n      this.io_ts.pull(\"3v\");\n      // await this.obniz.wait(1);\n    }\n  }\n}\n"]}