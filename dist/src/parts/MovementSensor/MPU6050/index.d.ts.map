{"version":3,"sources":["../src/parts/MovementSensor/MPU6050/index.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAM,gBAAgB,CAAC;AACnC,OAAO,aAAa,MAAM,wCAAwC,CAAC;AAEnE,OAAO,mBAAmB,EAAE,EAAC,cAAc,EAAC,MAAM,oCAAoC,CAAC;AAEvF;;GAEG;AACH,MAAM,WAAY,cAAc;IAC9B,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,GAAG,CAAC,EAAE,aAAa,CAAC;IACpB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,mBAAmB,CAAC,EAAE,MAAM,CAAC;IAC7B,eAAe,CAAC,EAAE,MAAM,CAAC;CAC1B;AAED;;GAEG;AACH,MAAM,CAAC,OAAO,OAAO,OAAQ,YAAW,mBAAmB;WAE3C,IAAI,IAAI,cAAc;IAM7B,IAAI,EAAE,MAAM,EAAE,CAAC;IACf,YAAY,EAAE,MAAM,EAAE,CAAC;IACvB,MAAM,EAAE,GAAG,CAAC;IAEnB,SAAS,CAAC,KAAK,EAAG,KAAK,CAAC;IAExB,OAAO,CAAC,GAAG,CAAiB;IAE5B,OAAO,CAAC,QAAQ,CAAQ;IACxB,OAAO,CAAC,YAAY,CAAM;IAC1B,OAAO,CAAC,WAAW,CAAM;;IAgBlB,KAAK,CAAC,KAAK,EAAE,KAAK;IAgBlB,SAAS,CAAC,mBAAmB,EAAE,MAAM,EAAE,eAAe,EAAE,MAAM;IAuCxD,OAAO,IAAI,OAAO,CAAC;QAC9B,aAAa,EAAE;YACb,CAAC,EAAE,MAAM,CAAC;YACV,CAAC,EAAE,MAAM,CAAC;YACV,CAAC,EAAE,MAAM,CAAC;SACX,CAAC;QACF,IAAI,EAAE,MAAM,CAAC;QACb,SAAS,EAAE;YACT,CAAC,EAAE,MAAM,CAAC;YACV,CAAC,EAAE,MAAM,CAAC;YACV,CAAC,EAAE,MAAM,CAAC;SACX,CAAC;KACH,CAAC;IAyBK,UAAU,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM;CAOjD","file":"index.d.ts","sourcesContent":["import Obniz from \"../../../obniz\";\nimport PeripheralI2C from \"../../../obniz/libs/io_peripherals/i2c\";\n\nimport ObnizPartsInterface, {ObnizPartsInfo} from \"../../../obniz/ObnizPartsInterface\";\n\n/**\n * @category Parts\n */\nexport interface  MPU6050Options {\n  gnd?: number;\n  vcc?: number;\n  sda?: number;\n  scl?: number;\n  i2c?: PeripheralI2C;\n  address?: number;\n  accelerometer_range?: number;\n  gyroscope_range?: number;\n}\n\n/**\n * @category Parts\n */\nexport default class MPU6050 implements ObnizPartsInterface {\n\n  public static info(): ObnizPartsInfo {\n    return {\n      name: \"MPU6050\",\n    };\n  }\n\n  public keys: string[];\n  public requiredKeys: string[];\n  public params: any;\n\n  protected obniz!: Obniz;\n\n  private i2c!: PeripheralI2C;\n\n  private _address = 0x68;\n  private _accel_range: any;\n  private _gyro_range: any;\n\n  constructor() {\n    this.keys = [\n      \"gnd\",\n      \"vcc\",\n      \"sda\",\n      \"scl\",\n      \"i2c\",\n      \"address\",\n      \"accelerometer_range\",\n      \"gyroscope_range\",\n    ];\n    this.requiredKeys = [];\n  }\n\n  public wired(obniz: Obniz) {\n    this.obniz = obniz;\n    obniz.setVccGnd(this.params.vcc, this.params.gnd, \"5v\");\n    this.params.clock = 100000;\n    this.params.pull = \"3v\";\n    this.params.mode = \"master\";\n    if (typeof this.params.address === \"number\") {\n      this._address = this.params.address;\n    }\n    this.i2c = obniz.getI2CWithConfig(this.params);\n    this.setConfig(\n      this.params.accelerometer_range || 2,\n      this.params.gyroscope_range || 250,\n    );\n  }\n\n  public setConfig(accelerometer_range: number, gyroscope_range: number) {\n    // accel range set (0x00:2g, 0x08:4g, 0x10:8g, 0x18:16g)\n    switch (accelerometer_range) {\n      case 2:\n        this.i2c.write(this._address, [0x1c, 0x00]);\n        break;\n      case 4:\n        this.i2c.write(this._address, [0x1c, 0x08]);\n        break;\n      case 8:\n        this.i2c.write(this._address, [0x1c, 0x10]);\n        break;\n      case 16:\n        this.i2c.write(this._address, [0x1c, 0x18]);\n        break;\n      default:\n        throw new Error(\"accel_range variable 2,4,8,16 setting\");\n    }\n    // gyro range & LPF set (0x00:250, 0x08:500, 0x10:1000, 0x18:2000[deg/s])\n    switch (gyroscope_range) {\n      case 250:\n        this.i2c.write(this._address, [0x1b, 0x00]);\n        break;\n      case 500:\n        this.i2c.write(this._address, [0x1b, 0x08]);\n        break;\n      case 1000:\n        this.i2c.write(this._address, [0x1b, 0x10]);\n        break;\n      case 2000:\n        this.i2c.write(this._address, [0x1b, 0x18]);\n        break;\n      default:\n        throw new Error(\"accel_range variable 250,500,1000,2000 setting\");\n    }\n    this._accel_range = accelerometer_range;\n    this._gyro_range = gyroscope_range;\n  }\n\n  public async getWait(): Promise<{\n    accelerometer: {\n      x: number,\n      y: number,\n      z: number,\n    },\n    temp: number,\n    gyroscope: {\n      x: number,\n      y: number,\n      z: number,\n    },\n  }> {\n    this.i2c.write(this._address, [0x3b]); // request MPU6050 data\n    const raw_data_MPU6050 = await this.i2c.readWait(this._address, 14); // read 14byte\n    const ac_scale = this._accel_range / 32768;\n    const gy_scale = this._gyro_range / 32768;\n    return {\n      accelerometer: {\n        x: this.char2short(raw_data_MPU6050[0], raw_data_MPU6050[1]) * ac_scale,\n        y: this.char2short(raw_data_MPU6050[2], raw_data_MPU6050[3]) * ac_scale,\n        z: this.char2short(raw_data_MPU6050[4], raw_data_MPU6050[5]) * ac_scale,\n      },\n      temp:\n        this.char2short(raw_data_MPU6050[6], raw_data_MPU6050[7]) / 333.87 + 21,\n      gyroscope: {\n        x: this.char2short(raw_data_MPU6050[8], raw_data_MPU6050[9]) * gy_scale,\n        y:\n          this.char2short(raw_data_MPU6050[10], raw_data_MPU6050[11]) *\n          gy_scale,\n        z:\n          this.char2short(raw_data_MPU6050[12], raw_data_MPU6050[13]) *\n          gy_scale,\n      },\n    };\n  }\n\n  public char2short(valueH: number, valueL: number) {\n    const buffer = new ArrayBuffer(2);\n    const dv = new DataView(buffer);\n    dv.setUint8(0, valueH);\n    dv.setUint8(1, valueL);\n    return dv.getInt16(0, false);\n  }\n}\n"]}