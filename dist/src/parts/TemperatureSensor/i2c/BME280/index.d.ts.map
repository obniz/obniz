{"version":3,"sources":["../src/parts/TemperatureSensor/i2c/BME280/index.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAM,mBAAmB,CAAC;AACtC,OAAO,aAAa,MAAM,2CAA2C,CAAC;AACtE,OAAO,YAAY,MAAM,0CAA0C,CAAC;AAEpE,OAAO,mBAAmB,EAAE,EAAC,cAAc,EAAC,MAAM,uCAAuC,CAAC;AAE1F,MAAM,WAAW,aAAa;IAC5B,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,GAAG,CAAC,EAAE,GAAG,CAAC;CACV;AAEF,MAAM,CAAC,OAAO,OAAO,MAAO,YAAW,mBAAmB;WAE1C,IAAI,IAAI,cAAc;IAQ7B,YAAY,EAAE,MAAM,EAAE,CAAC;IACvB,IAAI,EAAE,MAAM,EAAE,CAAC;IACf,MAAM,EAAE,MAAM,EAAE,CAAC;IACjB,YAAY,EAAE,GAAG,CAAC;IAClB,QAAQ,EAAE,GAAG,CAAC;IACd,MAAM,EAAE,GAAG,CAAC;IACZ,MAAM,CAAC,EAAE,YAAY,CAAC;IACtB,OAAO,EAAE,GAAG,CAAC;IACb,MAAM,CAAC,EAAE,YAAY,CAAC;IAE7B,SAAS,CAAC,KAAK,EAAG,KAAK,CAAC;IACxB,SAAS,CAAC,GAAG,EAAG,aAAa,CAAC;IAE9B,OAAO,CAAC,WAAW,CAAM;IACzB,OAAO,CAAC,OAAO,CAAM;;IA4Cd,KAAK,CAAC,KAAK,EAAE,KAAK;IA4CZ,MAAM;IAmBN,cAAc,CAAC,OAAO,EAAE,GAAG;IAK3B,gBAAgB;IAgCtB,aAAa,CAAC,KAAK,EAAE,MAAM;IAO3B,YAAY,CAAC,KAAK,EAAE,MAAM;IAO1B,KAAK,CAAC,IAAI,EAAE,GAAG;IAIX,OAAO;IAKL,UAAU,IAAI,OAAO,CAAC;QAAE,WAAW,EAAE,MAAM,CAAC;QAAC,QAAQ,EAAE,MAAM,CAAC;QAAC,QAAQ,EAAE,MAAM,CAAA;KAAE,CAAC;IAcxF,aAAa,CAAC,KAAK,EAAE,GAAG;IAoBxB,aAAa,CAAC,KAAK,EAAE,GAAG;IAsBxB,aAAa,CAAC,KAAK,EAAE,GAAG;IAelB,WAAW,IAAI,OAAO,CAAC,MAAM,CAAC;IAI9B,WAAW,IAAI,OAAO,CAAC,MAAM,CAAC;IAI9B,eAAe,IAAI,OAAO,CAAC,MAAM,CAAC;IAIlC,eAAe;IAKrB,YAAY,CAAC,QAAQ,EAAE,MAAM,EAAE,WAAW,CAAC,EAAE,MAAM,GAAG,MAAM;CAQpE","file":"index.d.ts","sourcesContent":["import Obniz from \"../../../../obniz\";\nimport PeripheralI2C from \"../../../../obniz/libs/io_peripherals/i2c\";\nimport PeripheralIO from \"../../../../obniz/libs/io_peripherals/io\";\n\nimport ObnizPartsInterface, {ObnizPartsInfo} from \"../../../../obniz/ObnizPartsInterface\";\n\nexport interface BME280Options {\n  vio?: number;\n  vcore?: number;\n  gnd?: number;\n  csb?: number;\n  sdi?: number;\n  sck?: number;\n  sdo?: number;\n  address?: number;\n  i2c?: any;\n }\n\nexport default class BME280 implements ObnizPartsInterface {\n\n  public static info(): ObnizPartsInfo {\n    return {\n      name: \"BME280\",\n      datasheet:\n        \"https://ae-bst.resource.bosch.com/media/_tech/media/datasheets/BST-BME280_DS001-12.pdf\",\n    };\n  }\n\n  public requiredKeys: string[];\n  public keys: string[];\n  public ioKeys: string[];\n  public configration: any;\n  public commands: any;\n  public params: any;\n  public io_csb?: PeripheralIO;\n  public address: any;\n  public io_sdo?: PeripheralIO;\n\n  protected obniz!: Obniz;\n  protected i2c!: PeripheralI2C;\n\n  private _calibrated: any;\n  private _t_fine: any;\n\n  constructor() {\n    this.requiredKeys = [];\n    this.keys = [\n      \"vcore\",\n      \"vio\",\n      \"gnd\",\n      \"csb\",\n      \"sdi\",\n      \"sck\",\n      \"sdo\",\n      \"i2c\",\n      \"address\",\n    ];\n\n    this.ioKeys = [\"vcore\", \"vio\", \"gnd\", \"csb\", \"sdi\", \"sdo\", \"sck\"];\n\n    this.configration = {\n      sampling: {\n        temp: 1, // 0 never. 0b001 to 0b101\n        hum: 1,\n        pres: 1,\n      },\n      interval: 5, // 0b000 to 0b111\n      iir_strength: 0, // 000 to 100 (0=disable)\n      mode: 3,\n\n      Modes: {\n        sleep: 0,\n        forced: 1, // or 2\n        normal: 3,\n      },\n    };\n\n    this.commands = {};\n\n    this.commands.addresses = {\n      config: 0xf5,\n      ctrl_meas: 0xf4,\n      ctrl_hum: 0xf2,\n    };\n  }\n\n  public wired(obniz: Obniz) {\n    this.obniz = obniz;\n\n    if (obniz.isValidIO(this.params.csb)) {\n      // selecting I2C mode before powerup\n      this.io_csb = obniz.getIO(this.params.csb);\n      this.io_csb.drive(\"3v\");\n      this.io_csb.output(true);\n    }\n\n    this.obniz.setVccGnd(this.params.vio, null, \"3v\");\n    this.obniz.setVccGnd(this.params.vcore, null, \"3v\");\n    this.obniz.setVccGnd(null, this.params.gnd, \"5v\");\n    this.obniz.wait(10);\n\n    this.address = 0x76;\n    if (this.params.address === 0x76) {\n      this.address = 0x76;\n    } else if (this.params.address === 0x77) {\n      this.address = 0x77;\n    } else if (this.params.address !== undefined) {\n      throw new Error(\"address must be 0x76 or 0x77\");\n    }\n\n    if (obniz.isValidIO(this.params.sdo)) {\n      this.io_sdo = obniz.getIO(this.params.sdo);\n      this.io_sdo.drive(\"3v\");\n      this.io_sdo.output(this.address === 0x76 ? false : true);\n    }\n\n    this.params.sda = this.params.sda || this.params.sdi;\n    this.params.scl = this.params.scl || this.params.sck;\n    this.params.clock = this.params.clock || 100 * 1000;\n    this.params.mode = \"master\";\n    this.params.pull = \"3v\";\n    this.i2c = obniz.getI2CWithConfig(this.params);\n\n    this.obniz.wait(10);\n\n    this.config();\n\n    this.obniz.wait(10);\n  }\n\n  public async config() {\n    this.write([\n      this.commands.addresses.config,\n      (this.configration.interval << 5) |\n      (this.configration.iir_strength << 2) |\n      0,\n    ]);\n    this.write([\n      this.commands.addresses.ctrl_hum,\n      this.configration.sampling.hum,\n    ]);\n    this.write([\n      this.commands.addresses.ctrl_meas,\n      (this.configration.sampling.temp << 5) |\n      (this.configration.sampling.pres << 2) |\n      this.configration.mode,\n    ]);\n  }\n\n  public async setIIRStrength(strengh: any) {\n    this.configration.iir_strength = strengh;\n    this.config();\n  }\n\n  public async applyCalibration() {\n    this.i2c.write(this.address, [0x88]);\n    const data: any = await this.i2c.readWait(this.address, 24);\n    this.i2c.write(this.address, [0xa1]);\n    let data_next: any = await this.i2c.readWait(this.address, 1);\n    data.push(...data_next);\n    this.i2c.write(this.address, [0xe1]);\n    data_next = await this.i2c.readWait(this.address, 7);\n    data.push(...data_next);\n    this._calibrated = {\n      dig_T1: (data[1] << 8) | data[0],\n      dig_T2: this._readSigned16((data[3] << 8) | data[2]),\n      dig_T3: this._readSigned16((data[5] << 8) | data[4]),\n      dig_P1: (data[7] << 8) | data[6],\n      dig_P2: this._readSigned16((data[9] << 8) | data[8]),\n      dig_P3: this._readSigned16((data[11] << 8) | data[10]),\n      dig_P4: this._readSigned16((data[13] << 8) | data[12]),\n      dig_P5: this._readSigned16((data[15] << 8) | data[14]),\n      dig_P6: this._readSigned16((data[17] << 8) | data[16]),\n      dig_P7: this._readSigned16((data[19] << 8) | data[18]),\n      dig_P8: this._readSigned16((data[21] << 8) | data[20]),\n      dig_P9: this._readSigned16((data[23] << 8) | data[22]),\n      dig_H1: this._readSigned8(data[24]),\n      dig_H2: this._readSigned16((data[26] << 8) | data[25]),\n      dig_H3: this._readSigned8(data[27]),\n      dig_H4: this._readSigned16((data[28] << 4) | (0x0f & data[29])),\n      dig_H5: this._readSigned16((data[30] << 4) | ((data[29] >> 4) & 0x0f)),\n      dig_H6: this._readSigned8(data[31]),\n    };\n    this._t_fine = 0;\n  }\n\n  public _readSigned16(value: number) {\n    if (value >= 0x8000) {\n      value = value - 0x10000;\n    }\n    return value;\n  }\n\n  public _readSigned8(value: number) {\n    if (value >= 0x80) {\n      value = value - 0x100;\n    }\n    return value;\n  }\n\n  public write(data: any) {\n    this.i2c.write(this.address, data);\n}\n\npublic async getData() {\n    this.i2c.write(this.address, [0xf7]);\n    return await this.i2c.readWait(this.address, 8);\n  }\n\n  public async getAllWait(): Promise<{ temperature: number; humidity: number; pressure: number }> {\n    const data = await this.getData();\n\n    const press_raw = (data[0] << 12) | (data[1] << 4) | (data[2] >> 4);\n    const temp_raw = (data[3] << 12) | (data[4] << 4) | (data[5] >> 4);\n    const hum_raw = (data[6] << 8) | data[7];\n\n    const temperature = this.calibration_T(temp_raw) / 100.0;\n    const pressure = this.calibration_P(press_raw) / 100.0;\n    const humidity = this.calibration_H(hum_raw);\n\n    return {temperature, humidity, pressure};\n  }\n\n  public calibration_T(adc_T: any) {\n    let var1: any;\n    let var2: any;\n    let T: any;\n    var1 =\n      (((adc_T >> 3) - (this._calibrated.dig_T1 << 1)) *\n        this._calibrated.dig_T2) >>\n      11;\n    var2 =\n      (((((adc_T >> 4) - this._calibrated.dig_T1) *\n        ((adc_T >> 4) - this._calibrated.dig_T1)) >>\n        12) *\n        this._calibrated.dig_T3) >>\n      14;\n\n    this._t_fine = var1 + var2;\n    T = (this._t_fine * 5 + 128) >> 8;\n    return T;\n  }\n\n  public calibration_P(adc_P: any) {\n    let pvar1: any = this._t_fine / 2 - 64000;\n    let pvar2: any = (pvar1 * pvar1 * this._calibrated.dig_P6) / 32768;\n    pvar2 = pvar2 + pvar1 * this._calibrated.dig_P5 * 2;\n    pvar2 = pvar2 / 4 + this._calibrated.dig_P4 * 65536;\n    pvar1 =\n      ((this._calibrated.dig_P3 * pvar1 * pvar1) / 524288 +\n        this._calibrated.dig_P2 * pvar1) /\n      524288;\n    pvar1 = (1 + pvar1 / 32768) * this._calibrated.dig_P1;\n\n    if (pvar1 !== 0) {\n      let p: any = 1048576 - adc_P;\n      p = ((p - pvar2 / 4096) * 6250) / pvar1;\n      pvar1 = (this._calibrated.dig_P9 * p * p) / 2147483648;\n      pvar2 = (p * this._calibrated.dig_P8) / 32768;\n      p = p + (pvar1 + pvar2 + this._calibrated.dig_P7) / 16;\n      return p;\n    }\n    return 0;\n  }\n\n  public calibration_H(adc_H: any) {\n    let h: any = this._t_fine - 76800;\n    h =\n      (adc_H -\n        (this._calibrated.dig_H4 * 64 +\n          (this._calibrated.dig_H5 / 16384) * h)) *\n      ((this._calibrated.dig_H2 / 65536) *\n        (1 +\n          (this._calibrated.dig_H6 / 67108864) *\n          h *\n          (1 + (this._calibrated.dig_H3 / 67108864) * h)));\n    h = h * (1 - (this._calibrated.dig_H1 * h) / 524288);\n    return h;\n  }\n\n  public async getTempWait(): Promise<number> {\n    return (await this.getAllWait()).temperature;\n  }\n\n  public async getHumdWait(): Promise<number> {\n    return (await this.getAllWait()).humidity;\n  }\n\n  public async getPressureWait(): Promise<number> {\n    return (await this.getAllWait()).pressure;\n  }\n\n  public async getAltitudeWait() {\n    const pressure: any = await this.getPressureWait();\n    return this.calcAltitude(pressure);\n  }\n\n  public calcAltitude(pressure: number, seaPressure?: number): number {\n    if (typeof seaPressure !== \"number\") {\n      seaPressure = 1013.25;\n    }\n    return (\n      (1.0 - Math.pow(pressure / seaPressure, 1 / 5.2553)) * 145366.45 * 0.3048\n    );\n  }\n}\n"]}