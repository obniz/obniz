{"version":3,"sources":["../src/parts/Light/WS2812/index.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAM,gBAAgB,CAAC;AAEnC,OAAO,mBAAmB,EAAE,EAAC,cAAc,EAAC,MAAM,oCAAoC,CAAC;AAEvF,MAAM,WAAW,aAAa;IAC5B,GAAG,EAAE,MAAM,CAAC;IACZ,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,GAAG,CAAC,EAAE,MAAM,CAAC;CACd;AAED,MAAM,CAAC,OAAO,OAAO,MAAO,YAAW,mBAAmB;WAE1C,IAAI,IAAI,cAAc;IAMpC,OAAO,CAAC,MAAM,CAAC,iBAAiB;IA6BhC,OAAO,CAAC,MAAM,CAAC,cAAc;IAO7B,OAAO,CAAC,MAAM,CAAC,iBAAiB;IAqCzB,IAAI,EAAE,MAAM,EAAE,CAAC;IACf,YAAY,EAAE,MAAM,EAAE,CAAC;IACvB,MAAM,EAAE,GAAG,CAAC;IAEnB,SAAS,CAAC,KAAK,EAAG,KAAK,CAAC;IAExB,OAAO,CAAC,GAAG,CAAiB;;IAOrB,KAAK,CAAC,KAAK,EAAE,KAAK;IAYlB,GAAG,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM;IAI5C,GAAG,CAAC,GAAG,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM;IAIlD,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;IAW3C,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;CAUnD","file":"index.d.ts","sourcesContent":["import Obniz from \"../../../obniz\";\nimport PeripheralSPI from \"../../../obniz/libs/io_peripherals/spi\";\nimport ObnizPartsInterface, {ObnizPartsInfo} from \"../../../obniz/ObnizPartsInterface\";\n\nexport interface WS2812Options {\n  din: number;\n  vcc?: number;\n  gnd?: number;\n}\n\nexport default class WS2812 implements ObnizPartsInterface {\n\n  public static info(): ObnizPartsInfo {\n    return {\n      name: \"WS2812\",\n    };\n  }\n\n  private static _generateFromByte(val: any) {\n    // T0H 0.35us+-0.15us\n    // T1H 0.7us+-0.15us\n    // T0L 0.8us+-0.15us\n    // T1L 0.6us+-0.15us\n\n    // 0.3-0.9 and 0.6-0.6 at 3.33Mhz\n\n    val = parseInt(val);\n    const zero: any = 0x8;\n    const one: any = 0xc;\n    const ret: any = [];\n    for (let i = 0; i < 8; i += 2) {\n      let byte: any = 0;\n      if (val & (0x80 >> i)) {\n        byte = one << 4;\n      } else {\n        byte = zero << 4;\n      }\n      if (val & (0x80 >> (i + 1))) {\n        byte |= one;\n      } else {\n        byte |= zero;\n      }\n      ret.push(byte);\n    }\n    return ret;\n  }\n\n  private static _generateColor(r: any, g: any, b: any) {\n    let array: any = WS2812._generateFromByte(g);\n    array = array.concat(WS2812._generateFromByte(r));\n    array = array.concat(WS2812._generateFromByte(b));\n    return array;\n  }\n\n  private static _generateHsvColor(h: any, s: any, v: any) {\n    const C: any = v * s;\n    const Hp: any = h / 60;\n    const X: any = C * (1 - Math.abs((Hp % 2) - 1));\n\n    let R: any;\n    let G: any;\n    let B: any;\n    if (0 <= Hp && Hp < 1) {\n      [R, G, B] = [C, X, 0];\n    }\n    if (1 <= Hp && Hp < 2) {\n      [R, G, B] = [X, C, 0];\n    }\n    if (2 <= Hp && Hp < 3) {\n      [R, G, B] = [0, C, X];\n    }\n    if (3 <= Hp && Hp < 4) {\n      [R, G, B] = [0, X, C];\n    }\n    if (4 <= Hp && Hp < 5) {\n      [R, G, B] = [X, 0, C];\n    }\n    if (5 <= Hp && Hp < 6) {\n      [R, G, B] = [C, 0, X];\n    }\n\n    const m: any = v - C;\n    [R, G, B] = [R + m, G + m, B + m];\n\n    R = Math.floor(R * 255);\n    G = Math.floor(G * 255);\n    B = Math.floor(B * 255);\n\n    return WS2812._generateColor(R, G, B);\n  }\n\n  public keys: string[];\n  public requiredKeys: string[];\n  public params: any;\n\n  protected obniz!: Obniz;\n\n  private spi!: PeripheralSPI;\n\n  constructor() {\n    this.keys = [\"din\", \"vcc\", \"gnd\"];\n    this.requiredKeys = [\"din\"];\n  }\n\n  public wired(obniz: Obniz) {\n    this.obniz = obniz;\n\n    obniz.setVccGnd(this.params.vcc, this.params.gnd, \"5v\");\n\n    this.params.mode = \"master\";\n    this.params.frequency = Math.floor(3.33 * 1000 * 1000);\n    this.params.mosi = this.params.din;\n    this.params.drive = \"5v\"; // It over spec for frequency. But VIN-HI require 0.7VCC<=.\n    this.spi = this.obniz.getSpiWithConfig(this.params);\n  }\n\n  public rgb(red: number, green: number, blue: number) {\n    this.spi.write(WS2812._generateColor(red, green, blue));\n  }\n\n  public hsv(hue: number, saturation: number, value: number) {\n    this.spi.write(WS2812._generateHsvColor(hue, saturation, value));\n  }\n\n  public rgbs(array: Array<[number, number, number]>) {\n    let bytes: any = [];\n    for (let i = 0; i < array.length; i++) {\n      const oneArray: any = array[i];\n      bytes = bytes.concat(\n        WS2812._generateColor(oneArray[0], oneArray[1], oneArray[2]),\n      );\n    }\n    this.spi.write(bytes);\n  }\n\n  public hsvs(array: Array<[number, number, number]>) {\n    let bytes: any = [];\n    for (let i = 0; i < array.length; i++) {\n      const oneArray: any = array[i];\n      bytes = bytes.concat(\n        WS2812._generateHsvColor(oneArray[0], oneArray[1], oneArray[2]),\n      );\n    }\n    this.spi.write(bytes);\n  }\n}\n"]}