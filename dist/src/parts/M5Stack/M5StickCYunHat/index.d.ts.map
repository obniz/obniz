{"version":3,"sources":["../src/parts/M5Stack/M5StickCYunHat/index.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAM,gBAAgB,CAAC;AACnC,OAAO,aAAa,MAAM,wCAAwC,CAAC;AAEnE,OAAO,mBAAmB,EAAE,EAAC,cAAc,EAAC,MAAM,oCAAoC,CAAC;AACvF,OAAO,EAAC,uBAAuB,EAAC,MAAM,gBAAgB,CAAC;AACvD,OAAO,MAAM,MAAM,6BAA6B,CAAC;AACjD,OAAO,KAAK,MAAM,mCAAmC,CAAC;AAEtD,MAAM,WAAW,aAAc,SAAQ,uBAAuB;CAC7D;AAED,MAAM,CAAC,OAAO,OAAO,MAAO,YAAW,mBAAmB;WAE1C,IAAI,IAAI,cAAc;IAMpC,OAAO,CAAC,MAAM,CAAC,iBAAiB;IAqCzB,YAAY,EAAE,MAAM,EAAE,CAAC;IACvB,IAAI,EAAE,MAAM,EAAE,CAAC;IACf,MAAM,EAAE,GAAG,CAAC;IAEZ,MAAM,EAAE,MAAM,EAAE,CAAC;IAExB,SAAS,CAAC,KAAK,EAAG,KAAK,CAAC;IACxB,SAAS,CAAC,GAAG,EAAG,aAAa,CAAC;IAC9B,SAAS,CAAC,KAAK,EAAG,KAAK,CAAC;IACxB,SAAS,CAAC,MAAM,EAAG,MAAM,CAAC;IAG1B,OAAO,CAAC,OAAO,CAAM;;IAad,KAAK,CAAC,KAAK,EAAE,KAAK;IA6BlB,GAAG,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,GAAG,IAAI;IAWnD,GAAG,CAAC,GAAG,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM;IAQlD,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;IAQ3C,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;IAQrC,YAAY,IAAI,OAAO,CAAC,MAAM,CAAC;IAM/B,WAAW,IAAI,OAAO,CAAC,MAAM,CAAC;IAI9B,YAAY,IAAI,OAAO,CAAC,MAAM,CAAC;IAI/B,eAAe,IAAI,OAAO,CAAC,MAAM,CAAC;CAGhD","file":"index.d.ts","sourcesContent":["import Obniz from \"../../../obniz\";\r\nimport PeripheralI2C from \"../../../obniz/libs/io_peripherals/i2c\";\r\nimport ObnizUtil from \"../../../obniz/libs/utils/util\";\r\nimport ObnizPartsInterface, {ObnizPartsInfo} from \"../../../obniz/ObnizPartsInterface\";\r\nimport {I2cPartsAbstructOptions} from \"../../i2cParts\";\r\nimport BMP280 from \"../../PressureSensor/BMP280\";\r\nimport SHT20 from \"../../TemperatureSensor/i2c/SHT20\";\r\n\r\nexport interface YunHatOptions extends I2cPartsAbstructOptions {\r\n}\r\n\r\nexport default class YunHat implements ObnizPartsInterface {\r\n\r\n  public static info(): ObnizPartsInfo {\r\n    return {\r\n      name: \"YunHat\",\r\n    };\r\n  }\r\n\r\n  private static _generateHsvColor(h: number, s: number, v: number) {\r\n    const C: number = v * s;\r\n    const Hp: number = h / 60;\r\n    const X: number = C * (1 - Math.abs((Hp % 2) - 1));\r\n\r\n    let R: number = 0;\r\n    let G: number = 0;\r\n    let B: number = 0;\r\n    if (0 <= Hp && Hp < 1) {\r\n      [R, G, B] = [C, X, 0];\r\n    }\r\n    if (1 <= Hp && Hp < 2) {\r\n      [R, G, B] = [X, C, 0];\r\n    }\r\n    if (2 <= Hp && Hp < 3) {\r\n      [R, G, B] = [0, C, X];\r\n    }\r\n    if (3 <= Hp && Hp < 4) {\r\n      [R, G, B] = [0, X, C];\r\n    }\r\n    if (4 <= Hp && Hp < 5) {\r\n      [R, G, B] = [X, 0, C];\r\n    }\r\n    if (5 <= Hp && Hp < 6) {\r\n      [R, G, B] = [C, 0, X];\r\n    }\r\n\r\n    const m: number = v - C;\r\n    [R, G, B] = [R + m, G + m, B + m];\r\n\r\n    R = Math.floor(R * 255);\r\n    G = Math.floor(G * 255);\r\n    B = Math.floor(B * 255);\r\n\r\n    return {red: R, green: G, blue: B};\r\n  }\r\n\r\n  public requiredKeys: string[];\r\n  public keys: string[];\r\n  public params: any;\r\n\r\n  public ioKeys: string[];\r\n\r\n  protected obniz!: Obniz;\r\n  protected i2c!: PeripheralI2C;\r\n  protected sht20!: SHT20;\r\n  protected bmp280!: BMP280;\r\n\r\n  // ホントは14個あるが全部制御するとバグる\r\n  private LED_LEN = 13;\r\n\r\n  constructor() {\r\n    this.requiredKeys = [];\r\n    this.keys = [\r\n      \"sda\",\r\n      \"scl\",\r\n      \"i2c\",\r\n    ];\r\n\r\n    this.ioKeys = [\"sda\", \"scl\"];\r\n  }\r\n\r\n  public wired(obniz: Obniz) {\r\n    this.obniz = obniz;\r\n\r\n    this.params.clock = 100 * 1000; // for i2c\r\n    this.params.mode = \"master\"; // for i2c\r\n    this.params.pull = \"3v\"; // for i2c\r\n    this.i2c = obniz.getI2CWithConfig(this.params);\r\n    this.sht20 = obniz.wired(\"SHT20\",  {i2c: this.i2c});\r\n    this.bmp280 = obniz.wired(\"BMP280\",  {i2c: this.i2c});\r\n    this.bmp280.applyCalibration();\r\n  }\r\n\r\n  // public setColorCode(ledNum: number, colorCode: string) {\r\n  //   const hexConvert = (hex: string) => {\r\n  //     if (hex.slice(0, 1) === \"#\") {\r\n  //       hex = hex.slice(1);\r\n  //     }\r\n  //     if (hex.length === 3) {\r\n  //       hex = hex.slice(0, 1) + hex.slice(0, 1) + hex.slice(1, 2) + hex.slice(1, 2) + hex.slice(2, 3) + hex.slice(2, 3);\r\n  //     }\r\n  //\r\n  //     return [hex.slice(0, 2), hex.slice(2, 4), hex.slice(4, 6)].map((str) => {\r\n  //       return parseInt(str, 16);\r\n  //     });\r\n  //   };\r\n  //   const color: number[] = hexConvert(colorCode);\r\n  //   this.rgb(color[0], color[1], color[2]);\r\n  // }\r\n\r\n  public rgb(red: number, green: number, blue: number): void {\r\n    ObnizUtil.assertNumber(0, 255, \"red\", red);\r\n    ObnizUtil.assertNumber(0, 255, \"green\", green);\r\n    ObnizUtil.assertNumber(0, 255, \"blue\", blue);\r\n    const leds: Array<[number, number, number]> = [];\r\n    for (let i = 0; i < this.LED_LEN; i++) {\r\n      leds.push([red, green, blue]);\r\n    }\r\n    this.rgbs(leds);\r\n  }\r\n\r\n  public hsv(hue: number, saturation: number, value: number) {\r\n    ObnizUtil.assertNumber(0, 300, \"hue\", hue);\r\n    ObnizUtil.assertNumber(0, 1, \"saturation\", saturation);\r\n    ObnizUtil.assertNumber(0, 1, \"value\", value);\r\n    const color = YunHat._generateHsvColor(hue, saturation, value);\r\n    this.rgb(color.red, color.green, color.blue);\r\n  }\r\n\r\n  public rgbs(array: Array<[number, number, number]>) {\r\n    if (array.length <= this.LED_LEN ) {\r\n      array.forEach((value, index) => {\r\n        this.i2c.write(0x38, [0x01, index, Math.floor(value[0]), Math.floor(value[1]), Math.floor(value[2])]);\r\n      });\r\n    }\r\n}\r\n\r\n  public hsvs(array: Array<[number, number, number]>) {\r\n    const leds: Array<[number, number, number]> = array.map((value, index) => {\r\n      const color = YunHat._generateHsvColor(value[0], value[1], value[2]);\r\n      return [color.red, color.green, color.blue];\r\n    });\r\n    this.rgbs(leds);\r\n  }\r\n\r\n  public async getLightWait(): Promise<number> {\r\n    this.i2c.write(0x38, [0x00]);\r\n    const d = await this.i2c.readWait(0x38, 2);\r\n    return d[1] << 8 | d[0];\r\n  }\r\n\r\n  public async getTempWait(): Promise<number> {\r\n    return await this.sht20.getTempWait();\r\n  }\r\n\r\n  public async getHumidWait(): Promise<number> {\r\n    return await this.sht20.getHumidWait();\r\n  }\r\n\r\n  public async getPressureWait(): Promise<number> {\r\n    return await this.bmp280.getPressureWait();\r\n  }\r\n}\r\n"]}