{"version":3,"sources":["../src/parts/Grove/Grove_GPS/index.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,OAAO,KAAK,MAAM,gBAAgB,CAAC;AAGnC,OAAO,mBAAmB,EAAE,EAAC,cAAc,EAAC,MAAM,oCAAoC,CAAC;AAEvF;;GAEG;AACH,MAAM,WAAY,gBAAgB;IAChC,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,EAAE,EAAE,MAAM,CAAC;IACX,EAAE,EAAE,MAAM,CAAC;CACZ;AAED;;GAEG;AACH,MAAM,WAAY,mBAAmB;IACnC,MAAM,EAAE,OAAO,CAAC;IAChB,KAAK,EAAE,GAAG,CAAC;IACX,KAAK,EAAE,GAAG,CAAC;IACX,KAAK,EAAE,GAAG,CAAC;IACX,KAAK,EAAE,GAAG,EAAE,CAAC;IACb,KAAK,EAAE,GAAG,CAAC;IACX,KAAK,EAAE,GAAG,CAAC;IACX,KAAK,EAAE,GAAG,CAAC;IACX,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;IACnB,SAAS,EAAE,IAAI,CAAC;CACjB;AAED;;GAEG;AACH,MAAM,CAAC,OAAO,OAAO,SAAU,YAAW,mBAAmB;IAE3D,IAAI,QAAQ,WAEX;IAED,IAAI,SAAS,WAEZ;WAEa,IAAI,IAAI,cAAc;IAM7B,IAAI,EAAE,MAAM,EAAE,CAAC;IACf,YAAY,EAAE,MAAM,EAAE,CAAC;IACvB,MAAM,EAAE,MAAM,EAAE,CAAC;IACjB,WAAW,EAAE,GAAG,CAAC;IACjB,cAAc,EAAE,GAAG,CAAC;IAEpB,MAAM,EAAE,GAAG,CAAC;IAEZ,UAAU,EAAE,GAAG,CAAC;IAChB,OAAO,EAAE,GAAG,CAAC;IACb,MAAM,EAAE,GAAG,CAAC;IACZ,OAAO,EAAE,GAAG,CAAC;IACb,UAAU,EAAE,GAAG,CAAC;IAEvB,SAAS,CAAC,KAAK,EAAG,KAAK,CAAC;IAExB,OAAO,CAAC,IAAI,CAAkB;IAC9B,OAAO,CAAC,SAAS,CAAa;IAC9B,OAAO,CAAC,UAAU,CAAa;;IAWxB,KAAK,CAAC,KAAK,EAAE,KAAK;IAgClB,YAAY,IAAI,MAAM;IAatB,aAAa,IAAI,mBAAmB;IAoEpC,UAAU,CAAC,UAAU,CAAC,EAAE,mBAAmB,GAAG,GAAG;IAqGjD,OAAO,CAAC,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG;IAmB/B,UAAU,CAAC,MAAM,EAAE,GAAG;IAItB,WAAW,CAAC,MAAM,EAAE,GAAG;IAIvB,aAAa,CAAC,MAAM,EAAE,GAAG;IAWzB,cAAc,CAAC,OAAO,EAAE,GAAG;IAc3B,iBAAiB,CAAC,UAAU,EAAE,GAAG;IAejC,QAAQ,CAAC,GAAG,EAAE,GAAG,GAAG,MAAM;IAS1B,OAAO,CAAC,GAAG,EAAE,GAAG,GAAG,MAAM;IAQzB,OAAO,CAAC,GAAG,EAAE,GAAG,GAAG,MAAM;IASzB,MAAM,CAAC,GAAG,EAAE,GAAG,GAAG,MAAM;CAQhC","file":"index.d.ts","sourcesContent":["/**\n * @packageDocumentation\n * @module Parts\n */\n\nimport Obniz from \"../../../obniz\";\nimport PeripheralIO from \"../../../obniz/libs/io_peripherals/io\";\nimport PeripheralUART from \"../../../obniz/libs/io_peripherals/uart\";\nimport ObnizPartsInterface, {ObnizPartsInfo} from \"../../../obniz/ObnizPartsInterface\";\n\n/**\n * @category Parts\n */\nexport interface  Grove_GPSOptions {\n  vcc?: number;\n  gnd?: number;\n  tx: number;\n  rx: number;\n}\n\n/**\n * @category Parts\n */\nexport interface  Grove_GPSEditedData {\n  enable: boolean;\n  GPGGA: any;\n  GPGLL: any;\n  GPGSA: any;\n  GPGSV: any[];\n  GPRMC: any;\n  GPVTG: any;\n  GPZDA: any;\n  [key: string]: any;\n  timestamp: Date;\n}\n\n/**\n * @category Parts\n */\nexport default class Grove_GPS implements ObnizPartsInterface {\n  // -------------------\n  get latitude() {\n    return this.nmea2dd(this._latitude);\n  }\n\n  get longitude() {\n    return this.nmea2dd(this._longitude);\n  }\n\n  public static info(): ObnizPartsInfo {\n    return {\n      name: \"Grove_GPS\",\n    };\n  }\n\n  public keys: string[];\n  public requiredKeys: string[];\n  public ioKeys: string[];\n  public displayName: any;\n  public displayIoNames: any;\n\n  public params: any;\n\n  public editedData: any;\n  public gpsInfo: any;\n  public status: any;\n  public fixMode: any;\n  public gpsQuality: any;\n\n  protected obniz!: Obniz;\n\n  private uart!: PeripheralUART;\n  private _latitude: number = 0;\n  private _longitude: number = 0;\n\n  constructor() {\n    this.keys = [\"tx\", \"rx\", \"vcc\", \"gnd\"];\n    this.requiredKeys = [\"tx\", \"rx\"];\n\n    this.ioKeys = this.keys;\n    this.displayName = \"gps\";\n    this.displayIoNames = {tx: \"tx\", rx: \"rx\"};\n  }\n\n  public wired(obniz: Obniz) {\n    this.obniz = obniz;\n\n    this.obniz.setVccGnd(this.params.vcc, this.params.gnd, \"5v\");\n    this.uart = obniz.getFreeUart();\n    this.uart.start({\n      tx: this.params.tx,\n      rx: this.params.rx,\n      baud: 9600,\n    });\n\n    this.editedData = {};\n    this.editedData.enable = false;\n    this.editedData.GPGSV = new Array(4);\n\n    this.gpsInfo = {};\n    this.gpsInfo._sentenceType = {\n      GPGGA: 0x0001, // GGA - Global Positioning System Fix Data\n      GPGSA: 0x0002, // GSA - GNSS DOP and active satellites\n      GPGSV: 0x0004, // GSV - Satellites in view\n      GPRMC: 0x0008, // RMC - Recommended minimum specific GNSS data\n      GPVTG: 0x0010, // VTG - Track made good and ground speed\n      GPZDA: 0x0020, // ZDA - Date & Time\n    };\n    this.gpsInfo.status = \"V\";\n    this.gpsInfo.sentences = new Set(); // Set specifying sentence of MNEA from which data have been obtained\n    this.gpsInfo.satelliteInfo = {\n      satellites: [],\n      inView: 0,\n    };\n  }\n\n  public readSentence(): string {\n    let results: any = [];\n    if (this.uart.isDataExists()) {\n      const pos: any = this.uart.received.indexOf(0x0a);\n      if (pos >= 0) {\n        results = this.uart.received.slice(0, pos - 1);\n        this.uart.received.splice(0, pos + 1);\n        return this.uart.tryConvertString(results);\n      }\n    }\n    return \"\";\n  }\n\n  public getEditedData(): Grove_GPSEditedData {\n    let n: any;\n    let utc: any;\n    let format: any;\n    let sentence: any = this.readSentence();\n    this.editedData.enable = false;\n    this.editedData.GPGSV = new Array(4);\n    while (sentence.length > 0) {\n      const part: any = sentence.split(\",\");\n      if (sentence.slice(-4, -3) !== \",\") {\n        const st: any = part[part.length - 1].slice(0, -3);\n        part.push(part[part.length - 1].slice(-3));\n        part[part.length - 2] = st;\n      }\n      this.editedData.sentence = part.join(\",\");\n      switch (part[0]) {\n        case \"$GPGGA\":\n          this.editedData.GPGGA = part;\n          break;\n        case \"$GPGLL\":\n          this.editedData.GPGLL = part;\n          break;\n        case \"$GPGSA\":\n          this.editedData.GPGSA = part;\n          break;\n        case \"$GPGSV\":\n          n = Number(part[2]);\n          if (n > this.editedData.GPGSV.length) {\n            while (n > this.editedData.GPGSV.length) {\n              this.editedData.GPGSV.push([]);\n            }\n          }\n          this.editedData.GPGSV[n - 1] = part;\n          break;\n        case \"$GPRMC\":\n          this.editedData.GPRMC = part;\n          break;\n        case \"$GPVTG\":\n          this.editedData.GPVTG = part;\n          break;\n        case \"$GPZDA\":\n          this.editedData.GPZDA = part;\n          utc =\n            part[4] +\n            \"/\" +\n            part[3] +\n            \"/\" +\n            part[2] +\n            \" \" +\n            part[1].substring(0, 2) +\n            \":\" +\n            part[1].substring(2, 4) +\n            \":\" +\n            part[1].substring(4, 6) +\n            \" +00:00\";\n          this.editedData.timestamp = new Date(utc);\n          break;\n        default:\n          format = part[0].substr(1);\n          this.editedData[format] = part;\n      }\n\n      this.editedData.enable = true;\n      sentence = this.readSentence();\n    }\n    return this.editedData;\n  }\n\n  public getGpsInfo(editedData?: Grove_GPSEditedData): any {\n    const NMEA_SATINSENTENCE: any = 4;\n    const NMEA_MAXSAT: any = 12;\n    editedData = editedData || this.getEditedData();\n    this.gpsInfo.status = \"V\";\n    if (editedData.enable) {\n      if (editedData.GPGGA) {\n        const gga: any = editedData.GPGGA;\n        this.gpsInfo.gpsQuality = parseFloat(gga[6]); // Fix Quality: 0 = Invalid, 1 = GPS fix, 2 = DGPS fix\n        this.gpsInfo.hdop = parseFloat(gga[8]); // Horizontal Dilution of Precision (HDOP)\n        this.gpsInfo.altitude = parseFloat(gga[9]); // Antenna Altitude meters above mean sea level\n        const latitude: any = this.nmea2dd(parseFloat(gga[2]));\n        this.gpsInfo.latitude = gga[3] === \"N\" ? latitude : -latitude;\n        const longitude: any = this.nmea2dd(parseFloat(gga[4]));\n        this.gpsInfo.longitude = gga[5] === \"E\" ? longitude : -longitude;\n        this.gpsInfo.sentences.add(this.gpsInfo._sentenceType.GPGGA);\n      }\n      if (editedData.GPGSV) {\n        for (let n = 0; n < editedData.GPGSV.length; n++) {\n          if (editedData.GPGSV[n]) {\n            const gsv: any = editedData.GPGSV[n].map((v: any) => parseFloat(v));\n            const pack_count: any = gsv[1];\n            const pack_index: any = gsv[2];\n            const sat_count: any = gsv[3];\n            if (pack_index > pack_count) {\n              continue;\n            }\n\n            this.gpsInfo.satelliteInfo.inView = sat_count;\n            let nsat: any = (pack_index - 1) * NMEA_SATINSENTENCE;\n            nsat =\n              nsat + NMEA_SATINSENTENCE > sat_count\n                ? sat_count - nsat\n                : NMEA_SATINSENTENCE;\n\n            for (let isat = 0; isat < nsat; ++isat) {\n              const isi: any = (pack_index - 1) * NMEA_SATINSENTENCE + isat;\n              if (this.gpsInfo.satelliteInfo.satellites.length <= isi) {\n                this.gpsInfo.satelliteInfo.satellites.push({});\n              }\n              const isatn: any = isat * NMEA_SATINSENTENCE;\n              this.gpsInfo.satelliteInfo.satellites[isi] = {\n                id: gsv[isatn + 4], // SV PRN number\n                elevation: gsv[isatn + 5], // Elevation in degrees, 90 maximum\n                azimuth: gsv[isatn + 6], // Azimuth, degrees from true north, 000 to 359\n                snr: gsv[isatn + 7], // SNR, 00-99 dB (null when not tracking)\n                inUse: false,\n              };\n            }\n            this.gpsInfo.sentences.add(this.gpsInfo._sentenceType.GPGSV);\n          }\n        }\n      }\n      if (editedData.GPGSA) {\n        const gsa: any = editedData.GPGSA;\n        let nuse: any = 0;\n        this.gpsInfo.fixMode = parseFloat(gsa[2]); // Fix Mode: 1=Fix not available, 2=2D, 3=3D\n        this.gpsInfo.pdop = parseFloat(gsa[15]); // PDOP: Position Dilution of Precision\n        this.gpsInfo.hdop = parseFloat(gsa[16]); // HDOP: Horizontal Dilution of Precision\n        this.gpsInfo.vdop = parseFloat(gsa[17]); // VDOP: Vertical Dilution of Position\n        for (let i = 0; i < NMEA_MAXSAT; ++i) {\n          for (let j = 0; j < this.gpsInfo.satelliteInfo.inView; ++j) {\n            if (\n              this.gpsInfo.satelliteInfo.satellites[j] &&\n              gsa[i + 3] === this.gpsInfo.satelliteInfo.satellites[j].id\n            ) {\n              this.gpsInfo.satelliteInfo.satellites[j].inUse = true;\n              nuse++;\n            }\n          }\n        }\n        this.gpsInfo.satelliteInfo.inUse = nuse;\n        this.gpsInfo.sentences.add(this.gpsInfo._sentenceType.GPGSA);\n      }\n      if (editedData.GPRMC) {\n        const rmc: any = editedData.GPRMC;\n        this.gpsInfo.status = rmc[2]; // Status Active or Void\n        const latitude: any = this.nmea2dd(parseFloat(rmc[3]));\n        this.gpsInfo.latitude = rmc[4] === \"N\" ? latitude : -latitude;\n        const longitude: any = this.nmea2dd(parseFloat(rmc[5]));\n        this.gpsInfo.longitude = rmc[6] === \"E\" ? longitude : -longitude;\n        const NMEA_TUD_KNOTS: any = 1.852; // 1knot=1.852km/h\n        this.gpsInfo.speed = parseFloat(rmc[7]) * NMEA_TUD_KNOTS; // unit: km/h\n        this.gpsInfo.direction = rmc[8];\n        this.gpsInfo.sentences.add(this.gpsInfo._sentenceType.GPRMC);\n      }\n      if (editedData.GPVTG) {\n        const vtg: any = editedData.GPVTG;\n        this.gpsInfo.direction = parseFloat(vtg[1]);\n        this.gpsInfo.declination = parseFloat(vtg[3]);\n        this.gpsInfo.speed = parseFloat(vtg[7]);\n        this.gpsInfo.sentences.add(this.gpsInfo._sentenceType.GPVTG);\n      }\n      if (editedData.GPZDA) {\n        this.gpsInfo.utc = editedData.timestamp;\n        this.gpsInfo.sentences.add(this.gpsInfo._sentenceType.GPZDA);\n      }\n    }\n    return this.gpsInfo;\n  }\n\n  public _mneaTo(format: any, value: any) {\n    let result: any = this.nmea2dd(value);\n    if (typeof format === \"string\") {\n      switch (format.toUpperCase()) {\n        case \"DMS\":\n          result = this.nmea2dms(value);\n          break;\n        case \"DM\":\n          result = this.nmea2dm(value);\n          break;\n        case \"S\":\n          result = this.nmea2s(value);\n          break;\n        default:\n      }\n    }\n    return result;\n  }\n\n  public latitudeTo(format: any) {\n    return this._mneaTo(format, this._latitude);\n  }\n\n  public longitudeTo(format: any) {\n    return this._mneaTo(format, this._longitude);\n  }\n\n  public status2string(status: any) {\n    status = status || this.status;\n    if (status === \"A\") {\n      return \"Active\";\n    }\n    if (status === \"V\") {\n      return \"Void\";\n    }\n    return status;\n  }\n\n  public fixMode2string(fixMode: any) {\n    fixMode = fixMode || this.fixMode;\n    if (fixMode === 1) {\n      return \"Fix not available\";\n    }\n    if (fixMode === 2) {\n      return \"2D\";\n    }\n    if (fixMode === 3) {\n      return \"3D\";\n    }\n    return fixMode;\n  }\n\n  public gpsQuality2string(gpsQuality: any) {\n    gpsQuality = gpsQuality || this.gpsQuality;\n    if (gpsQuality === 0) {\n      return \"Invalid\";\n    }\n    if (gpsQuality === 1) {\n      return \"GPS fix\";\n    }\n    if (gpsQuality === 2) {\n      return \"DGPS fix\";\n    }\n    return gpsQuality;\n  }\n\n  // --- latitude/longitude MNEA format change to each unit\n  public nmea2dms(val: any): string {\n    // NMEA format to DMS format string (999째 99'99.9\")\n    val = parseFloat(val);\n    const d: any = Math.floor(val / 100);\n    const m: any = Math.floor((val / 100.0 - d) * 100.0);\n    const s: any = ((val / 100.0 - d) * 100.0 - m) * 60;\n    return d + \"째\" + m + \"'\" + s.toFixed(1) + '\"';\n  }\n\n  public nmea2dm(val: any): string {\n    // NMEA format to DM format string (999째 99.9999')\n    val = parseFloat(val);\n    const d: any = Math.floor(val / 100.0);\n    const m: any = (val / 100.0 - d) * 100.0;\n    return d + \"째\" + m.toFixed(4) + \"'\";\n  }\n\n  public nmea2dd(val: any): number {\n    // NMEA format to DD format decimal (999.999999)\n    val = parseFloat(val);\n    const d: any = Math.floor(val / 100.0);\n    const m: any = Math.floor(((val / 100.0 - d) * 100.0) / 60);\n    const s: any = (((val / 100.0 - d) * 100.0 - m) * 60) / (60 * 60);\n    return parseFloat((d + m + s).toFixed(6));\n  }\n\n  public nmea2s(val: any): number {\n    // NMEA format to S format decimal (99999.9999)\n    val = parseFloat(val);\n    const d: any = Math.floor(val / 100.0);\n    const m: any = Math.floor(((val / 100.0 - d) * 100.0) / 60);\n    const s: any = (((val / 100.0 - d) * 100.0 - m) * 60) / (60 * 60);\n    return (d + m + s) / (1.0 / 60.0 / 60.0);\n  }\n}\n"]}