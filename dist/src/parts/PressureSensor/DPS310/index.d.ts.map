{"version":3,"sources":["../src/parts/PressureSensor/DPS310/index.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAM,gBAAgB,CAAC;AAEnC,OAAO,mBAAmB,EAAE,EAAC,cAAc,EAAC,MAAM,oCAAoC,CAAC;AAEvF;;GAEG;AACH,MAAM,WAAY,aAAa;CAC9B;AAED;;GAEG;AACH,MAAM,CAAC,OAAO,OAAO,MAAO,YAAW,mBAAmB;WAE1C,IAAI,IAAI,cAAc;IAO7B,YAAY,EAAE,MAAM,EAAE,CAAC;IACvB,IAAI,EAAE,MAAM,EAAE,CAAC;IACf,MAAM,EAAE,MAAM,EAAE,CAAC;IACxB,OAAO,CAAC,YAAY,CAElB;IAEF,OAAO,CAAC,cAAc,CAAK;IAC3B,OAAO,CAAC,WAAW,CAAQ;IAC3B,OAAO,CAAC,kBAAkB,CAAK;IAC/B,OAAO,CAAC,mBAAmB,CAAK;IAChC,OAAO,CAAC,mBAAmB,CAAK;IAChC,OAAO,CAAC,oBAAoB,CAAK;IAEjC,OAAO,CAAC,iBAAiB,CAAK;IAC9B,OAAO,CAAC,oBAAoB,CAAM;IAClC,OAAO,CAAC,wBAAwB,CAAM;IACtC,OAAO,CAAC,oBAAoB,CAAM;IAClC,OAAO,CAAC,uBAAuB,CAAM;IACrC,OAAO,CAAC,KAAK,CAAK;IAClB,OAAO,CAAC,MAAM,CAAK;IACnB,OAAO,CAAC,MAAM,CAAK;IACnB,OAAO,CAAC,OAAO,CAAK;IACpB,OAAO,CAAC,cAAc,CAAK;IAC3B,OAAO,CAAC,IAAI,CASV;IACF,OAAO,CAAC,SAAS,CA4Ef;IAEF,OAAO,CAAC,SAAS,CAaf;IACF,OAAO,CAAC,aAAa,CASnB;IACF,OAAO,CAAC,MAAM,CAAM;IACpB,OAAO,CAAC,MAAM,CAAM;IACpB,OAAO,CAAC,KAAK,CAAS;IACtB,OAAO,CAAC,OAAO,CAAM;IACrB,OAAO,CAAC,MAAM,CAAM;IACpB,OAAO,CAAC,GAAG,CAAiB;;IAYrB,KAAK,CAAC,KAAK,EAAE,KAAK;IAYZ,QAAQ,IAAI,OAAO,CAAC,IAAI,CAAC;IAkCzB,uBAAuB,CAAC,gBAAgB,EAAE,GAAG;YAU5C,YAAY;YAOZ,oBAAoB;YAiBpB,aAAa;YASb,aAAa;YASb,iBAAiB;YAOjB,mBAAmB;YAQnB,aAAa;YAYb,WAAW;YAMX,cAAc;YAoBd,kBAAkB;YAgBlB,cAAc;YAmDd,mBAAmB;YAwCnB,wBAAwB;YAKxB,4BAA4B;IAK1C,OAAO,CAAC,YAAY;IAcpB,OAAO,CAAC,QAAQ;YAQF,eAAe;YAUf,mBAAmB;YASnB,WAAW;YAUX,eAAe;CAQ9B","file":"index.d.ts","sourcesContent":["import Obniz from \"../../../obniz\";\nimport PeripheralI2C from \"../../../obniz/libs/io_peripherals/i2c\";\nimport ObnizPartsInterface, {ObnizPartsInfo} from \"../../../obniz/ObnizPartsInterface\";\n\n/**\n * @category Parts\n */\nexport interface  DPS310Options {\n}\n\n/**\n * @category Parts\n */\nexport default class DPS310 implements ObnizPartsInterface {\n\n  public static info(): ObnizPartsInfo {\n    return {\n      name: \"DPS310\",\n      datasheet: \"\",\n    };\n  }\n\n  public requiredKeys: string[];\n  public keys: string[];\n  public ioKeys: string[];\n  private configration = {\n    DPS310__STD_SLAVE_ADDRESS: 0x77,\n  };\n\n  private DPS310__OSR_SE = 3;\n  private DPS310__LSB = 0x01;\n  private DPS310__PRS_STD_MR = 2;\n  private DPS310__PRS_STD_OSR = 3;\n  private DPS310__TEMP_STD_MR = 2;\n  private DPS310__TEMP_STD_OSR = 3;\n\n  private DPS310__SUCCEEDED = 0;\n  private DPS310__FAIL_UNKNOWN = -1;\n  private DPS310__FAIL_INIT_FAILED = -2;\n  private DPS310__FAIL_TOOBUSY = -3;\n  private DPS310__FAIL_UNFINISHED = -4;\n  private prsMr = 0;\n  private prsOsr = 0;\n  private tempMr = 0;\n  private tempOsr = 0;\n  private m_lastTempScal = 0;\n  private mode = {\n    IDLE: 0x00,\n    CMD_PRS: 0x01,\n    CMD_TEMP: 0x02,\n    INVAL_OP_CMD_BOTH: 0x03, // invalid\n    INVAL_OP_CONT_NONE: 0x04, // invalid\n    CONT_PRS: 0x05,\n    CONT_TMP: 0x06,\n    CONT_BOTH: 0x07,\n  };\n  private bitFileds = {\n    DPS310__REG_INFO_PROD_ID: {\n      address: 0x0d,\n      mask: 0x0f,\n      shift: 0,\n    },\n    DPS310__REG_INFO_REV_ID: {\n      address: 0x0d,\n      mask: 0xf0,\n      shift: 4,\n    },\n    DPS310__REG_INFO_TEMP_SENSORREC: {\n      address: 0x28,\n      mask: 0x80,\n      shift: 7,\n    },\n    DPS310__REG_INFO_TEMP_SENSOR: {\n      address: 0x07,\n      mask: 0x80,\n      shift: 7,\n    },\n    DPS310__REG_INFO_OPMODE: {\n      address: 0x08,\n      mask: 0x07,\n      shift: 0,\n    },\n    DPS310__REG_INFO_FIFO_FL: {\n      address: 0x0c,\n      mask: 0x80,\n      shift: 7,\n    },\n    DPS310__REG_INFO_FIFO_EN: {\n      address: 0x09,\n      mask: 0x02,\n      shift: 1,\n    },\n    DPS310__REG_INFO_TEMP_MR: {\n      address: 0x07,\n      mask: 0x70,\n      shift: 4,\n    },\n    DPS310__REG_INFO_TEMP_OSR: {\n      address: 0x07,\n      mask: 0x07,\n      shift: 0,\n    },\n    DPS310__REG_INFO_PRS_MR: {\n      address: 0x06,\n      mask: 0x70,\n      shift: 4,\n    },\n    DPS310__REG_INFO_PRS_OSR: {\n      address: 0x06,\n      mask: 0x07,\n      shift: 0,\n    },\n    DPS310__REG_INFO_PRS_SE: {\n      address: 0x09,\n      mask: 0x04,\n      shift: 2,\n    },\n    DPS310__REG_INFO_PRS_RDY: {\n      address: 0x08,\n      mask: 0x10,\n      shift: 4,\n    },\n    DPS310__REG_INFO_TEMP_SE: {\n      address: 0x09,\n      mask: 0x08,\n      shift: 3,\n    },\n    DPS310__REG_INFO_TEMP_RDY: {\n      address: 0x08,\n      mask: 0x20,\n      shift: 5,\n    },\n  };\n\n  private dataBlock = {\n    DPS310__REG_ADR_COEF: {\n      address: 0x10,\n      length: 18,\n    },\n    DPS310__REG_ADR_PRS: {\n      address: 0x00,\n      length: 3,\n    },\n    DPS310__REG_ADR_TEMP: {\n      address: 0x03,\n      length: 3,\n    },\n  };\n  private scaling_facts = [\n    524288,\n    1572864,\n    3670016,\n    7864320,\n    253952,\n    516096,\n    1040384,\n    2088960,\n  ];\n  private opMode: any;\n  private coeffs: any;\n  private obniz!: Obniz;\n  private address: any;\n  private params: any;\n  private i2c!: PeripheralI2C;\n\n  constructor() {\n    this.requiredKeys = [\"sda\", \"scl\"];\n    this.keys = [\"gpio3\", \"vcc\", \"gnd\", \"scl\", \"sda\"];\n    this.ioKeys = [\"gpio3\", \"vcc\", \"gnd\", \"scl\", \"sda\"];\n\n    this.coeffs = {};\n\n    this.opMode = this.mode.IDLE;\n  }\n\n  public wired(obniz: Obniz) {\n    this.obniz = obniz;\n    this.address = 0x77;\n    this.params.sda = this.params.sda;\n    this.params.scl = this.params.scl;\n    this.params.clock = this.params.clock || 100 * 1000;\n    this.params.mode = \"master\";\n    this.params.pull = \"3v\";\n    this.i2c = obniz.getI2CWithConfig(this.params);\n    this.obniz.wait(10);\n  }\n\n  public async initWait(): Promise<void> {\n    const prodId: any = await this.readByteBitfieldWait(\n      this.bitFileds.DPS310__REG_INFO_PROD_ID,\n    );\n    if (prodId !== 0) {\n      throw new Error(\"invalid prodId\");\n    }\n    await this.readByteBitfieldWait(this.bitFileds.DPS310__REG_INFO_REV_ID);\n\n    await this.readByteBitfieldWait(\n      this.bitFileds.DPS310__REG_INFO_TEMP_SENSORREC,\n    );\n\n    await this.writeByteBitfield(\n      this.bitFileds.DPS310__REG_INFO_TEMP_SENSOR,\n      0,\n    );\n\n    await this.readCoeffsWait();\n    await this.standbyWait();\n    await this.configTempWait(\n      this.DPS310__TEMP_STD_MR,\n      this.DPS310__TEMP_STD_OSR,\n    );\n    await this.configPressureWait(\n      this.DPS310__PRS_STD_MR,\n      this.DPS310__PRS_STD_OSR,\n    );\n    await this.standbyWait();\n    await this.measureTempOnceWait();\n    await this.standbyWait();\n    await this.correctTempWait();\n  }\n\n  public async measurePressureOnceWait(oversamplingRate: any) {\n    if (oversamplingRate === undefined) {\n      oversamplingRate = this.prsOsr;\n    }\n    await this.startMeasurePressureOnceWait(oversamplingRate);\n    await this.obniz.wait(100);\n    const ret: any = await this.getSingleResultWait();\n    return ret;\n  }\n\n  private async readByteWait(regAddress: any): Promise<number> {\n    this.i2c.write(this.address, [regAddress]);\n    await this.obniz.wait(1);\n    const results: number[] = await this.i2c.readWait(this.address, 1);\n    return results[0];\n  }\n\n  private async readByteBitfieldWait(field: any): Promise<number> {\n    const regAddress: any = field.address;\n    const mask: any = field.mask;\n    const shift: any = field.shift;\n    let ret: number = await this.readByteWait(regAddress);\n    if (ret < 0) {\n      return ret;\n    }\n    if (mask !== undefined) {\n      ret = ret & mask;\n    }\n    if (shift !== undefined) {\n      ret = ret >> shift;\n    }\n    return ret;\n  }\n\n  private async readBlockWait(datablock: any): Promise<number[]> {\n    const address: any = datablock.address;\n    const length: any = datablock.length;\n    await this.obniz.wait(1);\n    this.i2c.write(this.address, [address]);\n    const results: number[] = await this.i2c.readWait(this.address, length);\n    return results;\n  }\n\n  private async writeByteWait(regAddress: any, data: any, check?: any): Promise<void> {\n    this.i2c.write(this.address, [regAddress, data]);\n    if (check) {\n      if ((await this.readByteWait(regAddress)) !== data) {\n        throw new Error(\"DPS310 data write failed\");\n      }\n    }\n  }\n\n  private async writeByteBitfield(field: any, data: any, check?: any): Promise<void> {\n    const old: any = await this.readByteWait(field.address);\n    const sendData: any = (old & ~field.mask) | ((data << field.shift) & field.mask);\n\n    await this.writeByteWait(field.address, sendData, check);\n  }\n\n  private async setOpModeDetailWait(background: any, temperature: any, pressure: any): Promise<void> {\n    const opMode: any =\n      ((background & this.DPS310__LSB) << 2) |\n      ((temperature & this.DPS310__LSB) << 1) |\n      (pressure & this.DPS310__LSB);\n    return await this.setOpModeWait(opMode);\n  }\n\n  private async setOpModeWait(opMode: any): Promise<void> {\n    opMode &=\n      this.bitFileds.DPS310__REG_INFO_OPMODE.mask >>\n      this.bitFileds.DPS310__REG_INFO_OPMODE.shift;\n\n    await this.writeByteWait(\n      this.bitFileds.DPS310__REG_INFO_OPMODE.address,\n      opMode,\n    );\n    this.opMode = opMode;\n  }\n\n  private async standbyWait(): Promise<void> {\n    this.setOpModeWait(this.mode.IDLE);\n    await this.writeByteBitfield(this.bitFileds.DPS310__REG_INFO_FIFO_FL, 1);\n    await this.writeByteBitfield(this.bitFileds.DPS310__REG_INFO_FIFO_EN, 0);\n  }\n\n  private async configTempWait(tempMr: any, tempOsr: any): Promise<void> {\n    await this.writeByteBitfield(\n      this.bitFileds.DPS310__REG_INFO_TEMP_MR,\n      tempMr,\n    );\n    await this.writeByteBitfield(\n      this.bitFileds.DPS310__REG_INFO_TEMP_OSR,\n      tempOsr,\n    );\n\n    if (tempOsr > this.DPS310__OSR_SE) {\n      await this.writeByteBitfield(this.bitFileds.DPS310__REG_INFO_TEMP_SE, 1);\n    } else {\n      await this.writeByteBitfield(this.bitFileds.DPS310__REG_INFO_TEMP_SE, 0);\n    }\n\n    this.tempMr = tempMr;\n    this.tempOsr = tempOsr;\n  }\n\n  private async configPressureWait(prsMr: any, prsOsr: any): Promise<void> {\n    await this.writeByteBitfield(this.bitFileds.DPS310__REG_INFO_PRS_MR, prsMr);\n    await this.writeByteBitfield(\n      this.bitFileds.DPS310__REG_INFO_PRS_OSR,\n      prsOsr,\n    );\n\n    if (prsOsr > this.DPS310__OSR_SE) {\n      await this.writeByteBitfield(this.bitFileds.DPS310__REG_INFO_PRS_SE, 1);\n    } else {\n      await this.writeByteBitfield(this.bitFileds.DPS310__REG_INFO_PRS_SE, 0);\n    }\n    this.prsMr = prsMr;\n    this.prsOsr = prsOsr;\n  }\n\n  private async readCoeffsWait(): Promise<void> {\n    const buffer: any = await this.readBlockWait(this.dataBlock.DPS310__REG_ADR_COEF);\n\n    this.coeffs.m_c0Half = (buffer[0] << 4) | ((buffer[1] >> 4) & 0x0f);\n    if (this.coeffs.m_c0Half & (1 << 11)) {\n      this.coeffs.m_c0Half -= 1 << 12;\n    }\n    this.coeffs.m_c0Half = this.coeffs.m_c0Half / 2;\n\n    this.coeffs.m_c1 = ((buffer[1] & 0x0f) << 8) | buffer[2];\n    if (this.coeffs.m_c1 & (1 << 11)) {\n      this.coeffs.m_c1 -= 1 << 12;\n    }\n    this.coeffs.m_c00 =\n      (buffer[3] << 12) | (buffer[4] << 4) | ((buffer[5] >> 4) & 0x0f);\n    if (this.coeffs.m_c00 & (1 << 19)) {\n      this.coeffs.m_c00 -= 1 << 20;\n    }\n\n    this.coeffs.m_c10 =\n      ((buffer[5] & 0x0f) << 16) | (buffer[6] << 8) | buffer[7];\n    if (this.coeffs.m_c10 & (1 << 19)) {\n      this.coeffs.m_c10 -= 1 << 20;\n    }\n\n    this.coeffs.m_c01 = (buffer[8] << 8) | buffer[9];\n    if (this.coeffs.m_c01 & (1 << 15)) {\n      this.coeffs.m_c01 -= 1 << 16;\n    }\n\n    this.coeffs.m_c11 = (buffer[10] << 8) | buffer[11];\n    if (this.coeffs.m_c11 & (1 << 15)) {\n      this.coeffs.m_c11 -= 1 << 16;\n    }\n\n    this.coeffs.m_c20 = (buffer[12] << 8) | buffer[13];\n    if (this.coeffs.m_c20 & (1 << 15)) {\n      this.coeffs.m_c20 -= 1 << 16;\n    }\n\n    this.coeffs.m_c21 = (buffer[14] << 8) | buffer[15];\n    if (this.coeffs.m_c21 & (1 << 15)) {\n      this.coeffs.m_c21 -= 1 << 16;\n    }\n\n    this.coeffs.m_c30 = (buffer[16] << 8) | buffer[17];\n    if (this.coeffs.m_c30 & (1 << 15)) {\n      this.coeffs.m_c30 -= 1 << 16;\n    }\n  }\n\n  private async getSingleResultWait(): Promise<number> {\n    let rdy: any;\n    switch (this.opMode) {\n      case this.mode.CMD_TEMP:\n        rdy = await this.readByteBitfieldWait(\n          this.bitFileds.DPS310__REG_INFO_TEMP_RDY,\n        );\n        break;\n      case this.mode.CMD_PRS:\n        rdy = await this.readByteBitfieldWait(\n          this.bitFileds.DPS310__REG_INFO_PRS_RDY,\n        );\n        break;\n      default:\n        return this.DPS310__FAIL_TOOBUSY;\n    }\n\n    let oldMode: any;\n    switch (rdy) {\n      case this.DPS310__FAIL_UNKNOWN:\n        throw new Error(\"DPS310__FAIL_UNKNOWN\");\n      case 0:\n        return this.obniz.wait(10).then(() => {\n          return this.getSingleResultWait();\n        });\n      case 1:\n        oldMode = this.opMode;\n        this.opMode = this.mode.IDLE;\n        switch (oldMode) {\n          case this.mode.CMD_TEMP:\n            return await this.getTempWait();\n          case this.mode.CMD_PRS:\n            return await this.getPressureWait();\n          default:\n            throw new Error(\"DPS310__FAIL_UNKNOWN\");\n        }\n    }\n    throw new Error(\"DPS310__FAIL_UNKNOWN\");\n  }\n\n  private async startMeasureTempOnceWait(oversamplingRate: any): Promise<void> {\n    await this.configTempWait(0, oversamplingRate);\n    await this.setOpModeDetailWait(0, 1, 0);\n  }\n\n  private async startMeasurePressureOnceWait(oversamplingRate: any): Promise<void> {\n    await this.configPressureWait(0, oversamplingRate);\n    await this.setOpModeDetailWait(0, 0, 1);\n  }\n\n  private calcPressure(raw: any): number {\n    let prs: any = raw;\n    prs /= this.scaling_facts[this.prsOsr];\n    prs =\n      this.coeffs.m_c00 +\n      prs *\n      (this.coeffs.m_c10 +\n        prs * (this.coeffs.m_c20 + prs * this.coeffs.m_c30)) +\n      this.m_lastTempScal *\n      (this.coeffs.m_c01 +\n        prs * (this.coeffs.m_c11 + prs * this.coeffs.m_c21));\n    return prs;\n  }\n\n  private calcTemp(raw: any): number {\n    let temp: any = raw;\n    temp /= this.scaling_facts[this.tempOsr];\n    this.m_lastTempScal = temp;\n    temp = this.coeffs.m_c0Half + this.coeffs.m_c1 * temp;\n    return temp;\n  }\n\n  private async correctTempWait(): Promise<void> {\n    this.writeByteWait(0x0e, 0xe5);\n    this.writeByteWait(0x0f, 0x96);\n    this.writeByteWait(0x62, 0x02);\n    this.writeByteWait(0x0e, 0x00);\n    this.writeByteWait(0x0f, 0x00);\n\n    await this.measureTempOnceWait();\n  }\n\n  private async measureTempOnceWait(oversamplingRate?: any): Promise<number> {\n    if (oversamplingRate === undefined) {\n      oversamplingRate = this.tempOsr;\n    }\n    await this.startMeasureTempOnceWait(oversamplingRate);\n    await this.obniz.wait(100);\n    return await this.getSingleResultWait();\n  }\n\n  private async getTempWait(): Promise<number> {\n    const data: any = await this.readBlockWait(this.dataBlock.DPS310__REG_ADR_TEMP);\n\n    let temp: any = (data[0] << 16) | (data[1] << 8) | data[2];\n    if (temp & (1 << 23)) {\n      temp -= 1 << 24;\n    }\n    return this.calcTemp(temp);\n  }\n\n  private async getPressureWait(): Promise<number> {\n    const data: any = await this.readBlockWait(this.dataBlock.DPS310__REG_ADR_PRS);\n    let prs: any = (data[0] << 16) | (data[1] << 8) | data[2];\n    if (prs & (1 << 23)) {\n      prs -= 1 << 24;\n    }\n    return this.calcPressure(prs);\n  }\n}\n"]}