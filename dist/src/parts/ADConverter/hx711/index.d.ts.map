{"version":3,"sources":["../src/parts/ADConverter/hx711/index.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAM,gBAAgB,CAAC;AACnC,OAAO,YAAY,MAAM,uCAAuC,CAAC;AACjE,OAAO,aAAa,MAAM,wCAAwC,CAAC;AACnE,OAAO,mBAAmB,EAAE,EAAC,cAAc,EAAC,MAAM,oCAAoC,CAAC;AAEvF,MAAM,WAAW,YAAY;IAC3B,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,GAAG,EAAE,MAAM,CAAC;IACZ,IAAI,EAAE,MAAM,CAAC;CACd;AAED,MAAM,CAAC,OAAO,OAAO,KAAM,YAAW,mBAAmB;WAEzC,IAAI,IAAI,cAAc;IAM7B,IAAI,EAAE,MAAM,EAAE,CAAC;IACf,YAAY,EAAE,MAAM,EAAE,CAAC;IACvB,OAAO,EAAE,GAAG,CAAC;IACb,MAAM,EAAE,GAAG,CAAC;IACZ,KAAK,EAAG,KAAK,CAAC;IACd,GAAG,EAAG,aAAa,CAAC;IACpB,MAAM,EAAE,GAAG,CAAC;IACZ,GAAG,EAAG,YAAY,CAAC;IACnB,IAAI,EAAG,YAAY,CAAC;;IASpB,KAAK,CAAC,KAAK,EAAE,KAAK;IAkBZ,QAAQ;IAoCd,mBAAmB,CAAC,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,MAAM;IAaxC,GAAG,CAAC,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,MAAM;IAIlB,eAAe,CAAC,KAAK,EAAE,GAAG;IAYhC,SAAS;IAIT,OAAO;IAID,cAAc,CAAC,KAAK,EAAE,MAAM,GAAG,GAAG,GAAG,OAAO,CAAC,IAAI,CAAC;IAKlD,YAAY,CAAC,KAAK,EAAE,MAAM,GAAG,GAAG,GAAG,OAAO,CAAC,MAAM,CAAC;IAMxD,SAAS,CAAC,MAAM,EAAE,GAAG;IAOrB,QAAQ,CAAC,KAAK,EAAE,GAAG;CAM3B","file":"index.d.ts","sourcesContent":["import Obniz from \"../../../obniz\";\r\nimport PeripheralIO from \"../../../obniz/libs/io_peripherals/io\";\r\nimport PeripheralSPI from \"../../../obniz/libs/io_peripherals/spi\";\r\nimport ObnizPartsInterface, {ObnizPartsInfo} from \"../../../obniz/ObnizPartsInterface\";\r\n\r\nexport interface Hx711Options {\r\n  vcc?: number;\r\n  gnd?: number;\r\n  sck: number;\r\n  dout: number;\r\n}\r\n\r\nexport default class Hx711 implements ObnizPartsInterface {\r\n\r\n  public static info(): ObnizPartsInfo {\r\n    return {\r\n      name: \"hx711\",\r\n    };\r\n  }\r\n\r\n  public keys: string[];\r\n  public requiredKeys: string[];\r\n  public _offset: any;\r\n  public _scale: any;\r\n  public obniz!: Obniz;\r\n  public spi!: PeripheralSPI;\r\n  public params: any;\r\n  public sck!: PeripheralIO;\r\n  public dout!: PeripheralIO;\r\n\r\n  constructor() {\r\n    this.keys = [\"vcc\", \"gnd\", \"sck\", \"dout\"];\r\n    this.requiredKeys = [\"sck\", \"dout\"];\r\n    this._offset = 0;\r\n    this._scale = 1;\r\n  }\r\n\r\n  public wired(obniz: Obniz) {\r\n    this.obniz = obniz;\r\n    this.spi = obniz.getFreeSpi();\r\n    obniz.setVccGnd(this.params.vcc, this.params.gnd, \"5v\");\r\n\r\n    const ioKeys: any = [\"clk\", \"dout\"];\r\n    for (const key of ioKeys) {\r\n      if (this.params[key] && !this.obniz.isValidIO(this.params[key])) {\r\n        throw new Error(\"spi start param '\" + key + \"' are to be valid io no\");\r\n      }\r\n    }\r\n    this.sck = obniz.getIO(this.params.sck);\r\n    this.dout = obniz.getIO(this.params.dout);\r\n\r\n    this.sck.output(true);\r\n    obniz.wait(500);\r\n  }\r\n\r\n  public async readWait() {\r\n    this.sck.output(false);\r\n\r\n    while (true) {\r\n      const val: any = await this.dout.inputWait();\r\n      if (val === false) {\r\n        break;\r\n      }\r\n    }\r\n    this.spi.start({\r\n      mode: \"master\",\r\n      mosi: this.params.sck,\r\n      miso: this.params.dout,\r\n      frequency: 500 * 1000,\r\n    });\r\n\r\n    const ret_double: any = await this.spi.writeWait([\r\n      0xaa,\r\n      0xaa,\r\n      0xaa,\r\n      0xaa,\r\n      0xaa,\r\n      0xaa,\r\n      0x80,\r\n    ]);\r\n    this.spi.end(true);\r\n    this.sck.output(false);\r\n    const ret: any = [\r\n      this.doubleBit2singleBit(ret_double[0], ret_double[1]),\r\n      this.doubleBit2singleBit(ret_double[2], ret_double[3]),\r\n      this.doubleBit2singleBit(ret_double[4], ret_double[5]),\r\n    ];\r\n    const flag: any = (ret[0] & 0x80) === 0 ? 1 : -1;\r\n    return flag * (((ret[0] & 0x7f) << 16) + (ret[1] << 8) + (ret[2] << 0));\r\n  }\r\n\r\n  public doubleBit2singleBit(a: number, b: number) {\r\n    return (\r\n      (this.bit(a, 7) << 7) |\r\n      (this.bit(a, 5) << 6) |\r\n      (this.bit(a, 3) << 5) |\r\n      (this.bit(a, 1) << 4) |\r\n      (this.bit(b, 7) << 3) |\r\n      (this.bit(b, 5) << 2) |\r\n      (this.bit(b, 3) << 1) |\r\n      (this.bit(b, 1) << 0)\r\n    );\r\n  }\r\n\r\n  public bit(a: number, n: number) {\r\n    return a & (1 << n) ? 1 : 0;\r\n  }\r\n\r\n  public async readAverageWait(times: any) {\r\n    const results: any = [];\r\n    for (let i = 0; i < times; i++) {\r\n      results.push(await this.readWait());\r\n    }\r\n    return (\r\n      results.reduce((prev: any, current: any, i: any) => {\r\n        return prev + current;\r\n      }, 0) / results.length\r\n    );\r\n  }\r\n\r\n  public powerDown() {\r\n    this.sck.output(true);\r\n  }\r\n\r\n  public powerUp() {\r\n    this.sck.output(false);\r\n  }\r\n\r\n  public async zeroAdjustWait(times: number | any): Promise<void>  {\r\n    times = parseInt(times) || 1;\r\n    this._offset = await this.readAverageWait(times);\r\n  }\r\n\r\n  public async getValueWait(times: number | any): Promise<number> {\r\n    times = parseInt(times) || 1;\r\n    const val: any = await this.readAverageWait(times);\r\n    return (val - this._offset) / this._scale;\r\n  }\r\n\r\n  public setOffset(offset: any) {\r\n    if (typeof offset !== \"number\") {\r\n      throw new Error(\"offset variable is Number\");\r\n    }\r\n    this._offset = offset;\r\n  }\r\n\r\n  public setScale(scale: any) {\r\n    if (typeof scale !== \"number\") {\r\n      throw new Error(\"scale variable is Number\");\r\n    }\r\n    this._scale = scale;\r\n  }\r\n}\r\n"]}