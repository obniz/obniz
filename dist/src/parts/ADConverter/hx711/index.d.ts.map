{"version":3,"sources":["../src/parts/ADConverter/hx711/index.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAM,gBAAgB,CAAC;AACnC,OAAO,YAAY,MAAM,uCAAuC,CAAC;AACjE,OAAO,aAAa,MAAM,wCAAwC,CAAC;AACnE,OAAO,mBAAmB,EAAE,EAAC,cAAc,EAAC,MAAM,oCAAoC,CAAC;AAEvF;;GAEG;AACH,MAAM,WAAY,YAAY;IAC5B,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,GAAG,EAAE,MAAM,CAAC;IACZ,IAAI,EAAE,MAAM,CAAC;CACd;AAED;;GAEG;AACH,MAAM,CAAC,OAAO,OAAO,KAAM,YAAW,mBAAmB;WAEzC,IAAI,IAAI,cAAc;IAM7B,IAAI,EAAE,MAAM,EAAE,CAAC;IACf,YAAY,EAAE,MAAM,EAAE,CAAC;IACvB,OAAO,EAAE,GAAG,CAAC;IACb,MAAM,EAAE,GAAG,CAAC;IACZ,KAAK,EAAG,KAAK,CAAC;IACd,GAAG,EAAG,aAAa,CAAC;IACpB,MAAM,EAAE,GAAG,CAAC;IACZ,GAAG,EAAG,YAAY,CAAC;IACnB,IAAI,EAAG,YAAY,CAAC;;IASpB,KAAK,CAAC,KAAK,EAAE,KAAK;IAkBZ,QAAQ;IAoCd,mBAAmB,CAAC,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,MAAM;IAaxC,GAAG,CAAC,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,MAAM;IAIlB,eAAe,CAAC,KAAK,EAAE,GAAG;IAYhC,SAAS;IAIT,OAAO;IAID,cAAc,CAAC,KAAK,EAAE,MAAM,GAAG,GAAG;IAKlC,YAAY,CAAC,KAAK,EAAE,MAAM,GAAG,GAAG,GAAG,OAAO,CAAC,MAAM,CAAC;IAMxD,SAAS,CAAC,MAAM,EAAE,GAAG;IAOrB,QAAQ,CAAC,KAAK,EAAE,GAAG;CAM3B","file":"index.d.ts","sourcesContent":["import Obniz from \"../../../obniz\";\nimport PeripheralIO from \"../../../obniz/libs/io_peripherals/io\";\nimport PeripheralSPI from \"../../../obniz/libs/io_peripherals/spi\";\nimport ObnizPartsInterface, {ObnizPartsInfo} from \"../../../obniz/ObnizPartsInterface\";\n\n/**\n * @category Parts\n */\nexport interface  Hx711Options {\n  vcc?: number;\n  gnd?: number;\n  sck: number;\n  dout: number;\n}\n\n/**\n * @category Parts\n */\nexport default class Hx711 implements ObnizPartsInterface {\n\n  public static info(): ObnizPartsInfo {\n    return {\n      name: \"hx711\",\n    };\n  }\n\n  public keys: string[];\n  public requiredKeys: string[];\n  public _offset: any;\n  public _scale: any;\n  public obniz!: Obniz;\n  public spi!: PeripheralSPI;\n  public params: any;\n  public sck!: PeripheralIO;\n  public dout!: PeripheralIO;\n\n  constructor() {\n    this.keys = [\"vcc\", \"gnd\", \"sck\", \"dout\"];\n    this.requiredKeys = [\"sck\", \"dout\"];\n    this._offset = 0;\n    this._scale = 1;\n  }\n\n  public wired(obniz: Obniz) {\n    this.obniz = obniz;\n    this.spi = obniz.getFreeSpi();\n    obniz.setVccGnd(this.params.vcc, this.params.gnd, \"5v\");\n\n    const ioKeys: any = [\"clk\", \"dout\"];\n    for (const key of ioKeys) {\n      if (this.params[key] && !this.obniz.isValidIO(this.params[key])) {\n        throw new Error(\"spi start param '\" + key + \"' are to be valid io no\");\n      }\n    }\n    this.sck = obniz.getIO(this.params.sck);\n    this.dout = obniz.getIO(this.params.dout);\n\n    this.sck.output(true);\n    obniz.wait(500);\n  }\n\n  public async readWait() {\n    this.sck.output(false);\n\n    while (true) {\n      const val: any = await this.dout.inputWait();\n      if (val === false) {\n        break;\n      }\n    }\n    this.spi.start({\n      mode: \"master\",\n      mosi: this.params.sck,\n      miso: this.params.dout,\n      frequency: 500 * 1000,\n    });\n\n    const ret_double: any = await this.spi.writeWait([\n      0xaa,\n      0xaa,\n      0xaa,\n      0xaa,\n      0xaa,\n      0xaa,\n      0x80,\n    ]);\n    this.spi.end(true);\n    this.sck.output(false);\n    const ret: any = [\n      this.doubleBit2singleBit(ret_double[0], ret_double[1]),\n      this.doubleBit2singleBit(ret_double[2], ret_double[3]),\n      this.doubleBit2singleBit(ret_double[4], ret_double[5]),\n    ];\n    const flag: any = (ret[0] & 0x80) === 0 ? 1 : -1;\n    return flag * (((ret[0] & 0x7f) << 16) + (ret[1] << 8) + (ret[2] << 0));\n  }\n\n  public doubleBit2singleBit(a: number, b: number) {\n    return (\n      (this.bit(a, 7) << 7) |\n      (this.bit(a, 5) << 6) |\n      (this.bit(a, 3) << 5) |\n      (this.bit(a, 1) << 4) |\n      (this.bit(b, 7) << 3) |\n      (this.bit(b, 5) << 2) |\n      (this.bit(b, 3) << 1) |\n      (this.bit(b, 1) << 0)\n    );\n  }\n\n  public bit(a: number, n: number) {\n    return a & (1 << n) ? 1 : 0;\n  }\n\n  public async readAverageWait(times: any) {\n    const results: any = [];\n    for (let i = 0; i < times; i++) {\n      results.push(await this.readWait());\n    }\n    return (\n      results.reduce((prev: any, current: any, i: any) => {\n        return prev + current;\n      }, 0) / results.length\n    );\n  }\n\n  public powerDown() {\n    this.sck.output(true);\n  }\n\n  public powerUp() {\n    this.sck.output(false);\n  }\n\n  public async zeroAdjustWait(times: number | any) {\n    times = parseInt(times) || 1;\n    this._offset = await this.readAverageWait(times);\n  }\n\n  public async getValueWait(times: number | any): Promise<number> {\n    times = parseInt(times) || 1;\n    const val: any = await this.readAverageWait(times);\n    return (val - this._offset) / this._scale;\n  }\n\n  public setOffset(offset: any) {\n    if (typeof offset !== \"number\") {\n      throw new Error(\"offset variable is Number\");\n    }\n    this._offset = offset;\n  }\n\n  public setScale(scale: any) {\n    if (typeof scale !== \"number\") {\n      throw new Error(\"scale variable is Number\");\n    }\n    this._scale = scale;\n  }\n}\n"]}