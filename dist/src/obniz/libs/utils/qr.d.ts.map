{"version":3,"sources":["../src/obniz/libs/utils/qr.ts"],"names":[],"mappings":"AAsBA,QAAA,MAAM,OAAO,EAAE,GAgxDb,CAAC;AA8CH,eAAe,OAAO,CAAC","file":"qr.d.ts","sourcesContent":["/* eslint-disable */\r\n\r\n/* Thanks Kazuhiko Arase */\r\n/* https://github.com/kazuhikoarase/qrcode-generator/tree/master/js */\r\n\r\n// ---------------------------------------------------------------------\r\n//\r\n// QR Code Generator for JavaScript\r\n//\r\n// Copyright (c) 2009 Kazuhiko Arase\r\n//\r\n// URL: http://www.d-project.com/\r\n//\r\n// Licensed under the MIT license:\r\n//  http://www.opensource.org/licenses/mit-license.php\r\n//\r\n// The word 'QR Code' is registered trademark of\r\n// DENSO WAVE INCORPORATED\r\n//  http://www.denso-wave.com/qrcode/faqpatent-e.html\r\n//\r\n// ---------------------------------------------------------------------\r\n\r\nconst _qrcode: any = (() => {\r\n  // --------------------------------------------------------------------\r\n  // qrcode\r\n  // ---------------------------------------------------------------------\r\n\r\n  /**\r\n   * qrcode\r\n   * @param typeNumber 1 to 40\r\n   * @param errorCorrectionLevel 'L','M','Q','H'\r\n   */\r\n  const qrcode: any = (_typeNumber: number, errorCorrectionLevelStr: \"L\" | \"M\" | \"Q\" | \"H\") => {\r\n    const PAD0: any = 0xec;\r\n    const PAD1: any = 0x11;\r\n\r\n    const _errorCorrectionLevel: any = QRErrorCorrectionLevel[errorCorrectionLevelStr];\r\n    let _modules: any = null;\r\n    let _moduleCount: any = 0;\r\n    let _dataCache: any = null;\r\n    const _dataList: any = [];\r\n\r\n    const _this: any = {};\r\n\r\n    const makeImpl: any = (test: any, maskPattern: any) => {\r\n      _moduleCount = _typeNumber * 4 + 17;\r\n      _modules = ((moduleCount: any ) => {\r\n        const modules: any = new Array(moduleCount);\r\n        for (let row = 0; row < moduleCount; row += 1) {\r\n          modules[row] = new Array(moduleCount);\r\n          for (let col = 0; col < moduleCount; col += 1) {\r\n            modules[row][col] = null;\r\n          }\r\n        }\r\n        return modules;\r\n      })(_moduleCount);\r\n\r\n      setupPositionProbePattern(0, 0);\r\n      setupPositionProbePattern(_moduleCount - 7, 0);\r\n      setupPositionProbePattern(0, _moduleCount - 7);\r\n      setupPositionAdjustPattern();\r\n      setupTimingPattern();\r\n      setupTypeInfo(test, maskPattern);\r\n\r\n      if (_typeNumber >= 7) {\r\n        setupTypeNumber(test);\r\n      }\r\n\r\n      if (_dataCache === null) {\r\n        _dataCache = createData(_typeNumber, _errorCorrectionLevel, _dataList);\r\n      }\r\n\r\n      mapData(_dataCache, maskPattern);\r\n    };\r\n\r\n    const setupPositionProbePattern: any = (row: number, col: number) => {\r\n      for (let r = -1; r <= 7; r += 1) {\r\n        if (row + r <= -1 || _moduleCount <= row + r) {\r\n          continue;\r\n        }\r\n\r\n        for (let c = -1; c <= 7; c += 1) {\r\n          if (col + c <= -1 || _moduleCount <= col + c) {\r\n            continue;\r\n          }\r\n\r\n          if (\r\n            (0 <= r && r <= 6 && (c === 0 || c === 6)) ||\r\n            (0 <= c && c <= 6 && (r === 0 || r === 6)) ||\r\n            (2 <= r && r <= 4 && 2 <= c && c <= 4)\r\n          ) {\r\n            _modules[row + r][col + c] = true;\r\n          } else {\r\n            _modules[row + r][col + c] = false;\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    const getBestMaskPattern: any = () => {\r\n      let minLostPoint: any = 0;\r\n      let pattern: any = 0;\r\n\r\n      for (let i = 0; i < 8; i += 1) {\r\n        makeImpl(true, i);\r\n\r\n        const lostPoint: any = QRUtil.getLostPoint(_this);\r\n\r\n        if (i === 0 || minLostPoint > lostPoint) {\r\n          minLostPoint = lostPoint;\r\n          pattern = i;\r\n        }\r\n      }\r\n\r\n      return pattern;\r\n    };\r\n\r\n    const setupTimingPattern: any = () => {\r\n      for (let r = 8; r < _moduleCount - 8; r += 1) {\r\n        if (_modules[r][6] !== null) {\r\n          continue;\r\n        }\r\n        _modules[r][6] = r % 2 === 0;\r\n      }\r\n\r\n      for (let c = 8; c < _moduleCount - 8; c += 1) {\r\n        if (_modules[6][c] !== null) {\r\n          continue;\r\n        }\r\n        _modules[6][c] = c % 2 === 0;\r\n      }\r\n    };\r\n\r\n    const setupPositionAdjustPattern: any = () => {\r\n      const pos: any = QRUtil.getPatternPosition(_typeNumber);\r\n\r\n      for (let i = 0; i < pos.length; i += 1) {\r\n        for (let j = 0; j < pos.length; j += 1) {\r\n          const row: any = pos[i];\r\n          const col: any = pos[j];\r\n\r\n          if (_modules[row][col] !== null) {\r\n            continue;\r\n          }\r\n\r\n          for (let r = -2; r <= 2; r += 1) {\r\n            for (let c = -2; c <= 2; c += 1) {\r\n              if (\r\n                r === -2 ||\r\n                r === 2 ||\r\n                c === -2 ||\r\n                c === 2 ||\r\n                (r === 0 && c === 0)\r\n              ) {\r\n                _modules[row + r][col + c] = true;\r\n              } else {\r\n                _modules[row + r][col + c] = false;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    const setupTypeNumber: any = (test: any) => {\r\n      const bits: any = QRUtil.getBCHTypeNumber(_typeNumber);\r\n\r\n      for (let i = 0; i < 18; i += 1) {\r\n        const mod: any = !test && ((bits >> i) & 1) === 1;\r\n        _modules[Math.floor(i / 3)][i % 3 + _moduleCount - 8 - 3] = mod;\r\n      }\r\n\r\n      for (let i = 0; i < 18; i += 1) {\r\n        const mod: any = !test && ((bits >> i) & 1) === 1;\r\n        _modules[i % 3 + _moduleCount - 8 - 3][Math.floor(i / 3)] = mod;\r\n      }\r\n    };\r\n\r\n    const setupTypeInfo: any = (test: any, maskPattern: any) => {\r\n      const data: any = (_errorCorrectionLevel << 3) | maskPattern;\r\n      const bits: any = QRUtil.getBCHTypeInfo(data);\r\n\r\n      // vertical\r\n      for (let i = 0; i < 15; i += 1) {\r\n        const mod: any = !test && ((bits >> i) & 1) === 1;\r\n\r\n        if (i < 6) {\r\n          _modules[i][8] = mod;\r\n        } else if (i < 8) {\r\n          _modules[i + 1][8] = mod;\r\n        } else {\r\n          _modules[_moduleCount - 15 + i][8] = mod;\r\n        }\r\n      }\r\n\r\n      // horizontal\r\n      for (let i = 0; i < 15; i += 1) {\r\n        const mod: any = !test && ((bits >> i) & 1) === 1;\r\n\r\n        if (i < 8) {\r\n          _modules[8][_moduleCount - i - 1] = mod;\r\n        } else if (i < 9) {\r\n          _modules[8][15 - i - 1 + 1] = mod;\r\n        } else {\r\n          _modules[8][15 - i - 1] = mod;\r\n        }\r\n      }\r\n\r\n      // fixed module\r\n      _modules[_moduleCount - 8][8] = !test;\r\n    };\r\n\r\n    const mapData: any = (data: any, maskPattern: any) => {\r\n      let inc: any = -1;\r\n      let row: any = _moduleCount - 1;\r\n      let bitIndex: any = 7;\r\n      let byteIndex: any = 0;\r\n      const maskFunc: any = QRUtil.getMaskFunction(maskPattern);\r\n\r\n      for (let col = _moduleCount - 1; col > 0; col -= 2) {\r\n        if (col === 6) {\r\n          col -= 1;\r\n        }\r\n\r\n        while (true) {\r\n          for (let c = 0; c < 2; c += 1) {\r\n            if (_modules[row][col - c] === null) {\r\n              let dark: any = false;\r\n\r\n              if (byteIndex < data.length) {\r\n                dark = ((data[byteIndex] >>> bitIndex) & 1) === 1;\r\n              }\r\n\r\n              const mask: any = maskFunc(row, col - c);\r\n\r\n              if (mask) {\r\n                dark = !dark;\r\n              }\r\n\r\n              _modules[row][col - c] = dark;\r\n              bitIndex -= 1;\r\n\r\n              if (bitIndex === -1) {\r\n                byteIndex += 1;\r\n                bitIndex = 7;\r\n              }\r\n            }\r\n          }\r\n\r\n          row += inc;\r\n\r\n          if (row < 0 || _moduleCount <= row) {\r\n            row -= inc;\r\n            inc = -inc;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    const createBytes: any = (buffer: any, rsBlocks: any) => {\r\n      let offset: any = 0;\r\n\r\n      let maxDcCount: any = 0;\r\n      let maxEcCount: any = 0;\r\n\r\n      const dcdata: any = new Array(rsBlocks.length);\r\n      const ecdata: any = new Array(rsBlocks.length);\r\n\r\n      for (let r = 0; r < rsBlocks.length; r += 1) {\r\n        const dcCount: any = rsBlocks[r].dataCount;\r\n        const ecCount: any = rsBlocks[r].totalCount - dcCount;\r\n\r\n        maxDcCount = Math.max(maxDcCount, dcCount);\r\n        maxEcCount = Math.max(maxEcCount, ecCount);\r\n\r\n        dcdata[r] = new Array(dcCount);\r\n\r\n        for (let i = 0; i < dcdata[r].length; i += 1) {\r\n          dcdata[r][i] = 0xff & buffer.getBuffer()[i + offset];\r\n        }\r\n        offset += dcCount;\r\n\r\n        const rsPoly: any = QRUtil.getErrorCorrectPolynomial(ecCount);\r\n        const rawPoly: any = qrPolynomial(dcdata[r], rsPoly.getLength() - 1) as any;\r\n\r\n        const modPoly: any = rawPoly.mod(rsPoly);\r\n        ecdata[r] = new Array(rsPoly.getLength() - 1);\r\n        for (let i = 0; i < ecdata[r].length; i += 1) {\r\n          const modIndex: any = i + modPoly.getLength() - ecdata[r].length;\r\n          ecdata[r][i] = modIndex >= 0 ? modPoly.getAt(modIndex) : 0;\r\n        }\r\n      }\r\n\r\n      let totalCodeCount: any = 0;\r\n      for (let i = 0; i < rsBlocks.length; i += 1) {\r\n        totalCodeCount += rsBlocks[i].totalCount;\r\n      }\r\n\r\n      const data: any = new Array(totalCodeCount);\r\n      let index: any = 0;\r\n\r\n      for (let i = 0; i < maxDcCount; i += 1) {\r\n        for (let r = 0; r < rsBlocks.length; r += 1) {\r\n          if (i < dcdata[r].length) {\r\n            data[index] = dcdata[r][i];\r\n            index += 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      for (let i = 0; i < maxEcCount; i += 1) {\r\n        for (let r = 0; r < rsBlocks.length; r += 1) {\r\n          if (i < ecdata[r].length) {\r\n            data[index] = ecdata[r][i];\r\n            index += 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      return data;\r\n    };\r\n\r\n    const createData: any = (typeNumber: any, errorCorrectionLevel: any, dataList: any) => {\r\n      const rsBlocks: any = QRRSBlock.getRSBlocks(typeNumber, errorCorrectionLevel);\r\n\r\n      const buffer: any = qrBitBuffer();\r\n\r\n      for (let i = 0; i < dataList.length; i += 1) {\r\n        const data: any = dataList[i];\r\n        buffer.put(data.getMode(), 4);\r\n        buffer.put(\r\n          data.getLength(),\r\n          QRUtil.getLengthInBits(data.getMode(), typeNumber),\r\n        );\r\n        data.write(buffer);\r\n      }\r\n\r\n      // calc num max data.\r\n      let totalDataCount: any = 0;\r\n      for (let i = 0; i < rsBlocks.length; i += 1) {\r\n        totalDataCount += rsBlocks[i].dataCount;\r\n      }\r\n\r\n      if (buffer.getLengthInBits() > totalDataCount * 8) {\r\n        throw new Error(\"code length overflow. (\" +\r\n          buffer.getLengthInBits() +\r\n          \">\" +\r\n          totalDataCount * 8 +\r\n          \")\");\r\n      }\r\n\r\n      // end code\r\n      if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {\r\n        buffer.put(0, 4);\r\n      }\r\n\r\n      // padding\r\n      while (buffer.getLengthInBits() % 8 !== 0) {\r\n        buffer.putBit(false);\r\n      }\r\n\r\n      // padding\r\n      while (true) {\r\n        if (buffer.getLengthInBits() >= totalDataCount * 8) {\r\n          break;\r\n        }\r\n        buffer.put(PAD0, 8);\r\n\r\n        if (buffer.getLengthInBits() >= totalDataCount * 8) {\r\n          break;\r\n        }\r\n        buffer.put(PAD1, 8);\r\n      }\r\n\r\n      return createBytes(buffer, rsBlocks);\r\n    };\r\n\r\n    _this.addData = (data: any, mode: any) => {\r\n      mode = mode || \"Byte\";\r\n\r\n      let newData: any = null;\r\n\r\n      switch (mode) {\r\n        case \"Numeric\":\r\n          newData = qrNumber(data);\r\n          break;\r\n        case \"Alphanumeric\":\r\n          newData = qrAlphaNum(data);\r\n          break;\r\n        case \"Byte\":\r\n          newData = qr8BitByte(data);\r\n          break;\r\n        case \"Kanji\":\r\n          newData = qrKanji(data);\r\n          break;\r\n        default:\r\n          throw new Error(\"mode:\" + mode);\r\n      }\r\n\r\n      _dataList.push(newData);\r\n      _dataCache = null;\r\n    };\r\n\r\n    _this.getModules = () => {\r\n      return _modules;\r\n    };\r\n\r\n    _this.isDark = (row: number, col: number) => {\r\n      if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {\r\n        throw new Error(row + \",\" + col);\r\n      }\r\n      return _modules[row][col];\r\n    };\r\n\r\n    _this.getModuleCount = () => {\r\n      return _moduleCount;\r\n    };\r\n\r\n    _this.make = () => {\r\n      if (_typeNumber < 1) {\r\n        let typeNumber: any = 1;\r\n\r\n        for (; typeNumber < 40; typeNumber++) {\r\n          const rsBlocks: any = QRRSBlock.getRSBlocks(\r\n            typeNumber,\r\n            _errorCorrectionLevel,\r\n          );\r\n          const buffer: any = qrBitBuffer();\r\n\r\n          for (let i = 0; i < _dataList.length; i++) {\r\n            const data: any = _dataList[i];\r\n            buffer.put(data.getMode(), 4);\r\n            buffer.put(\r\n              data.getLength(),\r\n              QRUtil.getLengthInBits(data.getMode(), typeNumber),\r\n            );\r\n            data.write(buffer);\r\n          }\r\n\r\n          let totalDataCount: any = 0;\r\n          for (let i = 0; i < rsBlocks.length; i++) {\r\n            totalDataCount += rsBlocks[i].dataCount;\r\n          }\r\n\r\n          if (buffer.getLengthInBits() <= totalDataCount * 8) {\r\n            break;\r\n          }\r\n        }\r\n\r\n        _typeNumber = typeNumber;\r\n      }\r\n\r\n      makeImpl(false, getBestMaskPattern());\r\n    };\r\n\r\n    _this.createTableTag = (cellSize: any, margin: any) => {\r\n      cellSize = cellSize || 2;\r\n      margin = typeof margin === \"undefined\" ? cellSize * 4 : margin;\r\n\r\n      let qrHtml: any = \"\";\r\n\r\n      qrHtml += '<table style=\"';\r\n      qrHtml += \" border-width: 0px; border-style: none;\";\r\n      qrHtml += \" border-collapse: collapse;\";\r\n      qrHtml += \" padding: 0px; margin: \" + margin + \"px;\";\r\n      qrHtml += '\">';\r\n      qrHtml += \"<tbody>\";\r\n\r\n      for (let r = 0; r < _this.getModuleCount(); r += 1) {\r\n        qrHtml += \"<tr>\";\r\n\r\n        for (let c = 0; c < _this.getModuleCount(); c += 1) {\r\n          qrHtml += '<td style=\"';\r\n          qrHtml += \" border-width: 0px; border-style: none;\";\r\n          qrHtml += \" border-collapse: collapse;\";\r\n          qrHtml += \" padding: 0px; margin: 0px;\";\r\n          qrHtml += \" width: \" + cellSize + \"px;\";\r\n          qrHtml += \" height: \" + cellSize + \"px;\";\r\n          qrHtml += \" background-color: \";\r\n          qrHtml += _this.isDark(r, c) ? \"#000000\" : \"#ffffff\";\r\n          qrHtml += \";\";\r\n          qrHtml += '\"/>';\r\n        }\r\n\r\n        qrHtml += \"</tr>\";\r\n      }\r\n\r\n      qrHtml += \"</tbody>\";\r\n      qrHtml += \"</table>\";\r\n\r\n      return qrHtml;\r\n    };\r\n\r\n    _this.renderTo2dContext = (context: any, cellSize: any) => {\r\n      cellSize = cellSize || 2;\r\n      const length: any = _this.getModuleCount();\r\n      for (let row = 0; row < length; row++) {\r\n        for (let col = 0; col < length; col++) {\r\n          context.fillStyle = _this.isDark(row, col) ? \"black\" : \"white\";\r\n          context.fillRect(row * cellSize, col * cellSize, cellSize, cellSize);\r\n        }\r\n      }\r\n    };\r\n\r\n    return _this;\r\n  };\r\n\r\n  // ---------------------------------------------------------------------\r\n  // qrcode.stringToBytes\r\n  // ---------------------------------------------------------------------\r\n\r\n  qrcode.stringToBytesFuncs = {\r\n    default(s: any) {\r\n      const bytes: any = [];\r\n      for (let i = 0; i < s.length; i += 1) {\r\n        const c: any = s.charCodeAt(i);\r\n        bytes.push(c & 0xff);\r\n      }\r\n      return bytes;\r\n    },\r\n  } as any;\r\n\r\n  qrcode.stringToBytes = qrcode.stringToBytesFuncs.default;\r\n\r\n  // ---------------------------------------------------------------------\r\n  // qrcode.createStringToBytes\r\n  // ---------------------------------------------------------------------\r\n\r\n  /**\r\n   * @param unicodeData base64 string of byte array.\r\n   * [16bit Unicode],[16bit Bytes], ...\r\n   * @param numChars\r\n   */\r\n  qrcode.createStringToBytes = (unicodeData: any, numChars: any) => {\r\n    // create conversion map.\r\n\r\n    const unicodeMap: any = (() => {\r\n      const bin: any = base64DecodeInputStream(unicodeData);\r\n      const read: any = () => {\r\n        const b: any = bin.read();\r\n        if (b === -1) {\r\n          throw new Error(\"eof\");\r\n        }\r\n        return b;\r\n      };\r\n\r\n      let count: any = 0;\r\n      const result: any = {};\r\n      while (true) {\r\n        const b0: any = bin.read();\r\n        if (b0 === -1) {\r\n          break;\r\n        }\r\n        const b1: any = read();\r\n        const b2: any = read();\r\n        const b3: any = read();\r\n        const k: any = String.fromCharCode((b0 << 8) | b1);\r\n        const v: any = (b2 << 8) | b3;\r\n        result[k] = v;\r\n        count += 1;\r\n      }\r\n      if (count !== numChars) {\r\n        throw new Error(count + \" !==\" + numChars);\r\n      }\r\n\r\n      return result;\r\n    })();\r\n\r\n    const unknownChar: any = \"?\".charCodeAt(0);\r\n\r\n    return (s: any) => {\r\n      const bytes: any = [];\r\n      for (let i = 0; i < s.length; i += 1) {\r\n        const c: any = s.charCodeAt(i);\r\n        if (c < 128) {\r\n          bytes.push(c);\r\n        } else {\r\n          const b: any = unicodeMap[s.charAt(i)];\r\n          if (typeof b === \"number\") {\r\n            if ((b & 0xff) === b) {\r\n              // 1byte\r\n              bytes.push(b);\r\n            } else {\r\n              // 2bytes\r\n              bytes.push(b >>> 8);\r\n              bytes.push(b & 0xff);\r\n            }\r\n          } else {\r\n            bytes.push(unknownChar);\r\n          }\r\n        }\r\n      }\r\n      return bytes;\r\n    };\r\n  };\r\n\r\n  // ---------------------------------------------------------------------\r\n  // QRMode\r\n  // ---------------------------------------------------------------------\r\n\r\n  const QRMode: any = {\r\n    MODE_NUMBER: 1 << 0,\r\n    MODE_ALPHA_NUM: 1 << 1,\r\n    MODE_8BIT_BYTE: 1 << 2,\r\n    MODE_KANJI: 1 << 3,\r\n  };\r\n\r\n  // ---------------------------------------------------------------------\r\n  // QRErrorCorrectionLevel\r\n  // ---------------------------------------------------------------------\r\n\r\n  const QRErrorCorrectionLevel: any = {\r\n    L: 1,\r\n    M: 0,\r\n    Q: 3,\r\n    H: 2,\r\n  };\r\n\r\n  // ---------------------------------------------------------------------\r\n  // QRMaskPattern\r\n  // ---------------------------------------------------------------------\r\n\r\n  const QRMaskPattern: any = {\r\n    PATTERN000: 0,\r\n    PATTERN001: 1,\r\n    PATTERN010: 2,\r\n    PATTERN011: 3,\r\n    PATTERN100: 4,\r\n    PATTERN101: 5,\r\n    PATTERN110: 6,\r\n    PATTERN111: 7,\r\n  };\r\n\r\n  // ---------------------------------------------------------------------\r\n  // QRUtil\r\n  // ---------------------------------------------------------------------\r\n\r\n  const QRUtil: any = (() => {\r\n    const PATTERN_POSITION_TABLE: any = [\r\n      [],\r\n      [6, 18],\r\n      [6, 22],\r\n      [6, 26],\r\n      [6, 30],\r\n      [6, 34],\r\n      [6, 22, 38],\r\n      [6, 24, 42],\r\n      [6, 26, 46],\r\n      [6, 28, 50],\r\n      [6, 30, 54],\r\n      [6, 32, 58],\r\n      [6, 34, 62],\r\n      [6, 26, 46, 66],\r\n      [6, 26, 48, 70],\r\n      [6, 26, 50, 74],\r\n      [6, 30, 54, 78],\r\n      [6, 30, 56, 82],\r\n      [6, 30, 58, 86],\r\n      [6, 34, 62, 90],\r\n      [6, 28, 50, 72, 94],\r\n      [6, 26, 50, 74, 98],\r\n      [6, 30, 54, 78, 102],\r\n      [6, 28, 54, 80, 106],\r\n      [6, 32, 58, 84, 110],\r\n      [6, 30, 58, 86, 114],\r\n      [6, 34, 62, 90, 118],\r\n      [6, 26, 50, 74, 98, 122],\r\n      [6, 30, 54, 78, 102, 126],\r\n      [6, 26, 52, 78, 104, 130],\r\n      [6, 30, 56, 82, 108, 134],\r\n      [6, 34, 60, 86, 112, 138],\r\n      [6, 30, 58, 86, 114, 142],\r\n      [6, 34, 62, 90, 118, 146],\r\n      [6, 30, 54, 78, 102, 126, 150],\r\n      [6, 24, 50, 76, 102, 128, 154],\r\n      [6, 28, 54, 80, 106, 132, 158],\r\n      [6, 32, 58, 84, 110, 136, 162],\r\n      [6, 26, 54, 82, 110, 138, 166],\r\n      [6, 30, 58, 86, 114, 142, 170],\r\n    ];\r\n    const G15: any =\r\n      (1 << 10) |\r\n      (1 << 8) |\r\n      (1 << 5) |\r\n      (1 << 4) |\r\n      (1 << 2) |\r\n      (1 << 1) |\r\n      (1 << 0);\r\n    const G18: any =\r\n      (1 << 12) |\r\n      (1 << 11) |\r\n      (1 << 10) |\r\n      (1 << 9) |\r\n      (1 << 8) |\r\n      (1 << 5) |\r\n      (1 << 2) |\r\n      (1 << 0);\r\n    const G15_MASK: any = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);\r\n\r\n    const _this: any = {};\r\n\r\n    const getBCHDigit: any = (data: any) => {\r\n      let digit: any = 0;\r\n      while (data !== 0) {\r\n        digit += 1;\r\n        data >>>= 1;\r\n      }\r\n      return digit;\r\n    };\r\n\r\n    _this.getBCHTypeInfo = (data: any) => {\r\n      let d: any = data << 10;\r\n      while (getBCHDigit(d) - getBCHDigit(G15) >= 0) {\r\n        d ^= G15 << (getBCHDigit(d) - getBCHDigit(G15));\r\n      }\r\n      return ((data << 10) | d) ^ G15_MASK;\r\n    };\r\n\r\n    _this.getBCHTypeNumber = (data: any) => {\r\n      let d: any = data << 12;\r\n      while (getBCHDigit(d) - getBCHDigit(G18) >= 0) {\r\n        d ^= G18 << (getBCHDigit(d) - getBCHDigit(G18));\r\n      }\r\n      return (data << 12) | d;\r\n    };\r\n\r\n    _this.getPatternPosition = (typeNumber: number) => {\r\n      return PATTERN_POSITION_TABLE[typeNumber - 1];\r\n    };\r\n\r\n    _this.getMaskFunction = (maskPattern: any) => {\r\n      switch (maskPattern) {\r\n        case QRMaskPattern.PATTERN000:\r\n          return (i: any, j: any) => {\r\n            return (i + j) % 2 === 0;\r\n          };\r\n        case QRMaskPattern.PATTERN001:\r\n          return (i: any, j: any) => {\r\n            return i % 2 === 0;\r\n          };\r\n        case QRMaskPattern.PATTERN010:\r\n          return (i: any, j: any) => {\r\n            return j % 3 === 0;\r\n          };\r\n        case QRMaskPattern.PATTERN011:\r\n          return (i: any, j: any) => {\r\n            return (i + j) % 3 === 0;\r\n          };\r\n        case QRMaskPattern.PATTERN100:\r\n          return (i: any, j: any) => {\r\n            return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;\r\n          };\r\n        case QRMaskPattern.PATTERN101:\r\n          return (i: any, j: any) => {\r\n            return (i * j) % 2 + (i * j) % 3 === 0;\r\n          };\r\n        case QRMaskPattern.PATTERN110:\r\n          return (i: any, j: any) => {\r\n            return ((i * j) % 2 + (i * j) % 3) % 2 === 0;\r\n          };\r\n        case QRMaskPattern.PATTERN111:\r\n          return (i: any, j: any) => {\r\n            return ((i * j) % 3 + (i + j) % 2) % 2 === 0;\r\n          };\r\n\r\n        default:\r\n          throw new Error(\"bad maskPattern:\" + maskPattern);\r\n      }\r\n    };\r\n\r\n    _this.getErrorCorrectPolynomial = (errorCorrectLength: any) => {\r\n      let a: any = qrPolynomial([1], 0) as any;\r\n      for (let i = 0; i < errorCorrectLength; i += 1) {\r\n        a = a.multiply(qrPolynomial([1, QRMath.gexp(i)], 0));\r\n      }\r\n      return a;\r\n    };\r\n\r\n    _this.getLengthInBits = (mode: any, type: any) => {\r\n      if (1 <= type && type < 10) {\r\n        // 1 - 9\r\n\r\n        switch (mode) {\r\n          case QRMode.MODE_NUMBER:\r\n            return 10;\r\n          case QRMode.MODE_ALPHA_NUM:\r\n            return 9;\r\n          case QRMode.MODE_8BIT_BYTE:\r\n            return 8;\r\n          case QRMode.MODE_KANJI:\r\n            return 8;\r\n          default:\r\n            throw new Error(\"mode:\" + mode);\r\n        }\r\n      } else if (type < 27) {\r\n        // 10 - 26\r\n\r\n        switch (mode) {\r\n          case QRMode.MODE_NUMBER:\r\n            return 12;\r\n          case QRMode.MODE_ALPHA_NUM:\r\n            return 11;\r\n          case QRMode.MODE_8BIT_BYTE:\r\n            return 16;\r\n          case QRMode.MODE_KANJI:\r\n            return 10;\r\n          default:\r\n            throw new Error(\"mode:\" + mode);\r\n        }\r\n      } else if (type < 41) {\r\n        // 27 - 40\r\n\r\n        switch (mode) {\r\n          case QRMode.MODE_NUMBER:\r\n            return 14;\r\n          case QRMode.MODE_ALPHA_NUM:\r\n            return 13;\r\n          case QRMode.MODE_8BIT_BYTE:\r\n            return 16;\r\n          case QRMode.MODE_KANJI:\r\n            return 12;\r\n          default:\r\n            throw new Error(\"mode:\" + mode);\r\n        }\r\n      } else {\r\n        throw new Error(\"type:\" + type);\r\n      }\r\n    };\r\n\r\n    _this.getLostPoint = (__qrcode: any) => {\r\n      const moduleCount: any = __qrcode.getModuleCount();\r\n\r\n      let lostPoint: any = 0;\r\n\r\n      // LEVEL1\r\n\r\n      for (let row = 0; row < moduleCount; row += 1) {\r\n        for (let col = 0; col < moduleCount; col += 1) {\r\n          let sameCount: any = 0;\r\n          const dark: any = __qrcode.isDark(row, col);\r\n\r\n          for (let r = -1; r <= 1; r += 1) {\r\n            if (row + r < 0 || moduleCount <= row + r) {\r\n              continue;\r\n            }\r\n\r\n            for (let c = -1; c <= 1; c += 1) {\r\n              if (col + c < 0 || moduleCount <= col + c) {\r\n                continue;\r\n              }\r\n\r\n              if (r === 0 && c === 0) {\r\n                continue;\r\n              }\r\n\r\n              if (dark === __qrcode.isDark(row + r, col + c)) {\r\n                sameCount += 1;\r\n              }\r\n            }\r\n          }\r\n\r\n          if (sameCount > 5) {\r\n            lostPoint += 3 + sameCount - 5;\r\n          }\r\n        }\r\n      }\r\n\r\n      // LEVEL2\r\n\r\n      for (let row = 0; row < moduleCount - 1; row += 1) {\r\n        for (let col = 0; col < moduleCount - 1; col += 1) {\r\n          let count: any = 0;\r\n          if (__qrcode.isDark(row, col)) {\r\n            count += 1;\r\n          }\r\n          if (__qrcode.isDark(row + 1, col)) {\r\n            count += 1;\r\n          }\r\n          if (__qrcode.isDark(row, col + 1)) {\r\n            count += 1;\r\n          }\r\n          if (__qrcode.isDark(row + 1, col + 1)) {\r\n            count += 1;\r\n          }\r\n          if (count === 0 || count === 4) {\r\n            lostPoint += 3;\r\n          }\r\n        }\r\n      }\r\n\r\n      // LEVEL3\r\n\r\n      for (let row = 0; row < moduleCount; row += 1) {\r\n        for (let col = 0; col < moduleCount - 6; col += 1) {\r\n          if (\r\n            __qrcode.isDark(row, col) &&\r\n            !__qrcode.isDark(row, col + 1) &&\r\n            __qrcode.isDark(row, col + 2) &&\r\n            __qrcode.isDark(row, col + 3) &&\r\n            __qrcode.isDark(row, col + 4) &&\r\n            !__qrcode.isDark(row, col + 5) &&\r\n            __qrcode.isDark(row, col + 6)\r\n          ) {\r\n            lostPoint += 40;\r\n          }\r\n        }\r\n      }\r\n\r\n      for (let col = 0; col < moduleCount; col += 1) {\r\n        for (let row = 0; row < moduleCount - 6; row += 1) {\r\n          if (\r\n            __qrcode.isDark(row, col) &&\r\n            !__qrcode.isDark(row + 1, col) &&\r\n            __qrcode.isDark(row + 2, col) &&\r\n            __qrcode.isDark(row + 3, col) &&\r\n            __qrcode.isDark(row + 4, col) &&\r\n            !__qrcode.isDark(row + 5, col) &&\r\n            __qrcode.isDark(row + 6, col)\r\n          ) {\r\n            lostPoint += 40;\r\n          }\r\n        }\r\n      }\r\n\r\n      // LEVEL4\r\n\r\n      let darkCount: any = 0;\r\n\r\n      for (let col = 0; col < moduleCount; col += 1) {\r\n        for (let row = 0; row < moduleCount; row += 1) {\r\n          if (__qrcode.isDark(row, col)) {\r\n            darkCount += 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      const ratio: any =\r\n        Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;\r\n      lostPoint += ratio * 10;\r\n\r\n      return lostPoint;\r\n    };\r\n\r\n    return _this;\r\n  })();\r\n\r\n  // ---------------------------------------------------------------------\r\n  // QRMath\r\n  // ---------------------------------------------------------------------\r\n\r\n  const QRMath: any = (() => {\r\n    const EXP_TABLE: any = new Array(256);\r\n    const LOG_TABLE: any = new Array(256);\r\n\r\n    // initialize tables\r\n    for (let i = 0; i < 8; i += 1) {\r\n      EXP_TABLE[i] = 1 << i;\r\n    }\r\n    for (let i = 8; i < 256; i += 1) {\r\n      EXP_TABLE[i] =\r\n        EXP_TABLE[i - 4] ^\r\n        EXP_TABLE[i - 5] ^\r\n        EXP_TABLE[i - 6] ^\r\n        EXP_TABLE[i - 8];\r\n    }\r\n    for (let i = 0; i < 255; i += 1) {\r\n      LOG_TABLE[EXP_TABLE[i]] = i;\r\n    }\r\n\r\n    const _this: any = {};\r\n\r\n    _this.glog = (n: any) => {\r\n      if (n < 1) {\r\n        throw new Error(\"glog(\" + n + \")\");\r\n      }\r\n\r\n      return LOG_TABLE[n];\r\n    };\r\n\r\n    _this.gexp = (n: any) => {\r\n      while (n < 0) {\r\n        n += 255;\r\n      }\r\n\r\n      while (n >= 256) {\r\n        n -= 255;\r\n      }\r\n\r\n      return EXP_TABLE[n];\r\n    };\r\n\r\n    return _this;\r\n  })();\r\n\r\n  // ---------------------------------------------------------------------\r\n  // qrPolynomial\r\n  // ---------------------------------------------------------------------\r\n\r\n  function qrPolynomial(num?: any, shift?: any) {\r\n    if (typeof num.length === \"undefined\") {\r\n      throw new Error(num.length + \"/\" + shift);\r\n    }\r\n\r\n    const _num: any = (() => {\r\n      let offset: any = 0;\r\n      while (offset < num.length && num[offset] === 0) {\r\n        offset += 1;\r\n      }\r\n      const __num: any = new Array(num.length - offset + shift);\r\n      for (let i = 0; i < num.length - offset; i += 1) {\r\n        __num[i] = num[i + offset];\r\n      }\r\n      return __num;\r\n    })();\r\n\r\n    const _this: any = {};\r\n\r\n    _this.getAt = (index: any) => {\r\n      return _num[index];\r\n    };\r\n\r\n    _this.getLength = () => {\r\n      return _num.length;\r\n    };\r\n\r\n    _this.multiply = (e: any) => {\r\n      const ___num: any = new Array(_this.getLength() + e.getLength() - 1);\r\n\r\n      for (let i = 0; i < _this.getLength(); i += 1) {\r\n        for (let j = 0; j < e.getLength(); j += 1) {\r\n          ___num[i + j] ^= QRMath.gexp(\r\n            QRMath.glog(_this.getAt(i)) + QRMath.glog(e.getAt(j)),\r\n          );\r\n        }\r\n      }\r\n\r\n      return qrPolynomial(___num, 0);\r\n    };\r\n\r\n    _this.mod = (e: any) => {\r\n      if (_this.getLength() - e.getLength() < 0) {\r\n        return _this;\r\n      }\r\n\r\n      const ratio: any = QRMath.glog(_this.getAt(0)) - QRMath.glog(e.getAt(0));\r\n\r\n      const __num: any = new Array(_this.getLength());\r\n      for (let i = 0; i < _this.getLength(); i += 1) {\r\n        __num[i] = _this.getAt(i);\r\n      }\r\n\r\n      for (let i = 0; i < e.getLength(); i += 1) {\r\n        __num[i] ^= QRMath.gexp(QRMath.glog(e.getAt(i)) + ratio);\r\n      }\r\n\r\n      // recursive call\r\n      return qrPolynomial(__num, 0).mod(e);\r\n    };\r\n\r\n    return _this;\r\n  }\r\n\r\n// ---------------------------------------------------------------------\r\n// QRRSBlock\r\n// ---------------------------------------------------------------------\r\n\r\n  const QRRSBlock: any = (() => {\r\n    const RS_BLOCK_TABLE: any = [\r\n      // L\r\n      // M\r\n      // Q\r\n      // H\r\n\r\n      // 1\r\n      [1, 26, 19],\r\n      [1, 26, 16],\r\n      [1, 26, 13],\r\n      [1, 26, 9],\r\n\r\n      // 2\r\n      [1, 44, 34],\r\n      [1, 44, 28],\r\n      [1, 44, 22],\r\n      [1, 44, 16],\r\n\r\n      // 3\r\n      [1, 70, 55],\r\n      [1, 70, 44],\r\n      [2, 35, 17],\r\n      [2, 35, 13],\r\n\r\n      // 4\r\n      [1, 100, 80],\r\n      [2, 50, 32],\r\n      [2, 50, 24],\r\n      [4, 25, 9],\r\n\r\n      // 5\r\n      [1, 134, 108],\r\n      [2, 67, 43],\r\n      [2, 33, 15, 2, 34, 16],\r\n      [2, 33, 11, 2, 34, 12],\r\n\r\n      // 6\r\n      [2, 86, 68],\r\n      [4, 43, 27],\r\n      [4, 43, 19],\r\n      [4, 43, 15],\r\n\r\n      // 7\r\n      [2, 98, 78],\r\n      [4, 49, 31],\r\n      [2, 32, 14, 4, 33, 15],\r\n      [4, 39, 13, 1, 40, 14],\r\n\r\n      // 8\r\n      [2, 121, 97],\r\n      [2, 60, 38, 2, 61, 39],\r\n      [4, 40, 18, 2, 41, 19],\r\n      [4, 40, 14, 2, 41, 15],\r\n\r\n      // 9\r\n      [2, 146, 116],\r\n      [3, 58, 36, 2, 59, 37],\r\n      [4, 36, 16, 4, 37, 17],\r\n      [4, 36, 12, 4, 37, 13],\r\n\r\n      // 10\r\n      [2, 86, 68, 2, 87, 69],\r\n      [4, 69, 43, 1, 70, 44],\r\n      [6, 43, 19, 2, 44, 20],\r\n      [6, 43, 15, 2, 44, 16],\r\n\r\n      // 11\r\n      [4, 101, 81],\r\n      [1, 80, 50, 4, 81, 51],\r\n      [4, 50, 22, 4, 51, 23],\r\n      [3, 36, 12, 8, 37, 13],\r\n\r\n      // 12\r\n      [2, 116, 92, 2, 117, 93],\r\n      [6, 58, 36, 2, 59, 37],\r\n      [4, 46, 20, 6, 47, 21],\r\n      [7, 42, 14, 4, 43, 15],\r\n\r\n      // 13\r\n      [4, 133, 107],\r\n      [8, 59, 37, 1, 60, 38],\r\n      [8, 44, 20, 4, 45, 21],\r\n      [12, 33, 11, 4, 34, 12],\r\n\r\n      // 14\r\n      [3, 145, 115, 1, 146, 116],\r\n      [4, 64, 40, 5, 65, 41],\r\n      [11, 36, 16, 5, 37, 17],\r\n      [11, 36, 12, 5, 37, 13],\r\n\r\n      // 15\r\n      [5, 109, 87, 1, 110, 88],\r\n      [5, 65, 41, 5, 66, 42],\r\n      [5, 54, 24, 7, 55, 25],\r\n      [11, 36, 12, 7, 37, 13],\r\n\r\n      // 16\r\n      [5, 122, 98, 1, 123, 99],\r\n      [7, 73, 45, 3, 74, 46],\r\n      [15, 43, 19, 2, 44, 20],\r\n      [3, 45, 15, 13, 46, 16],\r\n\r\n      // 17\r\n      [1, 135, 107, 5, 136, 108],\r\n      [10, 74, 46, 1, 75, 47],\r\n      [1, 50, 22, 15, 51, 23],\r\n      [2, 42, 14, 17, 43, 15],\r\n\r\n      // 18\r\n      [5, 150, 120, 1, 151, 121],\r\n      [9, 69, 43, 4, 70, 44],\r\n      [17, 50, 22, 1, 51, 23],\r\n      [2, 42, 14, 19, 43, 15],\r\n\r\n      // 19\r\n      [3, 141, 113, 4, 142, 114],\r\n      [3, 70, 44, 11, 71, 45],\r\n      [17, 47, 21, 4, 48, 22],\r\n      [9, 39, 13, 16, 40, 14],\r\n\r\n      // 20\r\n      [3, 135, 107, 5, 136, 108],\r\n      [3, 67, 41, 13, 68, 42],\r\n      [15, 54, 24, 5, 55, 25],\r\n      [15, 43, 15, 10, 44, 16],\r\n\r\n      // 21\r\n      [4, 144, 116, 4, 145, 117],\r\n      [17, 68, 42],\r\n      [17, 50, 22, 6, 51, 23],\r\n      [19, 46, 16, 6, 47, 17],\r\n\r\n      // 22\r\n      [2, 139, 111, 7, 140, 112],\r\n      [17, 74, 46],\r\n      [7, 54, 24, 16, 55, 25],\r\n      [34, 37, 13],\r\n\r\n      // 23\r\n      [4, 151, 121, 5, 152, 122],\r\n      [4, 75, 47, 14, 76, 48],\r\n      [11, 54, 24, 14, 55, 25],\r\n      [16, 45, 15, 14, 46, 16],\r\n\r\n      // 24\r\n      [6, 147, 117, 4, 148, 118],\r\n      [6, 73, 45, 14, 74, 46],\r\n      [11, 54, 24, 16, 55, 25],\r\n      [30, 46, 16, 2, 47, 17],\r\n\r\n      // 25\r\n      [8, 132, 106, 4, 133, 107],\r\n      [8, 75, 47, 13, 76, 48],\r\n      [7, 54, 24, 22, 55, 25],\r\n      [22, 45, 15, 13, 46, 16],\r\n\r\n      // 26\r\n      [10, 142, 114, 2, 143, 115],\r\n      [19, 74, 46, 4, 75, 47],\r\n      [28, 50, 22, 6, 51, 23],\r\n      [33, 46, 16, 4, 47, 17],\r\n\r\n      // 27\r\n      [8, 152, 122, 4, 153, 123],\r\n      [22, 73, 45, 3, 74, 46],\r\n      [8, 53, 23, 26, 54, 24],\r\n      [12, 45, 15, 28, 46, 16],\r\n\r\n      // 28\r\n      [3, 147, 117, 10, 148, 118],\r\n      [3, 73, 45, 23, 74, 46],\r\n      [4, 54, 24, 31, 55, 25],\r\n      [11, 45, 15, 31, 46, 16],\r\n\r\n      // 29\r\n      [7, 146, 116, 7, 147, 117],\r\n      [21, 73, 45, 7, 74, 46],\r\n      [1, 53, 23, 37, 54, 24],\r\n      [19, 45, 15, 26, 46, 16],\r\n\r\n      // 30\r\n      [5, 145, 115, 10, 146, 116],\r\n      [19, 75, 47, 10, 76, 48],\r\n      [15, 54, 24, 25, 55, 25],\r\n      [23, 45, 15, 25, 46, 16],\r\n\r\n      // 31\r\n      [13, 145, 115, 3, 146, 116],\r\n      [2, 74, 46, 29, 75, 47],\r\n      [42, 54, 24, 1, 55, 25],\r\n      [23, 45, 15, 28, 46, 16],\r\n\r\n      // 32\r\n      [17, 145, 115],\r\n      [10, 74, 46, 23, 75, 47],\r\n      [10, 54, 24, 35, 55, 25],\r\n      [19, 45, 15, 35, 46, 16],\r\n\r\n      // 33\r\n      [17, 145, 115, 1, 146, 116],\r\n      [14, 74, 46, 21, 75, 47],\r\n      [29, 54, 24, 19, 55, 25],\r\n      [11, 45, 15, 46, 46, 16],\r\n\r\n      // 34\r\n      [13, 145, 115, 6, 146, 116],\r\n      [14, 74, 46, 23, 75, 47],\r\n      [44, 54, 24, 7, 55, 25],\r\n      [59, 46, 16, 1, 47, 17],\r\n\r\n      // 35\r\n      [12, 151, 121, 7, 152, 122],\r\n      [12, 75, 47, 26, 76, 48],\r\n      [39, 54, 24, 14, 55, 25],\r\n      [22, 45, 15, 41, 46, 16],\r\n\r\n      // 36\r\n      [6, 151, 121, 14, 152, 122],\r\n      [6, 75, 47, 34, 76, 48],\r\n      [46, 54, 24, 10, 55, 25],\r\n      [2, 45, 15, 64, 46, 16],\r\n\r\n      // 37\r\n      [17, 152, 122, 4, 153, 123],\r\n      [29, 74, 46, 14, 75, 47],\r\n      [49, 54, 24, 10, 55, 25],\r\n      [24, 45, 15, 46, 46, 16],\r\n\r\n      // 38\r\n      [4, 152, 122, 18, 153, 123],\r\n      [13, 74, 46, 32, 75, 47],\r\n      [48, 54, 24, 14, 55, 25],\r\n      [42, 45, 15, 32, 46, 16],\r\n\r\n      // 39\r\n      [20, 147, 117, 4, 148, 118],\r\n      [40, 75, 47, 7, 76, 48],\r\n      [43, 54, 24, 22, 55, 25],\r\n      [10, 45, 15, 67, 46, 16],\r\n\r\n      // 40\r\n      [19, 148, 118, 6, 149, 119],\r\n      [18, 75, 47, 31, 76, 48],\r\n      [34, 54, 24, 34, 55, 25],\r\n      [20, 45, 15, 61, 46, 16],\r\n    ];\r\n\r\n    const qrRSBlock: any = (totalCount: any, dataCount: any) => {\r\n      const result: any = {};\r\n      result.totalCount = totalCount;\r\n      result.dataCount = dataCount;\r\n      return result;\r\n    };\r\n\r\n    const _this: any = {};\r\n\r\n    const getRsBlockTable: any = (typeNumber: any, errorCorrectionLevel: any) => {\r\n      switch (errorCorrectionLevel) {\r\n        case QRErrorCorrectionLevel.L:\r\n          return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];\r\n        case QRErrorCorrectionLevel.M:\r\n          return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];\r\n        case QRErrorCorrectionLevel.Q:\r\n          return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];\r\n        case QRErrorCorrectionLevel.H:\r\n          return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];\r\n        default:\r\n          return undefined;\r\n      }\r\n    };\r\n\r\n    _this.getRSBlocks = (typeNumber: any, errorCorrectionLevel: any) => {\r\n      const rsBlock: any = getRsBlockTable(typeNumber, errorCorrectionLevel);\r\n\r\n      if (typeof rsBlock === \"undefined\") {\r\n        throw new Error(\"bad rs block @ typeNumber:\" +\r\n          typeNumber +\r\n          \"/errorCorrectionLevel:\" +\r\n          errorCorrectionLevel);\r\n      }\r\n\r\n      const length: any = rsBlock.length / 3;\r\n\r\n      const list: any = [];\r\n\r\n      for (let i = 0; i < length; i += 1) {\r\n        const count: any = rsBlock[i * 3 + 0];\r\n        const totalCount: any = rsBlock[i * 3 + 1];\r\n        const dataCount: any = rsBlock[i * 3 + 2];\r\n\r\n        for (let j = 0; j < count; j += 1) {\r\n          list.push(qrRSBlock(totalCount, dataCount));\r\n        }\r\n      }\r\n\r\n      return list;\r\n    };\r\n\r\n    return _this;\r\n  })();\r\n\r\n// ---------------------------------------------------------------------\r\n// qrBitBuffer\r\n// ---------------------------------------------------------------------\r\n\r\n  const qrBitBuffer: any = () => {\r\n    const _buffer: any = [];\r\n    let _length: any = 0;\r\n\r\n    const _this: any = {};\r\n\r\n    _this.getBuffer = () => {\r\n      return _buffer;\r\n    };\r\n\r\n    _this.getAt = (index: number) => {\r\n      const bufIndex: any = Math.floor(index / 8);\r\n      return ((_buffer[bufIndex] >>> (7 - index % 8)) & 1) === 1;\r\n    };\r\n\r\n    _this.put = (num: number, length: number) => {\r\n      for (let i = 0; i < length; i += 1) {\r\n        _this.putBit(((num >>> (length - i - 1)) & 1) === 1);\r\n      }\r\n    };\r\n\r\n    _this.getLengthInBits = () => {\r\n      return _length;\r\n    };\r\n\r\n    _this.putBit = (bit: any) => {\r\n      const bufIndex: any = Math.floor(_length / 8);\r\n      if (_buffer.length <= bufIndex) {\r\n        _buffer.push(0);\r\n      }\r\n\r\n      if (bit) {\r\n        _buffer[bufIndex] |= 0x80 >>> (_length % 8);\r\n      }\r\n\r\n      _length += 1;\r\n    };\r\n\r\n    return _this;\r\n  };\r\n\r\n// ---------------------------------------------------------------------\r\n// qrNumber\r\n// ---------------------------------------------------------------------\r\n\r\n  const qrNumber: any = (_data: any) => {\r\n      const _mode: any = QRMode.MODE_NUMBER;\r\n\r\n      const _this: any = {};\r\n\r\n      _this.getMode = () => {\r\n        return _mode;\r\n      };\r\n\r\n      _this.getLength = (buffer: any) => {\r\n        return _data.length;\r\n      }\r\n      ;\r\n\r\n      _this.write = (buffer: any) => {\r\n        const data: any = _data;\r\n\r\n        let i: any = 0;\r\n\r\n        while (i + 2 < data.length) {\r\n          buffer.put(strToNum(data.substring(i, i + 3)), 10);\r\n          i += 3;\r\n        }\r\n\r\n        if (i < data.length) {\r\n          if (data.length - i === 1) {\r\n            buffer.put(strToNum(data.substring(i, i + 1)), 4);\r\n          } else if (data.length - i === 2) {\r\n            buffer.put(strToNum(data.substring(i, i + 2)), 7);\r\n          }\r\n        }\r\n      }\r\n      ;\r\n\r\n      const strToNum: any = (s: any) => {\r\n          let num: any = 0;\r\n          for (let i = 0; i < s.length; i += 1) {\r\n            num = num * 10 + chatToNum(s.charAt(i));\r\n          }\r\n          return num;\r\n        }\r\n      ;\r\n\r\n      const chatToNum: any = (c: any) => {\r\n          if (\"0\" <= c && c <= \"9\") {\r\n            return c.charCodeAt(0) - \"0\".charCodeAt(0);\r\n          }\r\n          throw new Error(\"illegal char :\" + c);\r\n        }\r\n      ;\r\n\r\n      return _this;\r\n    }\r\n  ;\r\n\r\n// ---------------------------------------------------------------------\r\n// qrAlphaNum\r\n// ---------------------------------------------------------------------\r\n\r\n  const qrAlphaNum: any = (data: any) => {\r\n      const _mode: any = QRMode.MODE_ALPHA_NUM;\r\n      const _data: any = data;\r\n\r\n      const _this: any = {};\r\n\r\n      _this.getMode = () => {\r\n        return _mode;\r\n      };\r\n\r\n      _this.getLength = (buffer: any) => {\r\n        return _data.length;\r\n      }\r\n      ;\r\n\r\n      _this.write = (buffer: any) => {\r\n        const s: any = _data;\r\n\r\n        let i: any = 0;\r\n\r\n        while (i + 1 < s.length) {\r\n          buffer.put(getCode(s.charAt(i)) * 45 + getCode(s.charAt(i + 1)), 11);\r\n          i += 2;\r\n        }\r\n\r\n        if (i < s.length) {\r\n          buffer.put(getCode(s.charAt(i)), 6);\r\n        }\r\n      }\r\n      ;\r\n\r\n      const getCode: any = (c: any) => {\r\n        if (\"0\" <= c && c <= \"9\") {\r\n          return c.charCodeAt(0) - \"0\".charCodeAt(0);\r\n        } else if (\"A\" <= c && c <= \"Z\") {\r\n          return c.charCodeAt(0) - \"A\".charCodeAt(0) + 10;\r\n        } else {\r\n          switch (c) {\r\n            case \" \":\r\n              return 36;\r\n            case \"$\":\r\n              return 37;\r\n            case \"%\":\r\n              return 38;\r\n            case \"*\":\r\n              return 39;\r\n            case \"+\":\r\n              return 40;\r\n            case \"-\":\r\n              return 41;\r\n            case \".\":\r\n              return 42;\r\n            case \"/\":\r\n              return 43;\r\n            case \":\":\r\n              return 44;\r\n            default:\r\n              throw new Error(\"illegal char :\" + c);\r\n          }\r\n        }\r\n      };\r\n\r\n      return _this;\r\n    }\r\n  ;\r\n\r\n// ---------------------------------------------------------------------\r\n// qr8BitByte\r\n// ---------------------------------------------------------------------\r\n\r\n  const qr8BitByte: any = (data: any) => {\r\n    const _mode: any = QRMode.MODE_8BIT_BYTE;\r\n    const _data: any = data;\r\n    const _bytes: any = qrcode.stringToBytes(data);\r\n\r\n    const _this: any = {};\r\n\r\n    _this.getMode = () => {\r\n      return _mode;\r\n    };\r\n\r\n    _this.getLength = (buffer: any) => {\r\n      return _bytes.length;\r\n    };\r\n\r\n    _this.write = (buffer: any) => {\r\n      for (let i = 0; i < _bytes.length; i += 1) {\r\n        buffer.put(_bytes[i], 8);\r\n      }\r\n    };\r\n\r\n    return _this;\r\n  };\r\n\r\n// ---------------------------------------------------------------------\r\n// qrKanji\r\n// ---------------------------------------------------------------------\r\n\r\n  const qrKanji: any = (data: any) => {\r\n    const _mode: any = QRMode.MODE_KANJI;\r\n    const _data: any = data;\r\n\r\n    const stringToBytes: any = (qrcode.stringToBytesFuncs as any).SJIS;\r\n    if (!stringToBytes) {\r\n      throw new Error(\"sjis not supported.\");\r\n    }\r\n\r\n    // tslint:disable:no-unused-expression\r\n    // @ts-ignore\r\n    !((c: string, code: number) => {\r\n      // self test for sjis support.\r\n      const test: any = stringToBytes(c);\r\n      if (test.length !== 2 || ((test[0] << 8) | test[1]) !== code) {\r\n        throw new Error(\"sjis not supported.\");\r\n      }\r\n    })(\"\\u53cb\", 0x9746);\r\n    // tslint:enable:no-unused-expression\r\n\r\n    const _bytes: any = stringToBytes(data);\r\n\r\n    const _this: any = {};\r\n\r\n    _this.getMode = () => {\r\n      return _mode;\r\n    };\r\n\r\n    _this.getLength = (buffer: any) => {\r\n      return ~~(_bytes.length / 2);\r\n    };\r\n\r\n    _this.write = (buffer: any) => {\r\n      const __data: any = _bytes;\r\n\r\n      let i: any = 0;\r\n\r\n      while (i + 1 < __data.length) {\r\n        let c: any = ((0xff & __data[i]) << 8) | (0xff & __data[i + 1]);\r\n\r\n        if (0x8140 <= c && c <= 0x9ffc) {\r\n          c -= 0x8140;\r\n        } else if (0xe040 <= c && c <= 0xebbf) {\r\n          c -= 0xc140;\r\n        } else {\r\n          throw new Error(\"illegal char at \" + (i + 1) + \"/\" + c);\r\n        }\r\n\r\n        c = ((c >>> 8) & 0xff) * 0xc0 + (c & 0xff);\r\n\r\n        buffer.put(c, 13);\r\n\r\n        i += 2;\r\n      }\r\n\r\n      if (i < __data.length) {\r\n        throw new Error(\"illegal char at \" + (i + 1));\r\n      }\r\n    };\r\n\r\n    return _this;\r\n  };\r\n\r\n// =====================================================================\r\n// GIF Support etc.\r\n//\r\n\r\n// ---------------------------------------------------------------------\r\n// byteArrayOutputStream\r\n// ---------------------------------------------------------------------\r\n\r\n  const byteArrayOutputStream: any = () => {\r\n    const _bytes: any = [];\r\n\r\n    const _this: any = {};\r\n\r\n    _this.writeByte = (b: any) => {\r\n      _bytes.push(b & 0xff);\r\n    };\r\n\r\n    _this.writeShort = (i: any) => {\r\n      _this.writeByte(i);\r\n      _this.writeByte(i >>> 8);\r\n    };\r\n\r\n    _this.writeBytes = (b: any, off: any, len: any) => {\r\n      off = off || 0;\r\n      len = len || b.length;\r\n      for (let i = 0; i < len; i += 1) {\r\n        _this.writeByte(b[i + off]);\r\n      }\r\n    };\r\n\r\n    _this.writeString = (s: any) => {\r\n      for (let i = 0; i < s.length; i += 1) {\r\n        _this.writeByte(s.charCodeAt(i));\r\n      }\r\n    }\r\n    ;\r\n\r\n    _this.toByteArray = () => {\r\n      return _bytes;\r\n    };\r\n\r\n    _this.toString = () => {\r\n      let s: any = \"\";\r\n      s += \"[\";\r\n      for (let i = 0; i < _bytes.length; i += 1) {\r\n        if (i > 0) {\r\n          s += \",\";\r\n        }\r\n        s += _bytes[i];\r\n      }\r\n      s += \"]\";\r\n      return s;\r\n    };\r\n\r\n    return _this;\r\n  };\r\n\r\n// ---------------------------------------------------------------------\r\n// base64EncodeOutputStream\r\n// ---------------------------------------------------------------------\r\n\r\n  const base64EncodeOutputStream: any = () => {\r\n    let _buffer: any = 0;\r\n    let _buflen: any = 0;\r\n    let _length: any = 0;\r\n    let _base64: any = \"\";\r\n\r\n    const _this: any = {};\r\n\r\n    const writeEncoded: any = (b: any) => {\r\n      _base64 += String.fromCharCode(encode(b & 0x3f));\r\n    };\r\n\r\n    const encode: any = (n: any) => {\r\n        if (n < 0) {\r\n          // error.\r\n        } else if (n < 26) {\r\n          return 0x41 + n;\r\n        } else if (n < 52) {\r\n          return 0x61 + (n - 26);\r\n        } else if (n < 62) {\r\n          return 0x30 + (n - 52);\r\n        } else if (n === 62) {\r\n          return 0x2b;\r\n        } else if (n === 63) {\r\n          return 0x2f;\r\n        }\r\n        throw new Error(\"n:\" + n);\r\n      }\r\n    ;\r\n\r\n    _this.writeByte = (n: any) => {\r\n      _buffer = (_buffer << 8) | (n & 0xff);\r\n      _buflen += 8;\r\n      _length += 1;\r\n\r\n      while (_buflen >= 6) {\r\n        writeEncoded(_buffer >>> (_buflen - 6));\r\n        _buflen -= 6;\r\n      }\r\n    };\r\n\r\n    _this.flush = () => {\r\n      if (_buflen > 0) {\r\n        writeEncoded(_buffer << (6 - _buflen));\r\n        _buffer = 0;\r\n        _buflen = 0;\r\n      }\r\n\r\n      if (_length % 3 !== 0) {\r\n        // padding\r\n        const padlen: any = 3 - _length % 3;\r\n        for (let i = 0; i < padlen; i += 1) {\r\n          _base64 += \"=\";\r\n        }\r\n      }\r\n    };\r\n\r\n    _this.toString = () => {\r\n      return _base64;\r\n    };\r\n\r\n    return _this;\r\n  };\r\n\r\n// ---------------------------------------------------------------------\r\n// base64DecodeInputStream\r\n// ---------------------------------------------------------------------\r\n\r\n  const base64DecodeInputStream: any = (str: any) => {\r\n      const _str: any = str;\r\n      let _pos: any = 0;\r\n      let _buffer: any = 0;\r\n      let _buflen: any = 0;\r\n\r\n      const _this: any = {};\r\n\r\n      _this.read = () => {\r\n        while (_buflen < 8) {\r\n          if (_pos >= _str.length) {\r\n            if (_buflen === 0) {\r\n              return -1;\r\n            }\r\n            throw new Error(\"unexpected end of file./\" + _buflen);\r\n          }\r\n\r\n          const c: any = _str.charAt(_pos);\r\n          _pos += 1;\r\n\r\n          if (c === \"=\") {\r\n            _buflen = 0;\r\n            return -1;\r\n          } else if (c.match(/^\\s$/)) {\r\n            // ignore if whitespace.\r\n            continue;\r\n          }\r\n\r\n          _buffer = (_buffer << 6) | decode(c.charCodeAt(0));\r\n          _buflen += 6;\r\n        }\r\n\r\n        const n: any = (_buffer >>> (_buflen - 8)) & 0xff;\r\n        _buflen -= 8;\r\n        return n;\r\n      };\r\n\r\n      const decode: any = (c: any) => {\r\n          if (0x41 <= c && c <= 0x5a) {\r\n            return c - 0x41;\r\n          } else if (0x61 <= c && c <= 0x7a) {\r\n            return c - 0x61 + 26;\r\n          } else if (0x30 <= c && c <= 0x39) {\r\n            return c - 0x30 + 52;\r\n          } else if (c === 0x2b) {\r\n            return 62;\r\n          } else if (c === 0x2f) {\r\n            return 63;\r\n          } else {\r\n            throw new Error(\"c:\" + c);\r\n          }\r\n        }\r\n      ;\r\n\r\n      return _this;\r\n    }\r\n  ;\r\n\r\n// ---------------------------------------------------------------------\r\n// returns qrcode function.\r\n\r\n  return qrcode;\r\n})\r\n();\r\n\r\n// multibyte support\r\n// tslint:disable-next-line:no-unused-expression\r\n// @ts-ignore\r\n// tslint:disable-next-line:no-unused-expression\r\n!(() => {\r\n  _qrcode.stringToBytesFuncs[\"UTF-8\"] = (s: any) => {\r\n    // http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\r\n    function toUTF8Array(str: any) {\r\n      const utf8: any = [];\r\n      for (let i = 0; i < str.length; i++) {\r\n        let charcode: any = str.charCodeAt(i);\r\n        if (charcode < 0x80) {\r\n          utf8.push(charcode);\r\n        } else if (charcode < 0x800) {\r\n          utf8.push(0xc0 | (charcode >> 6), 0x80 | (charcode & 0x3f));\r\n        } else if (charcode < 0xd800 || charcode >= 0xe000) {\r\n          utf8.push(\r\n            0xe0 | (charcode >> 12),\r\n            0x80 | ((charcode >> 6) & 0x3f),\r\n            0x80 | (charcode & 0x3f),\r\n          );\r\n        } else {\r\n          i++;\r\n          // UTF-16 encodes 0x10000-0x10FFFF by\r\n          // subtracting 0x10000 and splitting the\r\n          // 20 bits of 0x0-0xFFFFF into two halves\r\n          charcode =\r\n            0x10000 +\r\n            (((charcode & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));\r\n          utf8.push(\r\n            0xf0 | (charcode >> 18),\r\n            0x80 | ((charcode >> 12) & 0x3f),\r\n            0x80 | ((charcode >> 6) & 0x3f),\r\n            0x80 | (charcode & 0x3f),\r\n          );\r\n        }\r\n      }\r\n      return utf8;\r\n    }\r\n\r\n    return toUTF8Array(s);\r\n  };\r\n})\r\n();\r\nexport default _qrcode;\r\n"]}