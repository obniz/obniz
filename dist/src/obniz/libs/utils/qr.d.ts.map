{"version":3,"sources":["../src/obniz/libs/utils/qr.ts"],"names":[],"mappings":"AAsBA,QAAA,MAAM,OAAO,EAAE,GAgxDb,CAAC;AA8CH,eAAe,OAAO,CAAC","file":"qr.d.ts","sourcesContent":["/* eslint-disable */\n\n/* Thanks Kazuhiko Arase */\n/* https://github.com/kazuhikoarase/qrcode-generator/tree/master/js */\n\n// ---------------------------------------------------------------------\n//\n// QR Code Generator for JavaScript\n//\n// Copyright (c) 2009 Kazuhiko Arase\n//\n// URL: http://www.d-project.com/\n//\n// Licensed under the MIT license:\n//  http://www.opensource.org/licenses/mit-license.php\n//\n// The word 'QR Code' is registered trademark of\n// DENSO WAVE INCORPORATED\n//  http://www.denso-wave.com/qrcode/faqpatent-e.html\n//\n// ---------------------------------------------------------------------\n\nconst _qrcode: any = (() => {\n  // --------------------------------------------------------------------\n  // qrcode\n  // ---------------------------------------------------------------------\n\n  /**\n   * qrcode\n   * @param typeNumber 1 to 40\n   * @param errorCorrectionLevel 'L','M','Q','H'\n   */\n  const qrcode: any = (_typeNumber: number, errorCorrectionLevelStr: \"L\" | \"M\" | \"Q\" | \"H\") => {\n    const PAD0: any = 0xec;\n    const PAD1: any = 0x11;\n\n    const _errorCorrectionLevel: any = QRErrorCorrectionLevel[errorCorrectionLevelStr];\n    let _modules: any = null;\n    let _moduleCount: any = 0;\n    let _dataCache: any = null;\n    const _dataList: any = [];\n\n    const _this: any = {};\n\n    const makeImpl: any = (test: any, maskPattern: any) => {\n      _moduleCount = _typeNumber * 4 + 17;\n      _modules = ((moduleCount: any ) => {\n        const modules: any = new Array(moduleCount);\n        for (let row = 0; row < moduleCount; row += 1) {\n          modules[row] = new Array(moduleCount);\n          for (let col = 0; col < moduleCount; col += 1) {\n            modules[row][col] = null;\n          }\n        }\n        return modules;\n      })(_moduleCount);\n\n      setupPositionProbePattern(0, 0);\n      setupPositionProbePattern(_moduleCount - 7, 0);\n      setupPositionProbePattern(0, _moduleCount - 7);\n      setupPositionAdjustPattern();\n      setupTimingPattern();\n      setupTypeInfo(test, maskPattern);\n\n      if (_typeNumber >= 7) {\n        setupTypeNumber(test);\n      }\n\n      if (_dataCache === null) {\n        _dataCache = createData(_typeNumber, _errorCorrectionLevel, _dataList);\n      }\n\n      mapData(_dataCache, maskPattern);\n    };\n\n    const setupPositionProbePattern: any = (row: number, col: number) => {\n      for (let r = -1; r <= 7; r += 1) {\n        if (row + r <= -1 || _moduleCount <= row + r) {\n          continue;\n        }\n\n        for (let c = -1; c <= 7; c += 1) {\n          if (col + c <= -1 || _moduleCount <= col + c) {\n            continue;\n          }\n\n          if (\n            (0 <= r && r <= 6 && (c === 0 || c === 6)) ||\n            (0 <= c && c <= 6 && (r === 0 || r === 6)) ||\n            (2 <= r && r <= 4 && 2 <= c && c <= 4)\n          ) {\n            _modules[row + r][col + c] = true;\n          } else {\n            _modules[row + r][col + c] = false;\n          }\n        }\n      }\n    };\n\n    const getBestMaskPattern: any = () => {\n      let minLostPoint: any = 0;\n      let pattern: any = 0;\n\n      for (let i = 0; i < 8; i += 1) {\n        makeImpl(true, i);\n\n        const lostPoint: any = QRUtil.getLostPoint(_this);\n\n        if (i === 0 || minLostPoint > lostPoint) {\n          minLostPoint = lostPoint;\n          pattern = i;\n        }\n      }\n\n      return pattern;\n    };\n\n    const setupTimingPattern: any = () => {\n      for (let r = 8; r < _moduleCount - 8; r += 1) {\n        if (_modules[r][6] !== null) {\n          continue;\n        }\n        _modules[r][6] = r % 2 === 0;\n      }\n\n      for (let c = 8; c < _moduleCount - 8; c += 1) {\n        if (_modules[6][c] !== null) {\n          continue;\n        }\n        _modules[6][c] = c % 2 === 0;\n      }\n    };\n\n    const setupPositionAdjustPattern: any = () => {\n      const pos: any = QRUtil.getPatternPosition(_typeNumber);\n\n      for (let i = 0; i < pos.length; i += 1) {\n        for (let j = 0; j < pos.length; j += 1) {\n          const row: any = pos[i];\n          const col: any = pos[j];\n\n          if (_modules[row][col] !== null) {\n            continue;\n          }\n\n          for (let r = -2; r <= 2; r += 1) {\n            for (let c = -2; c <= 2; c += 1) {\n              if (\n                r === -2 ||\n                r === 2 ||\n                c === -2 ||\n                c === 2 ||\n                (r === 0 && c === 0)\n              ) {\n                _modules[row + r][col + c] = true;\n              } else {\n                _modules[row + r][col + c] = false;\n              }\n            }\n          }\n        }\n      }\n    };\n\n    const setupTypeNumber: any = (test: any) => {\n      const bits: any = QRUtil.getBCHTypeNumber(_typeNumber);\n\n      for (let i = 0; i < 18; i += 1) {\n        const mod: any = !test && ((bits >> i) & 1) === 1;\n        _modules[Math.floor(i / 3)][i % 3 + _moduleCount - 8 - 3] = mod;\n      }\n\n      for (let i = 0; i < 18; i += 1) {\n        const mod: any = !test && ((bits >> i) & 1) === 1;\n        _modules[i % 3 + _moduleCount - 8 - 3][Math.floor(i / 3)] = mod;\n      }\n    };\n\n    const setupTypeInfo: any = (test: any, maskPattern: any) => {\n      const data: any = (_errorCorrectionLevel << 3) | maskPattern;\n      const bits: any = QRUtil.getBCHTypeInfo(data);\n\n      // vertical\n      for (let i = 0; i < 15; i += 1) {\n        const mod: any = !test && ((bits >> i) & 1) === 1;\n\n        if (i < 6) {\n          _modules[i][8] = mod;\n        } else if (i < 8) {\n          _modules[i + 1][8] = mod;\n        } else {\n          _modules[_moduleCount - 15 + i][8] = mod;\n        }\n      }\n\n      // horizontal\n      for (let i = 0; i < 15; i += 1) {\n        const mod: any = !test && ((bits >> i) & 1) === 1;\n\n        if (i < 8) {\n          _modules[8][_moduleCount - i - 1] = mod;\n        } else if (i < 9) {\n          _modules[8][15 - i - 1 + 1] = mod;\n        } else {\n          _modules[8][15 - i - 1] = mod;\n        }\n      }\n\n      // fixed module\n      _modules[_moduleCount - 8][8] = !test;\n    };\n\n    const mapData: any = (data: any, maskPattern: any) => {\n      let inc: any = -1;\n      let row: any = _moduleCount - 1;\n      let bitIndex: any = 7;\n      let byteIndex: any = 0;\n      const maskFunc: any = QRUtil.getMaskFunction(maskPattern);\n\n      for (let col = _moduleCount - 1; col > 0; col -= 2) {\n        if (col === 6) {\n          col -= 1;\n        }\n\n        while (true) {\n          for (let c = 0; c < 2; c += 1) {\n            if (_modules[row][col - c] === null) {\n              let dark: any = false;\n\n              if (byteIndex < data.length) {\n                dark = ((data[byteIndex] >>> bitIndex) & 1) === 1;\n              }\n\n              const mask: any = maskFunc(row, col - c);\n\n              if (mask) {\n                dark = !dark;\n              }\n\n              _modules[row][col - c] = dark;\n              bitIndex -= 1;\n\n              if (bitIndex === -1) {\n                byteIndex += 1;\n                bitIndex = 7;\n              }\n            }\n          }\n\n          row += inc;\n\n          if (row < 0 || _moduleCount <= row) {\n            row -= inc;\n            inc = -inc;\n            break;\n          }\n        }\n      }\n    };\n\n    const createBytes: any = (buffer: any, rsBlocks: any) => {\n      let offset: any = 0;\n\n      let maxDcCount: any = 0;\n      let maxEcCount: any = 0;\n\n      const dcdata: any = new Array(rsBlocks.length);\n      const ecdata: any = new Array(rsBlocks.length);\n\n      for (let r = 0; r < rsBlocks.length; r += 1) {\n        const dcCount: any = rsBlocks[r].dataCount;\n        const ecCount: any = rsBlocks[r].totalCount - dcCount;\n\n        maxDcCount = Math.max(maxDcCount, dcCount);\n        maxEcCount = Math.max(maxEcCount, ecCount);\n\n        dcdata[r] = new Array(dcCount);\n\n        for (let i = 0; i < dcdata[r].length; i += 1) {\n          dcdata[r][i] = 0xff & buffer.getBuffer()[i + offset];\n        }\n        offset += dcCount;\n\n        const rsPoly: any = QRUtil.getErrorCorrectPolynomial(ecCount);\n        const rawPoly: any = qrPolynomial(dcdata[r], rsPoly.getLength() - 1) as any;\n\n        const modPoly: any = rawPoly.mod(rsPoly);\n        ecdata[r] = new Array(rsPoly.getLength() - 1);\n        for (let i = 0; i < ecdata[r].length; i += 1) {\n          const modIndex: any = i + modPoly.getLength() - ecdata[r].length;\n          ecdata[r][i] = modIndex >= 0 ? modPoly.getAt(modIndex) : 0;\n        }\n      }\n\n      let totalCodeCount: any = 0;\n      for (let i = 0; i < rsBlocks.length; i += 1) {\n        totalCodeCount += rsBlocks[i].totalCount;\n      }\n\n      const data: any = new Array(totalCodeCount);\n      let index: any = 0;\n\n      for (let i = 0; i < maxDcCount; i += 1) {\n        for (let r = 0; r < rsBlocks.length; r += 1) {\n          if (i < dcdata[r].length) {\n            data[index] = dcdata[r][i];\n            index += 1;\n          }\n        }\n      }\n\n      for (let i = 0; i < maxEcCount; i += 1) {\n        for (let r = 0; r < rsBlocks.length; r += 1) {\n          if (i < ecdata[r].length) {\n            data[index] = ecdata[r][i];\n            index += 1;\n          }\n        }\n      }\n\n      return data;\n    };\n\n    const createData: any = (typeNumber: any, errorCorrectionLevel: any, dataList: any) => {\n      const rsBlocks: any = QRRSBlock.getRSBlocks(typeNumber, errorCorrectionLevel);\n\n      const buffer: any = qrBitBuffer();\n\n      for (let i = 0; i < dataList.length; i += 1) {\n        const data: any = dataList[i];\n        buffer.put(data.getMode(), 4);\n        buffer.put(\n          data.getLength(),\n          QRUtil.getLengthInBits(data.getMode(), typeNumber),\n        );\n        data.write(buffer);\n      }\n\n      // calc num max data.\n      let totalDataCount: any = 0;\n      for (let i = 0; i < rsBlocks.length; i += 1) {\n        totalDataCount += rsBlocks[i].dataCount;\n      }\n\n      if (buffer.getLengthInBits() > totalDataCount * 8) {\n        throw new Error(\"code length overflow. (\" +\n          buffer.getLengthInBits() +\n          \">\" +\n          totalDataCount * 8 +\n          \")\");\n      }\n\n      // end code\n      if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {\n        buffer.put(0, 4);\n      }\n\n      // padding\n      while (buffer.getLengthInBits() % 8 !== 0) {\n        buffer.putBit(false);\n      }\n\n      // padding\n      while (true) {\n        if (buffer.getLengthInBits() >= totalDataCount * 8) {\n          break;\n        }\n        buffer.put(PAD0, 8);\n\n        if (buffer.getLengthInBits() >= totalDataCount * 8) {\n          break;\n        }\n        buffer.put(PAD1, 8);\n      }\n\n      return createBytes(buffer, rsBlocks);\n    };\n\n    _this.addData = (data: any, mode: any) => {\n      mode = mode || \"Byte\";\n\n      let newData: any = null;\n\n      switch (mode) {\n        case \"Numeric\":\n          newData = qrNumber(data);\n          break;\n        case \"Alphanumeric\":\n          newData = qrAlphaNum(data);\n          break;\n        case \"Byte\":\n          newData = qr8BitByte(data);\n          break;\n        case \"Kanji\":\n          newData = qrKanji(data);\n          break;\n        default:\n          throw new Error(\"mode:\" + mode);\n      }\n\n      _dataList.push(newData);\n      _dataCache = null;\n    };\n\n    _this.getModules = () => {\n      return _modules;\n    };\n\n    _this.isDark = (row: number, col: number) => {\n      if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {\n        throw new Error(row + \",\" + col);\n      }\n      return _modules[row][col];\n    };\n\n    _this.getModuleCount = () => {\n      return _moduleCount;\n    };\n\n    _this.make = () => {\n      if (_typeNumber < 1) {\n        let typeNumber: any = 1;\n\n        for (; typeNumber < 40; typeNumber++) {\n          const rsBlocks: any = QRRSBlock.getRSBlocks(\n            typeNumber,\n            _errorCorrectionLevel,\n          );\n          const buffer: any = qrBitBuffer();\n\n          for (let i = 0; i < _dataList.length; i++) {\n            const data: any = _dataList[i];\n            buffer.put(data.getMode(), 4);\n            buffer.put(\n              data.getLength(),\n              QRUtil.getLengthInBits(data.getMode(), typeNumber),\n            );\n            data.write(buffer);\n          }\n\n          let totalDataCount: any = 0;\n          for (let i = 0; i < rsBlocks.length; i++) {\n            totalDataCount += rsBlocks[i].dataCount;\n          }\n\n          if (buffer.getLengthInBits() <= totalDataCount * 8) {\n            break;\n          }\n        }\n\n        _typeNumber = typeNumber;\n      }\n\n      makeImpl(false, getBestMaskPattern());\n    };\n\n    _this.createTableTag = (cellSize: any, margin: any) => {\n      cellSize = cellSize || 2;\n      margin = typeof margin === \"undefined\" ? cellSize * 4 : margin;\n\n      let qrHtml: any = \"\";\n\n      qrHtml += '<table style=\"';\n      qrHtml += \" border-width: 0px; border-style: none;\";\n      qrHtml += \" border-collapse: collapse;\";\n      qrHtml += \" padding: 0px; margin: \" + margin + \"px;\";\n      qrHtml += '\">';\n      qrHtml += \"<tbody>\";\n\n      for (let r = 0; r < _this.getModuleCount(); r += 1) {\n        qrHtml += \"<tr>\";\n\n        for (let c = 0; c < _this.getModuleCount(); c += 1) {\n          qrHtml += '<td style=\"';\n          qrHtml += \" border-width: 0px; border-style: none;\";\n          qrHtml += \" border-collapse: collapse;\";\n          qrHtml += \" padding: 0px; margin: 0px;\";\n          qrHtml += \" width: \" + cellSize + \"px;\";\n          qrHtml += \" height: \" + cellSize + \"px;\";\n          qrHtml += \" background-color: \";\n          qrHtml += _this.isDark(r, c) ? \"#000000\" : \"#ffffff\";\n          qrHtml += \";\";\n          qrHtml += '\"/>';\n        }\n\n        qrHtml += \"</tr>\";\n      }\n\n      qrHtml += \"</tbody>\";\n      qrHtml += \"</table>\";\n\n      return qrHtml;\n    };\n\n    _this.renderTo2dContext = (context: any, cellSize: any) => {\n      cellSize = cellSize || 2;\n      const length: any = _this.getModuleCount();\n      for (let row = 0; row < length; row++) {\n        for (let col = 0; col < length; col++) {\n          context.fillStyle = _this.isDark(row, col) ? \"black\" : \"white\";\n          context.fillRect(row * cellSize, col * cellSize, cellSize, cellSize);\n        }\n      }\n    };\n\n    return _this;\n  };\n\n  // ---------------------------------------------------------------------\n  // qrcode.stringToBytes\n  // ---------------------------------------------------------------------\n\n  qrcode.stringToBytesFuncs = {\n    default(s: any) {\n      const bytes: any = [];\n      for (let i = 0; i < s.length; i += 1) {\n        const c: any = s.charCodeAt(i);\n        bytes.push(c & 0xff);\n      }\n      return bytes;\n    },\n  } as any;\n\n  qrcode.stringToBytes = qrcode.stringToBytesFuncs.default;\n\n  // ---------------------------------------------------------------------\n  // qrcode.createStringToBytes\n  // ---------------------------------------------------------------------\n\n  /**\n   * @param unicodeData base64 string of byte array.\n   * [16bit Unicode],[16bit Bytes], ...\n   * @param numChars\n   */\n  qrcode.createStringToBytes = (unicodeData: any, numChars: any) => {\n    // create conversion map.\n\n    const unicodeMap: any = (() => {\n      const bin: any = base64DecodeInputStream(unicodeData);\n      const read: any = () => {\n        const b: any = bin.read();\n        if (b === -1) {\n          throw new Error(\"eof\");\n        }\n        return b;\n      };\n\n      let count: any = 0;\n      const result: any = {};\n      while (true) {\n        const b0: any = bin.read();\n        if (b0 === -1) {\n          break;\n        }\n        const b1: any = read();\n        const b2: any = read();\n        const b3: any = read();\n        const k: any = String.fromCharCode((b0 << 8) | b1);\n        const v: any = (b2 << 8) | b3;\n        result[k] = v;\n        count += 1;\n      }\n      if (count !== numChars) {\n        throw new Error(count + \" !==\" + numChars);\n      }\n\n      return result;\n    })();\n\n    const unknownChar: any = \"?\".charCodeAt(0);\n\n    return (s: any) => {\n      const bytes: any = [];\n      for (let i = 0; i < s.length; i += 1) {\n        const c: any = s.charCodeAt(i);\n        if (c < 128) {\n          bytes.push(c);\n        } else {\n          const b: any = unicodeMap[s.charAt(i)];\n          if (typeof b === \"number\") {\n            if ((b & 0xff) === b) {\n              // 1byte\n              bytes.push(b);\n            } else {\n              // 2bytes\n              bytes.push(b >>> 8);\n              bytes.push(b & 0xff);\n            }\n          } else {\n            bytes.push(unknownChar);\n          }\n        }\n      }\n      return bytes;\n    };\n  };\n\n  // ---------------------------------------------------------------------\n  // QRMode\n  // ---------------------------------------------------------------------\n\n  const QRMode: any = {\n    MODE_NUMBER: 1 << 0,\n    MODE_ALPHA_NUM: 1 << 1,\n    MODE_8BIT_BYTE: 1 << 2,\n    MODE_KANJI: 1 << 3,\n  };\n\n  // ---------------------------------------------------------------------\n  // QRErrorCorrectionLevel\n  // ---------------------------------------------------------------------\n\n  const QRErrorCorrectionLevel: any = {\n    L: 1,\n    M: 0,\n    Q: 3,\n    H: 2,\n  };\n\n  // ---------------------------------------------------------------------\n  // QRMaskPattern\n  // ---------------------------------------------------------------------\n\n  const QRMaskPattern: any = {\n    PATTERN000: 0,\n    PATTERN001: 1,\n    PATTERN010: 2,\n    PATTERN011: 3,\n    PATTERN100: 4,\n    PATTERN101: 5,\n    PATTERN110: 6,\n    PATTERN111: 7,\n  };\n\n  // ---------------------------------------------------------------------\n  // QRUtil\n  // ---------------------------------------------------------------------\n\n  const QRUtil: any = (() => {\n    const PATTERN_POSITION_TABLE: any = [\n      [],\n      [6, 18],\n      [6, 22],\n      [6, 26],\n      [6, 30],\n      [6, 34],\n      [6, 22, 38],\n      [6, 24, 42],\n      [6, 26, 46],\n      [6, 28, 50],\n      [6, 30, 54],\n      [6, 32, 58],\n      [6, 34, 62],\n      [6, 26, 46, 66],\n      [6, 26, 48, 70],\n      [6, 26, 50, 74],\n      [6, 30, 54, 78],\n      [6, 30, 56, 82],\n      [6, 30, 58, 86],\n      [6, 34, 62, 90],\n      [6, 28, 50, 72, 94],\n      [6, 26, 50, 74, 98],\n      [6, 30, 54, 78, 102],\n      [6, 28, 54, 80, 106],\n      [6, 32, 58, 84, 110],\n      [6, 30, 58, 86, 114],\n      [6, 34, 62, 90, 118],\n      [6, 26, 50, 74, 98, 122],\n      [6, 30, 54, 78, 102, 126],\n      [6, 26, 52, 78, 104, 130],\n      [6, 30, 56, 82, 108, 134],\n      [6, 34, 60, 86, 112, 138],\n      [6, 30, 58, 86, 114, 142],\n      [6, 34, 62, 90, 118, 146],\n      [6, 30, 54, 78, 102, 126, 150],\n      [6, 24, 50, 76, 102, 128, 154],\n      [6, 28, 54, 80, 106, 132, 158],\n      [6, 32, 58, 84, 110, 136, 162],\n      [6, 26, 54, 82, 110, 138, 166],\n      [6, 30, 58, 86, 114, 142, 170],\n    ];\n    const G15: any =\n      (1 << 10) |\n      (1 << 8) |\n      (1 << 5) |\n      (1 << 4) |\n      (1 << 2) |\n      (1 << 1) |\n      (1 << 0);\n    const G18: any =\n      (1 << 12) |\n      (1 << 11) |\n      (1 << 10) |\n      (1 << 9) |\n      (1 << 8) |\n      (1 << 5) |\n      (1 << 2) |\n      (1 << 0);\n    const G15_MASK: any = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);\n\n    const _this: any = {};\n\n    const getBCHDigit: any = (data: any) => {\n      let digit: any = 0;\n      while (data !== 0) {\n        digit += 1;\n        data >>>= 1;\n      }\n      return digit;\n    };\n\n    _this.getBCHTypeInfo = (data: any) => {\n      let d: any = data << 10;\n      while (getBCHDigit(d) - getBCHDigit(G15) >= 0) {\n        d ^= G15 << (getBCHDigit(d) - getBCHDigit(G15));\n      }\n      return ((data << 10) | d) ^ G15_MASK;\n    };\n\n    _this.getBCHTypeNumber = (data: any) => {\n      let d: any = data << 12;\n      while (getBCHDigit(d) - getBCHDigit(G18) >= 0) {\n        d ^= G18 << (getBCHDigit(d) - getBCHDigit(G18));\n      }\n      return (data << 12) | d;\n    };\n\n    _this.getPatternPosition = (typeNumber: number) => {\n      return PATTERN_POSITION_TABLE[typeNumber - 1];\n    };\n\n    _this.getMaskFunction = (maskPattern: any) => {\n      switch (maskPattern) {\n        case QRMaskPattern.PATTERN000:\n          return (i: any, j: any) => {\n            return (i + j) % 2 === 0;\n          };\n        case QRMaskPattern.PATTERN001:\n          return (i: any, j: any) => {\n            return i % 2 === 0;\n          };\n        case QRMaskPattern.PATTERN010:\n          return (i: any, j: any) => {\n            return j % 3 === 0;\n          };\n        case QRMaskPattern.PATTERN011:\n          return (i: any, j: any) => {\n            return (i + j) % 3 === 0;\n          };\n        case QRMaskPattern.PATTERN100:\n          return (i: any, j: any) => {\n            return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;\n          };\n        case QRMaskPattern.PATTERN101:\n          return (i: any, j: any) => {\n            return (i * j) % 2 + (i * j) % 3 === 0;\n          };\n        case QRMaskPattern.PATTERN110:\n          return (i: any, j: any) => {\n            return ((i * j) % 2 + (i * j) % 3) % 2 === 0;\n          };\n        case QRMaskPattern.PATTERN111:\n          return (i: any, j: any) => {\n            return ((i * j) % 3 + (i + j) % 2) % 2 === 0;\n          };\n\n        default:\n          throw new Error(\"bad maskPattern:\" + maskPattern);\n      }\n    };\n\n    _this.getErrorCorrectPolynomial = (errorCorrectLength: any) => {\n      let a: any = qrPolynomial([1], 0) as any;\n      for (let i = 0; i < errorCorrectLength; i += 1) {\n        a = a.multiply(qrPolynomial([1, QRMath.gexp(i)], 0));\n      }\n      return a;\n    };\n\n    _this.getLengthInBits = (mode: any, type: any) => {\n      if (1 <= type && type < 10) {\n        // 1 - 9\n\n        switch (mode) {\n          case QRMode.MODE_NUMBER:\n            return 10;\n          case QRMode.MODE_ALPHA_NUM:\n            return 9;\n          case QRMode.MODE_8BIT_BYTE:\n            return 8;\n          case QRMode.MODE_KANJI:\n            return 8;\n          default:\n            throw new Error(\"mode:\" + mode);\n        }\n      } else if (type < 27) {\n        // 10 - 26\n\n        switch (mode) {\n          case QRMode.MODE_NUMBER:\n            return 12;\n          case QRMode.MODE_ALPHA_NUM:\n            return 11;\n          case QRMode.MODE_8BIT_BYTE:\n            return 16;\n          case QRMode.MODE_KANJI:\n            return 10;\n          default:\n            throw new Error(\"mode:\" + mode);\n        }\n      } else if (type < 41) {\n        // 27 - 40\n\n        switch (mode) {\n          case QRMode.MODE_NUMBER:\n            return 14;\n          case QRMode.MODE_ALPHA_NUM:\n            return 13;\n          case QRMode.MODE_8BIT_BYTE:\n            return 16;\n          case QRMode.MODE_KANJI:\n            return 12;\n          default:\n            throw new Error(\"mode:\" + mode);\n        }\n      } else {\n        throw new Error(\"type:\" + type);\n      }\n    };\n\n    _this.getLostPoint = (__qrcode: any) => {\n      const moduleCount: any = __qrcode.getModuleCount();\n\n      let lostPoint: any = 0;\n\n      // LEVEL1\n\n      for (let row = 0; row < moduleCount; row += 1) {\n        for (let col = 0; col < moduleCount; col += 1) {\n          let sameCount: any = 0;\n          const dark: any = __qrcode.isDark(row, col);\n\n          for (let r = -1; r <= 1; r += 1) {\n            if (row + r < 0 || moduleCount <= row + r) {\n              continue;\n            }\n\n            for (let c = -1; c <= 1; c += 1) {\n              if (col + c < 0 || moduleCount <= col + c) {\n                continue;\n              }\n\n              if (r === 0 && c === 0) {\n                continue;\n              }\n\n              if (dark === __qrcode.isDark(row + r, col + c)) {\n                sameCount += 1;\n              }\n            }\n          }\n\n          if (sameCount > 5) {\n            lostPoint += 3 + sameCount - 5;\n          }\n        }\n      }\n\n      // LEVEL2\n\n      for (let row = 0; row < moduleCount - 1; row += 1) {\n        for (let col = 0; col < moduleCount - 1; col += 1) {\n          let count: any = 0;\n          if (__qrcode.isDark(row, col)) {\n            count += 1;\n          }\n          if (__qrcode.isDark(row + 1, col)) {\n            count += 1;\n          }\n          if (__qrcode.isDark(row, col + 1)) {\n            count += 1;\n          }\n          if (__qrcode.isDark(row + 1, col + 1)) {\n            count += 1;\n          }\n          if (count === 0 || count === 4) {\n            lostPoint += 3;\n          }\n        }\n      }\n\n      // LEVEL3\n\n      for (let row = 0; row < moduleCount; row += 1) {\n        for (let col = 0; col < moduleCount - 6; col += 1) {\n          if (\n            __qrcode.isDark(row, col) &&\n            !__qrcode.isDark(row, col + 1) &&\n            __qrcode.isDark(row, col + 2) &&\n            __qrcode.isDark(row, col + 3) &&\n            __qrcode.isDark(row, col + 4) &&\n            !__qrcode.isDark(row, col + 5) &&\n            __qrcode.isDark(row, col + 6)\n          ) {\n            lostPoint += 40;\n          }\n        }\n      }\n\n      for (let col = 0; col < moduleCount; col += 1) {\n        for (let row = 0; row < moduleCount - 6; row += 1) {\n          if (\n            __qrcode.isDark(row, col) &&\n            !__qrcode.isDark(row + 1, col) &&\n            __qrcode.isDark(row + 2, col) &&\n            __qrcode.isDark(row + 3, col) &&\n            __qrcode.isDark(row + 4, col) &&\n            !__qrcode.isDark(row + 5, col) &&\n            __qrcode.isDark(row + 6, col)\n          ) {\n            lostPoint += 40;\n          }\n        }\n      }\n\n      // LEVEL4\n\n      let darkCount: any = 0;\n\n      for (let col = 0; col < moduleCount; col += 1) {\n        for (let row = 0; row < moduleCount; row += 1) {\n          if (__qrcode.isDark(row, col)) {\n            darkCount += 1;\n          }\n        }\n      }\n\n      const ratio: any =\n        Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;\n      lostPoint += ratio * 10;\n\n      return lostPoint;\n    };\n\n    return _this;\n  })();\n\n  // ---------------------------------------------------------------------\n  // QRMath\n  // ---------------------------------------------------------------------\n\n  const QRMath: any = (() => {\n    const EXP_TABLE: any = new Array(256);\n    const LOG_TABLE: any = new Array(256);\n\n    // initialize tables\n    for (let i = 0; i < 8; i += 1) {\n      EXP_TABLE[i] = 1 << i;\n    }\n    for (let i = 8; i < 256; i += 1) {\n      EXP_TABLE[i] =\n        EXP_TABLE[i - 4] ^\n        EXP_TABLE[i - 5] ^\n        EXP_TABLE[i - 6] ^\n        EXP_TABLE[i - 8];\n    }\n    for (let i = 0; i < 255; i += 1) {\n      LOG_TABLE[EXP_TABLE[i]] = i;\n    }\n\n    const _this: any = {};\n\n    _this.glog = (n: any) => {\n      if (n < 1) {\n        throw new Error(\"glog(\" + n + \")\");\n      }\n\n      return LOG_TABLE[n];\n    };\n\n    _this.gexp = (n: any) => {\n      while (n < 0) {\n        n += 255;\n      }\n\n      while (n >= 256) {\n        n -= 255;\n      }\n\n      return EXP_TABLE[n];\n    };\n\n    return _this;\n  })();\n\n  // ---------------------------------------------------------------------\n  // qrPolynomial\n  // ---------------------------------------------------------------------\n\n  function qrPolynomial(num?: any, shift?: any) {\n    if (typeof num.length === \"undefined\") {\n      throw new Error(num.length + \"/\" + shift);\n    }\n\n    const _num: any = (() => {\n      let offset: any = 0;\n      while (offset < num.length && num[offset] === 0) {\n        offset += 1;\n      }\n      const __num: any = new Array(num.length - offset + shift);\n      for (let i = 0; i < num.length - offset; i += 1) {\n        __num[i] = num[i + offset];\n      }\n      return __num;\n    })();\n\n    const _this: any = {};\n\n    _this.getAt = (index: any) => {\n      return _num[index];\n    };\n\n    _this.getLength = () => {\n      return _num.length;\n    };\n\n    _this.multiply = (e: any) => {\n      const ___num: any = new Array(_this.getLength() + e.getLength() - 1);\n\n      for (let i = 0; i < _this.getLength(); i += 1) {\n        for (let j = 0; j < e.getLength(); j += 1) {\n          ___num[i + j] ^= QRMath.gexp(\n            QRMath.glog(_this.getAt(i)) + QRMath.glog(e.getAt(j)),\n          );\n        }\n      }\n\n      return qrPolynomial(___num, 0);\n    };\n\n    _this.mod = (e: any) => {\n      if (_this.getLength() - e.getLength() < 0) {\n        return _this;\n      }\n\n      const ratio: any = QRMath.glog(_this.getAt(0)) - QRMath.glog(e.getAt(0));\n\n      const __num: any = new Array(_this.getLength());\n      for (let i = 0; i < _this.getLength(); i += 1) {\n        __num[i] = _this.getAt(i);\n      }\n\n      for (let i = 0; i < e.getLength(); i += 1) {\n        __num[i] ^= QRMath.gexp(QRMath.glog(e.getAt(i)) + ratio);\n      }\n\n      // recursive call\n      return qrPolynomial(__num, 0).mod(e);\n    };\n\n    return _this;\n  }\n\n// ---------------------------------------------------------------------\n// QRRSBlock\n// ---------------------------------------------------------------------\n\n  const QRRSBlock: any = (() => {\n    const RS_BLOCK_TABLE: any = [\n      // L\n      // M\n      // Q\n      // H\n\n      // 1\n      [1, 26, 19],\n      [1, 26, 16],\n      [1, 26, 13],\n      [1, 26, 9],\n\n      // 2\n      [1, 44, 34],\n      [1, 44, 28],\n      [1, 44, 22],\n      [1, 44, 16],\n\n      // 3\n      [1, 70, 55],\n      [1, 70, 44],\n      [2, 35, 17],\n      [2, 35, 13],\n\n      // 4\n      [1, 100, 80],\n      [2, 50, 32],\n      [2, 50, 24],\n      [4, 25, 9],\n\n      // 5\n      [1, 134, 108],\n      [2, 67, 43],\n      [2, 33, 15, 2, 34, 16],\n      [2, 33, 11, 2, 34, 12],\n\n      // 6\n      [2, 86, 68],\n      [4, 43, 27],\n      [4, 43, 19],\n      [4, 43, 15],\n\n      // 7\n      [2, 98, 78],\n      [4, 49, 31],\n      [2, 32, 14, 4, 33, 15],\n      [4, 39, 13, 1, 40, 14],\n\n      // 8\n      [2, 121, 97],\n      [2, 60, 38, 2, 61, 39],\n      [4, 40, 18, 2, 41, 19],\n      [4, 40, 14, 2, 41, 15],\n\n      // 9\n      [2, 146, 116],\n      [3, 58, 36, 2, 59, 37],\n      [4, 36, 16, 4, 37, 17],\n      [4, 36, 12, 4, 37, 13],\n\n      // 10\n      [2, 86, 68, 2, 87, 69],\n      [4, 69, 43, 1, 70, 44],\n      [6, 43, 19, 2, 44, 20],\n      [6, 43, 15, 2, 44, 16],\n\n      // 11\n      [4, 101, 81],\n      [1, 80, 50, 4, 81, 51],\n      [4, 50, 22, 4, 51, 23],\n      [3, 36, 12, 8, 37, 13],\n\n      // 12\n      [2, 116, 92, 2, 117, 93],\n      [6, 58, 36, 2, 59, 37],\n      [4, 46, 20, 6, 47, 21],\n      [7, 42, 14, 4, 43, 15],\n\n      // 13\n      [4, 133, 107],\n      [8, 59, 37, 1, 60, 38],\n      [8, 44, 20, 4, 45, 21],\n      [12, 33, 11, 4, 34, 12],\n\n      // 14\n      [3, 145, 115, 1, 146, 116],\n      [4, 64, 40, 5, 65, 41],\n      [11, 36, 16, 5, 37, 17],\n      [11, 36, 12, 5, 37, 13],\n\n      // 15\n      [5, 109, 87, 1, 110, 88],\n      [5, 65, 41, 5, 66, 42],\n      [5, 54, 24, 7, 55, 25],\n      [11, 36, 12, 7, 37, 13],\n\n      // 16\n      [5, 122, 98, 1, 123, 99],\n      [7, 73, 45, 3, 74, 46],\n      [15, 43, 19, 2, 44, 20],\n      [3, 45, 15, 13, 46, 16],\n\n      // 17\n      [1, 135, 107, 5, 136, 108],\n      [10, 74, 46, 1, 75, 47],\n      [1, 50, 22, 15, 51, 23],\n      [2, 42, 14, 17, 43, 15],\n\n      // 18\n      [5, 150, 120, 1, 151, 121],\n      [9, 69, 43, 4, 70, 44],\n      [17, 50, 22, 1, 51, 23],\n      [2, 42, 14, 19, 43, 15],\n\n      // 19\n      [3, 141, 113, 4, 142, 114],\n      [3, 70, 44, 11, 71, 45],\n      [17, 47, 21, 4, 48, 22],\n      [9, 39, 13, 16, 40, 14],\n\n      // 20\n      [3, 135, 107, 5, 136, 108],\n      [3, 67, 41, 13, 68, 42],\n      [15, 54, 24, 5, 55, 25],\n      [15, 43, 15, 10, 44, 16],\n\n      // 21\n      [4, 144, 116, 4, 145, 117],\n      [17, 68, 42],\n      [17, 50, 22, 6, 51, 23],\n      [19, 46, 16, 6, 47, 17],\n\n      // 22\n      [2, 139, 111, 7, 140, 112],\n      [17, 74, 46],\n      [7, 54, 24, 16, 55, 25],\n      [34, 37, 13],\n\n      // 23\n      [4, 151, 121, 5, 152, 122],\n      [4, 75, 47, 14, 76, 48],\n      [11, 54, 24, 14, 55, 25],\n      [16, 45, 15, 14, 46, 16],\n\n      // 24\n      [6, 147, 117, 4, 148, 118],\n      [6, 73, 45, 14, 74, 46],\n      [11, 54, 24, 16, 55, 25],\n      [30, 46, 16, 2, 47, 17],\n\n      // 25\n      [8, 132, 106, 4, 133, 107],\n      [8, 75, 47, 13, 76, 48],\n      [7, 54, 24, 22, 55, 25],\n      [22, 45, 15, 13, 46, 16],\n\n      // 26\n      [10, 142, 114, 2, 143, 115],\n      [19, 74, 46, 4, 75, 47],\n      [28, 50, 22, 6, 51, 23],\n      [33, 46, 16, 4, 47, 17],\n\n      // 27\n      [8, 152, 122, 4, 153, 123],\n      [22, 73, 45, 3, 74, 46],\n      [8, 53, 23, 26, 54, 24],\n      [12, 45, 15, 28, 46, 16],\n\n      // 28\n      [3, 147, 117, 10, 148, 118],\n      [3, 73, 45, 23, 74, 46],\n      [4, 54, 24, 31, 55, 25],\n      [11, 45, 15, 31, 46, 16],\n\n      // 29\n      [7, 146, 116, 7, 147, 117],\n      [21, 73, 45, 7, 74, 46],\n      [1, 53, 23, 37, 54, 24],\n      [19, 45, 15, 26, 46, 16],\n\n      // 30\n      [5, 145, 115, 10, 146, 116],\n      [19, 75, 47, 10, 76, 48],\n      [15, 54, 24, 25, 55, 25],\n      [23, 45, 15, 25, 46, 16],\n\n      // 31\n      [13, 145, 115, 3, 146, 116],\n      [2, 74, 46, 29, 75, 47],\n      [42, 54, 24, 1, 55, 25],\n      [23, 45, 15, 28, 46, 16],\n\n      // 32\n      [17, 145, 115],\n      [10, 74, 46, 23, 75, 47],\n      [10, 54, 24, 35, 55, 25],\n      [19, 45, 15, 35, 46, 16],\n\n      // 33\n      [17, 145, 115, 1, 146, 116],\n      [14, 74, 46, 21, 75, 47],\n      [29, 54, 24, 19, 55, 25],\n      [11, 45, 15, 46, 46, 16],\n\n      // 34\n      [13, 145, 115, 6, 146, 116],\n      [14, 74, 46, 23, 75, 47],\n      [44, 54, 24, 7, 55, 25],\n      [59, 46, 16, 1, 47, 17],\n\n      // 35\n      [12, 151, 121, 7, 152, 122],\n      [12, 75, 47, 26, 76, 48],\n      [39, 54, 24, 14, 55, 25],\n      [22, 45, 15, 41, 46, 16],\n\n      // 36\n      [6, 151, 121, 14, 152, 122],\n      [6, 75, 47, 34, 76, 48],\n      [46, 54, 24, 10, 55, 25],\n      [2, 45, 15, 64, 46, 16],\n\n      // 37\n      [17, 152, 122, 4, 153, 123],\n      [29, 74, 46, 14, 75, 47],\n      [49, 54, 24, 10, 55, 25],\n      [24, 45, 15, 46, 46, 16],\n\n      // 38\n      [4, 152, 122, 18, 153, 123],\n      [13, 74, 46, 32, 75, 47],\n      [48, 54, 24, 14, 55, 25],\n      [42, 45, 15, 32, 46, 16],\n\n      // 39\n      [20, 147, 117, 4, 148, 118],\n      [40, 75, 47, 7, 76, 48],\n      [43, 54, 24, 22, 55, 25],\n      [10, 45, 15, 67, 46, 16],\n\n      // 40\n      [19, 148, 118, 6, 149, 119],\n      [18, 75, 47, 31, 76, 48],\n      [34, 54, 24, 34, 55, 25],\n      [20, 45, 15, 61, 46, 16],\n    ];\n\n    const qrRSBlock: any = (totalCount: any, dataCount: any) => {\n      const result: any = {};\n      result.totalCount = totalCount;\n      result.dataCount = dataCount;\n      return result;\n    };\n\n    const _this: any = {};\n\n    const getRsBlockTable: any = (typeNumber: any, errorCorrectionLevel: any) => {\n      switch (errorCorrectionLevel) {\n        case QRErrorCorrectionLevel.L:\n          return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];\n        case QRErrorCorrectionLevel.M:\n          return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];\n        case QRErrorCorrectionLevel.Q:\n          return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];\n        case QRErrorCorrectionLevel.H:\n          return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];\n        default:\n          return undefined;\n      }\n    };\n\n    _this.getRSBlocks = (typeNumber: any, errorCorrectionLevel: any) => {\n      const rsBlock: any = getRsBlockTable(typeNumber, errorCorrectionLevel);\n\n      if (typeof rsBlock === \"undefined\") {\n        throw new Error(\"bad rs block @ typeNumber:\" +\n          typeNumber +\n          \"/errorCorrectionLevel:\" +\n          errorCorrectionLevel);\n      }\n\n      const length: any = rsBlock.length / 3;\n\n      const list: any = [];\n\n      for (let i = 0; i < length; i += 1) {\n        const count: any = rsBlock[i * 3 + 0];\n        const totalCount: any = rsBlock[i * 3 + 1];\n        const dataCount: any = rsBlock[i * 3 + 2];\n\n        for (let j = 0; j < count; j += 1) {\n          list.push(qrRSBlock(totalCount, dataCount));\n        }\n      }\n\n      return list;\n    };\n\n    return _this;\n  })();\n\n// ---------------------------------------------------------------------\n// qrBitBuffer\n// ---------------------------------------------------------------------\n\n  const qrBitBuffer: any = () => {\n    const _buffer: any = [];\n    let _length: any = 0;\n\n    const _this: any = {};\n\n    _this.getBuffer = () => {\n      return _buffer;\n    };\n\n    _this.getAt = (index: number) => {\n      const bufIndex: any = Math.floor(index / 8);\n      return ((_buffer[bufIndex] >>> (7 - index % 8)) & 1) === 1;\n    };\n\n    _this.put = (num: number, length: number) => {\n      for (let i = 0; i < length; i += 1) {\n        _this.putBit(((num >>> (length - i - 1)) & 1) === 1);\n      }\n    };\n\n    _this.getLengthInBits = () => {\n      return _length;\n    };\n\n    _this.putBit = (bit: any) => {\n      const bufIndex: any = Math.floor(_length / 8);\n      if (_buffer.length <= bufIndex) {\n        _buffer.push(0);\n      }\n\n      if (bit) {\n        _buffer[bufIndex] |= 0x80 >>> (_length % 8);\n      }\n\n      _length += 1;\n    };\n\n    return _this;\n  };\n\n// ---------------------------------------------------------------------\n// qrNumber\n// ---------------------------------------------------------------------\n\n  const qrNumber: any = (_data: any) => {\n      const _mode: any = QRMode.MODE_NUMBER;\n\n      const _this: any = {};\n\n      _this.getMode = () => {\n        return _mode;\n      };\n\n      _this.getLength = (buffer: any) => {\n        return _data.length;\n      }\n      ;\n\n      _this.write = (buffer: any) => {\n        const data: any = _data;\n\n        let i: any = 0;\n\n        while (i + 2 < data.length) {\n          buffer.put(strToNum(data.substring(i, i + 3)), 10);\n          i += 3;\n        }\n\n        if (i < data.length) {\n          if (data.length - i === 1) {\n            buffer.put(strToNum(data.substring(i, i + 1)), 4);\n          } else if (data.length - i === 2) {\n            buffer.put(strToNum(data.substring(i, i + 2)), 7);\n          }\n        }\n      }\n      ;\n\n      const strToNum: any = (s: any) => {\n          let num: any = 0;\n          for (let i = 0; i < s.length; i += 1) {\n            num = num * 10 + chatToNum(s.charAt(i));\n          }\n          return num;\n        }\n      ;\n\n      const chatToNum: any = (c: any) => {\n          if (\"0\" <= c && c <= \"9\") {\n            return c.charCodeAt(0) - \"0\".charCodeAt(0);\n          }\n          throw new Error(\"illegal char :\" + c);\n        }\n      ;\n\n      return _this;\n    }\n  ;\n\n// ---------------------------------------------------------------------\n// qrAlphaNum\n// ---------------------------------------------------------------------\n\n  const qrAlphaNum: any = (data: any) => {\n      const _mode: any = QRMode.MODE_ALPHA_NUM;\n      const _data: any = data;\n\n      const _this: any = {};\n\n      _this.getMode = () => {\n        return _mode;\n      };\n\n      _this.getLength = (buffer: any) => {\n        return _data.length;\n      }\n      ;\n\n      _this.write = (buffer: any) => {\n        const s: any = _data;\n\n        let i: any = 0;\n\n        while (i + 1 < s.length) {\n          buffer.put(getCode(s.charAt(i)) * 45 + getCode(s.charAt(i + 1)), 11);\n          i += 2;\n        }\n\n        if (i < s.length) {\n          buffer.put(getCode(s.charAt(i)), 6);\n        }\n      }\n      ;\n\n      const getCode: any = (c: any) => {\n        if (\"0\" <= c && c <= \"9\") {\n          return c.charCodeAt(0) - \"0\".charCodeAt(0);\n        } else if (\"A\" <= c && c <= \"Z\") {\n          return c.charCodeAt(0) - \"A\".charCodeAt(0) + 10;\n        } else {\n          switch (c) {\n            case \" \":\n              return 36;\n            case \"$\":\n              return 37;\n            case \"%\":\n              return 38;\n            case \"*\":\n              return 39;\n            case \"+\":\n              return 40;\n            case \"-\":\n              return 41;\n            case \".\":\n              return 42;\n            case \"/\":\n              return 43;\n            case \":\":\n              return 44;\n            default:\n              throw new Error(\"illegal char :\" + c);\n          }\n        }\n      };\n\n      return _this;\n    }\n  ;\n\n// ---------------------------------------------------------------------\n// qr8BitByte\n// ---------------------------------------------------------------------\n\n  const qr8BitByte: any = (data: any) => {\n    const _mode: any = QRMode.MODE_8BIT_BYTE;\n    const _data: any = data;\n    const _bytes: any = qrcode.stringToBytes(data);\n\n    const _this: any = {};\n\n    _this.getMode = () => {\n      return _mode;\n    };\n\n    _this.getLength = (buffer: any) => {\n      return _bytes.length;\n    };\n\n    _this.write = (buffer: any) => {\n      for (let i = 0; i < _bytes.length; i += 1) {\n        buffer.put(_bytes[i], 8);\n      }\n    };\n\n    return _this;\n  };\n\n// ---------------------------------------------------------------------\n// qrKanji\n// ---------------------------------------------------------------------\n\n  const qrKanji: any = (data: any) => {\n    const _mode: any = QRMode.MODE_KANJI;\n    const _data: any = data;\n\n    const stringToBytes: any = (qrcode.stringToBytesFuncs as any).SJIS;\n    if (!stringToBytes) {\n      throw new Error(\"sjis not supported.\");\n    }\n\n    // tslint:disable:no-unused-expression\n    // @ts-ignore\n    !((c: string, code: number) => {\n      // self test for sjis support.\n      const test: any = stringToBytes(c);\n      if (test.length !== 2 || ((test[0] << 8) | test[1]) !== code) {\n        throw new Error(\"sjis not supported.\");\n      }\n    })(\"\\u53cb\", 0x9746);\n    // tslint:enable:no-unused-expression\n\n    const _bytes: any = stringToBytes(data);\n\n    const _this: any = {};\n\n    _this.getMode = () => {\n      return _mode;\n    };\n\n    _this.getLength = (buffer: any) => {\n      return ~~(_bytes.length / 2);\n    };\n\n    _this.write = (buffer: any) => {\n      const __data: any = _bytes;\n\n      let i: any = 0;\n\n      while (i + 1 < __data.length) {\n        let c: any = ((0xff & __data[i]) << 8) | (0xff & __data[i + 1]);\n\n        if (0x8140 <= c && c <= 0x9ffc) {\n          c -= 0x8140;\n        } else if (0xe040 <= c && c <= 0xebbf) {\n          c -= 0xc140;\n        } else {\n          throw new Error(\"illegal char at \" + (i + 1) + \"/\" + c);\n        }\n\n        c = ((c >>> 8) & 0xff) * 0xc0 + (c & 0xff);\n\n        buffer.put(c, 13);\n\n        i += 2;\n      }\n\n      if (i < __data.length) {\n        throw new Error(\"illegal char at \" + (i + 1));\n      }\n    };\n\n    return _this;\n  };\n\n// =====================================================================\n// GIF Support etc.\n//\n\n// ---------------------------------------------------------------------\n// byteArrayOutputStream\n// ---------------------------------------------------------------------\n\n  const byteArrayOutputStream: any = () => {\n    const _bytes: any = [];\n\n    const _this: any = {};\n\n    _this.writeByte = (b: any) => {\n      _bytes.push(b & 0xff);\n    };\n\n    _this.writeShort = (i: any) => {\n      _this.writeByte(i);\n      _this.writeByte(i >>> 8);\n    };\n\n    _this.writeBytes = (b: any, off: any, len: any) => {\n      off = off || 0;\n      len = len || b.length;\n      for (let i = 0; i < len; i += 1) {\n        _this.writeByte(b[i + off]);\n      }\n    };\n\n    _this.writeString = (s: any) => {\n      for (let i = 0; i < s.length; i += 1) {\n        _this.writeByte(s.charCodeAt(i));\n      }\n    }\n    ;\n\n    _this.toByteArray = () => {\n      return _bytes;\n    };\n\n    _this.toString = () => {\n      let s: any = \"\";\n      s += \"[\";\n      for (let i = 0; i < _bytes.length; i += 1) {\n        if (i > 0) {\n          s += \",\";\n        }\n        s += _bytes[i];\n      }\n      s += \"]\";\n      return s;\n    };\n\n    return _this;\n  };\n\n// ---------------------------------------------------------------------\n// base64EncodeOutputStream\n// ---------------------------------------------------------------------\n\n  const base64EncodeOutputStream: any = () => {\n    let _buffer: any = 0;\n    let _buflen: any = 0;\n    let _length: any = 0;\n    let _base64: any = \"\";\n\n    const _this: any = {};\n\n    const writeEncoded: any = (b: any) => {\n      _base64 += String.fromCharCode(encode(b & 0x3f));\n    };\n\n    const encode: any = (n: any) => {\n        if (n < 0) {\n          // error.\n        } else if (n < 26) {\n          return 0x41 + n;\n        } else if (n < 52) {\n          return 0x61 + (n - 26);\n        } else if (n < 62) {\n          return 0x30 + (n - 52);\n        } else if (n === 62) {\n          return 0x2b;\n        } else if (n === 63) {\n          return 0x2f;\n        }\n        throw new Error(\"n:\" + n);\n      }\n    ;\n\n    _this.writeByte = (n: any) => {\n      _buffer = (_buffer << 8) | (n & 0xff);\n      _buflen += 8;\n      _length += 1;\n\n      while (_buflen >= 6) {\n        writeEncoded(_buffer >>> (_buflen - 6));\n        _buflen -= 6;\n      }\n    };\n\n    _this.flush = () => {\n      if (_buflen > 0) {\n        writeEncoded(_buffer << (6 - _buflen));\n        _buffer = 0;\n        _buflen = 0;\n      }\n\n      if (_length % 3 !== 0) {\n        // padding\n        const padlen: any = 3 - _length % 3;\n        for (let i = 0; i < padlen; i += 1) {\n          _base64 += \"=\";\n        }\n      }\n    };\n\n    _this.toString = () => {\n      return _base64;\n    };\n\n    return _this;\n  };\n\n// ---------------------------------------------------------------------\n// base64DecodeInputStream\n// ---------------------------------------------------------------------\n\n  const base64DecodeInputStream: any = (str: any) => {\n      const _str: any = str;\n      let _pos: any = 0;\n      let _buffer: any = 0;\n      let _buflen: any = 0;\n\n      const _this: any = {};\n\n      _this.read = () => {\n        while (_buflen < 8) {\n          if (_pos >= _str.length) {\n            if (_buflen === 0) {\n              return -1;\n            }\n            throw new Error(\"unexpected end of file./\" + _buflen);\n          }\n\n          const c: any = _str.charAt(_pos);\n          _pos += 1;\n\n          if (c === \"=\") {\n            _buflen = 0;\n            return -1;\n          } else if (c.match(/^\\s$/)) {\n            // ignore if whitespace.\n            continue;\n          }\n\n          _buffer = (_buffer << 6) | decode(c.charCodeAt(0));\n          _buflen += 6;\n        }\n\n        const n: any = (_buffer >>> (_buflen - 8)) & 0xff;\n        _buflen -= 8;\n        return n;\n      };\n\n      const decode: any = (c: any) => {\n          if (0x41 <= c && c <= 0x5a) {\n            return c - 0x41;\n          } else if (0x61 <= c && c <= 0x7a) {\n            return c - 0x61 + 26;\n          } else if (0x30 <= c && c <= 0x39) {\n            return c - 0x30 + 52;\n          } else if (c === 0x2b) {\n            return 62;\n          } else if (c === 0x2f) {\n            return 63;\n          } else {\n            throw new Error(\"c:\" + c);\n          }\n        }\n      ;\n\n      return _this;\n    }\n  ;\n\n// ---------------------------------------------------------------------\n// returns qrcode function.\n\n  return qrcode;\n})\n();\n\n// multibyte support\n// tslint:disable-next-line:no-unused-expression\n// @ts-ignore\n// tslint:disable-next-line:no-unused-expression\n!(() => {\n  _qrcode.stringToBytesFuncs[\"UTF-8\"] = (s: any) => {\n    // http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\n    function toUTF8Array(str: any) {\n      const utf8: any = [];\n      for (let i = 0; i < str.length; i++) {\n        let charcode: any = str.charCodeAt(i);\n        if (charcode < 0x80) {\n          utf8.push(charcode);\n        } else if (charcode < 0x800) {\n          utf8.push(0xc0 | (charcode >> 6), 0x80 | (charcode & 0x3f));\n        } else if (charcode < 0xd800 || charcode >= 0xe000) {\n          utf8.push(\n            0xe0 | (charcode >> 12),\n            0x80 | ((charcode >> 6) & 0x3f),\n            0x80 | (charcode & 0x3f),\n          );\n        } else {\n          i++;\n          // UTF-16 encodes 0x10000-0x10FFFF by\n          // subtracting 0x10000 and splitting the\n          // 20 bits of 0x0-0xFFFFF into two halves\n          charcode =\n            0x10000 +\n            (((charcode & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));\n          utf8.push(\n            0xf0 | (charcode >> 18),\n            0x80 | ((charcode >> 12) & 0x3f),\n            0x80 | ((charcode >> 6) & 0x3f),\n            0x80 | (charcode & 0x3f),\n          );\n        }\n      }\n      return utf8;\n    }\n\n    return toUTF8Array(s);\n  };\n})\n();\nexport default _qrcode;\n"]}