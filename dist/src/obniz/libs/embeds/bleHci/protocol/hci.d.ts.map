{"version":3,"sources":["../src/obniz/libs/embeds/bleHci/protocol/hci.ts"],"names":[],"mappings":"AAIA,QAAA,MAAM,MAAM,EAAE,GAAuB,CAAC;AA0FtC,cAAM,GAAI,SAAQ,MAAM,CAAC,YAAY;IAC5B,SAAS,EAAE,GAAG,CAAC;IACf,MAAM,EAAE,GAAG,CAAC;IACZ,cAAc,EAAE,GAAG,CAAC;IACpB,EAAE,EAAE,GAAG,CAAC;IACR,OAAO,EAAE,GAAG,CAAC;IACb,IAAI,EAAE,GAAG,CAAC;IACV,qBAAqB,EAAE,GAAG,CAAC;IAC3B,YAAY,EAAE,GAAG,CAAC;IAClB,OAAO,EAAE,GAAG,CAAC;IACb,iBAAiB,EAAE,GAAG,CAAC;IACvB,WAAW,EAAE,GAAG,CAAC;IACjB,OAAO,EAAE,GAAG,CAAC;gBAER,QAAQ,EAAE,GAAG;IAkBZ,QAAQ;IAiBd,YAAY;IAiBZ,KAAK;IAcL,YAAY;IAMZ,gBAAgB;IAchB,UAAU;IAcV,cAAc;IAiBd,mBAAmB;IAcnB,oBAAoB;IAkBpB,iBAAiB;IAqBjB,cAAc,CAAC,OAAO,EAAE,OAAO,EAAE,gBAAgB,EAAE,OAAO;IAkB1D,YAAY,CAAC,OAAO,EAAE,GAAG,EAAE,WAAW,EAAE,GAAG;IAqC3C,YAAY,CAAC,MAAM,EAAE,GAAG,EAAE,WAAW,EAAE,GAAG,EAAE,WAAW,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,EAAE,kBAAkB,EAAE,GAAG;IAuBnG,iBAAiB,CAAC,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,EAAE,WAAW,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG;IAoBtE,UAAU,CAAC,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG;IAoBnC,QAAQ,CAAC,MAAM,EAAE,GAAG;IAiBpB,eAAe,CAAC,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG;IAgBhD,wBAAwB;IA8BxB,kBAAkB,CAAC,IAAI,EAAE,GAAG;IAoB5B,mBAAmB,CAAC,IAAI,EAAE,GAAG;IAoB7B,kBAAkB,CAAC,OAAO,EAAE,GAAG;IAiB/B,gBAAgB;IAchB,cAAc;IAcd,eAAe,CAAC,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG;IAgChD,eAAe;IAmBf,kBAAkB;IAelB,YAAY,CAAC,KAAK,EAAE,GAAG;IAwKvB,aAAa,CAAC,KAAK,EAAE,GAAG;IAUxB,uBAAuB,CAAC,GAAG,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG;IAmG1D,kBAAkB,CAAC,SAAS,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG;IAUzD,qBAAqB,CAAC,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG;IAwC5C,0BAA0B,CAAC,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG;IAkChD,2BAA2B,CAAC,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG;IAqBlD,qBAAqB,CAAC,GAAG,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG;IAQ3C,uBAAuB,CAAC,MAAM,EAAE,GAAG;IAenC,aAAa,CAAC,KAAK,EAAE,GAAG;CAGhC;AAGD,eAAe,GAAG,CAAC","file":"hci.d.ts","sourcesContent":["// let debug = require('debug')('hci');\nconst debug: any = () => {\n};\n\nconst events: any = require(\"events\");\n\nconst HCI_COMMAND_PKT: any = 0x01;\nconst HCI_ACLDATA_PKT: any = 0x02;\nconst HCI_EVENT_PKT: any = 0x04;\n\nconst ACL_START_NO_FLUSH: any = 0x00;\nconst ACL_CONT: any = 0x01;\nconst ACL_START: any = 0x02;\n\nconst EVT_DISCONN_COMPLETE: any = 0x05;\nconst EVT_ENCRYPT_CHANGE: any = 0x08;\nconst EVT_CMD_COMPLETE: any = 0x0e;\nconst EVT_CMD_STATUS: any = 0x0f;\nconst EVT_NUMBER_OF_COMPLETED_PACKETS: any = 0x13;\nconst EVT_LE_META_EVENT: any = 0x3e;\n\nconst EVT_LE_CONN_COMPLETE: any = 0x01;\nconst EVT_LE_ADVERTISING_REPORT: any = 0x02;\nconst EVT_LE_CONN_UPDATE_COMPLETE: any = 0x03;\n\nconst OGF_LINK_CTL: any = 0x01;\nconst OCF_DISCONNECT: any = 0x0006;\n\nconst OGF_HOST_CTL: any = 0x03;\nconst OCF_SET_EVENT_MASK: any = 0x0001;\nconst OCF_RESET: any = 0x0003;\nconst OCF_READ_LE_HOST_SUPPORTED: any = 0x006c;\nconst OCF_WRITE_LE_HOST_SUPPORTED: any = 0x006d;\n\nconst OGF_INFO_PARAM: any = 0x04;\nconst OCF_READ_LOCAL_VERSION: any = 0x0001;\nconst OCF_READ_BUFFER_SIZE: any = 0x0005;\nconst OCF_READ_BD_ADDR: any = 0x0009;\n\nconst OGF_STATUS_PARAM: any = 0x05;\nconst OCF_READ_RSSI: any = 0x0005;\n\nconst OGF_LE_CTL: any = 0x08;\nconst OCF_LE_SET_EVENT_MASK: any = 0x0001;\nconst OCF_LE_READ_BUFFER_SIZE: any = 0x0002;\nconst OCF_LE_SET_ADVERTISING_PARAMETERS: any = 0x0006;\nconst OCF_LE_SET_ADVERTISING_DATA: any = 0x0008;\nconst OCF_LE_SET_SCAN_RESPONSE_DATA: any = 0x0009;\nconst OCF_LE_SET_ADVERTISE_ENABLE: any = 0x000a;\nconst OCF_LE_SET_SCAN_PARAMETERS: any = 0x000b;\nconst OCF_LE_SET_SCAN_ENABLE: any = 0x000c;\nconst OCF_LE_CREATE_CONN: any = 0x000d;\nconst OCF_LE_CONN_UPDATE: any = 0x0013;\nconst OCF_LE_START_ENCRYPTION: any = 0x0019;\nconst OCF_LE_LTK_NEG_REPLY: any = 0x001b;\n\nconst DISCONNECT_CMD: any = OCF_DISCONNECT | (OGF_LINK_CTL << 10);\n\nconst SET_EVENT_MASK_CMD: any = OCF_SET_EVENT_MASK | (OGF_HOST_CTL << 10);\nconst RESET_CMD: any = OCF_RESET | (OGF_HOST_CTL << 10);\nconst READ_LE_HOST_SUPPORTED_CMD: any =\n  OCF_READ_LE_HOST_SUPPORTED | (OGF_HOST_CTL << 10);\nconst WRITE_LE_HOST_SUPPORTED_CMD: any =\n  OCF_WRITE_LE_HOST_SUPPORTED | (OGF_HOST_CTL << 10);\n\nconst READ_LOCAL_VERSION_CMD: any = OCF_READ_LOCAL_VERSION | (OGF_INFO_PARAM << 10);\nconst READ_BUFFER_SIZE_CMD: any = OCF_READ_BUFFER_SIZE | (OGF_INFO_PARAM << 10);\nconst READ_BD_ADDR_CMD: any = OCF_READ_BD_ADDR | (OGF_INFO_PARAM << 10);\n\nconst READ_RSSI_CMD: any = OCF_READ_RSSI | (OGF_STATUS_PARAM << 10);\n\nconst LE_SET_EVENT_MASK_CMD: any = OCF_LE_SET_EVENT_MASK | (OGF_LE_CTL << 10);\nconst LE_READ_BUFFER_SIZE_CMD: any = OCF_LE_READ_BUFFER_SIZE | (OGF_LE_CTL << 10);\nconst LE_SET_SCAN_PARAMETERS_CMD: any =\n  OCF_LE_SET_SCAN_PARAMETERS | (OGF_LE_CTL << 10);\nconst LE_SET_SCAN_ENABLE_CMD: any = OCF_LE_SET_SCAN_ENABLE | (OGF_LE_CTL << 10);\nconst LE_CREATE_CONN_CMD: any = OCF_LE_CREATE_CONN | (OGF_LE_CTL << 10);\nconst LE_CONN_UPDATE_CMD: any = OCF_LE_CONN_UPDATE | (OGF_LE_CTL << 10);\nconst LE_START_ENCRYPTION_CMD: any = OCF_LE_START_ENCRYPTION | (OGF_LE_CTL << 10);\nconst LE_SET_ADVERTISING_PARAMETERS_CMD: any =\n  OCF_LE_SET_ADVERTISING_PARAMETERS | (OGF_LE_CTL << 10);\n\nconst LE_SET_ADVERTISING_DATA_CMD: any =\n  OCF_LE_SET_ADVERTISING_DATA | (OGF_LE_CTL << 10);\nconst LE_SET_SCAN_RESPONSE_DATA_CMD: any =\n  OCF_LE_SET_SCAN_RESPONSE_DATA | (OGF_LE_CTL << 10);\nconst LE_SET_ADVERTISE_ENABLE_CMD: any =\n  OCF_LE_SET_ADVERTISE_ENABLE | (OGF_LE_CTL << 10);\nconst LE_LTK_NEG_REPLY_CMD: any = OCF_LE_LTK_NEG_REPLY | (OGF_LE_CTL << 10);\n\nconst HCI_OE_USER_ENDED_CONNECTION: any = 0x13;\n\nconst STATUS_MAPPER: any = require(\"./hci-status\");\n\nclass Hci extends events.EventEmitter {\n  public _obnizHci: any;\n  public _state: any;\n  public _handleBuffers: any;\n  public on: any;\n  public _socket: any;\n  public once: any;\n  public _handleAclsInProgress: any;\n  public _aclOutQueue: any;\n  public _aclMtu: any;\n  public _aclMaxInProgress: any;\n  public addressType: any;\n  public address: any;\n\n  constructor(obnizHci: any) {\n    super();\n    this._obnizHci = obnizHci;\n    this._state = null;\n\n    this._handleBuffers = {};\n\n    this.on(\"stateChange\", this.onStateChange.bind(this));\n\n    this._socket = {\n      write: (data: any) => {\n        const arr: any = Array.from(data);\n        this._obnizHci.write(arr);\n      },\n    };\n    this._obnizHci.onread = this.onSocketData.bind(this);\n  }\n\n  public async initWait() {\n    this.reset();\n    // this.setEventMask();\n    // this.setLeEventMask();\n    // this.readLocalVersion();\n    // this.writeLeHostSupported();\n    // this.readLeHostSupported();\n    // this.readBdAddr();\n\n    return new Promise ((resolve: any ) => {\n      this.once(\"stateChange\", () => {\n        // console.log('te');\n        resolve();\n      });\n    });\n  }\n\n  public setEventMask() {\n    const cmd: any = Buffer.alloc(12);\n    const eventMask: any = Buffer.from(\"fffffbff07f8bf3d\", \"hex\");\n\n    // header\n    cmd.writeUInt8(HCI_COMMAND_PKT, 0);\n    cmd.writeUInt16LE(SET_EVENT_MASK_CMD, 1);\n\n    // length\n    cmd.writeUInt8(eventMask.length, 3);\n\n    eventMask.copy(cmd, 4);\n\n    debug(\"set event mask - writing: \" + cmd.toString(\"hex\"));\n    this._socket.write(cmd);\n  }\n\n  public reset() {\n    const cmd: any = Buffer.alloc(4);\n\n    // header\n    cmd.writeUInt8(HCI_COMMAND_PKT, 0);\n    cmd.writeUInt16LE(OCF_RESET | (OGF_HOST_CTL << 10), 1);\n\n    // length\n    cmd.writeUInt8(0x00, 3);\n\n    debug(\"reset - writing: \" + cmd.toString(\"hex\"));\n    this._socket.write(cmd);\n  }\n\n  public resetBuffers() {\n    this._handleAclsInProgress = {};\n    this._handleBuffers = {};\n    this._aclOutQueue = [];\n  }\n\n  public readLocalVersion() {\n    const cmd: any = Buffer.alloc(4);\n\n    // header\n    cmd.writeUInt8(HCI_COMMAND_PKT, 0);\n    cmd.writeUInt16LE(READ_LOCAL_VERSION_CMD, 1);\n\n    // length\n    cmd.writeUInt8(0x0, 3);\n\n    debug(\"read local version - writing: \" + cmd.toString(\"hex\"));\n    this._socket.write(cmd);\n  }\n\n  public readBdAddr() {\n    const cmd: any = Buffer.alloc(4);\n\n    // header\n    cmd.writeUInt8(HCI_COMMAND_PKT, 0);\n    cmd.writeUInt16LE(READ_BD_ADDR_CMD, 1);\n\n    // length\n    cmd.writeUInt8(0x0, 3);\n\n    debug(\"read bd addr - writing: \" + cmd.toString(\"hex\"));\n    this._socket.write(cmd);\n  }\n\n  public setLeEventMask() {\n    const cmd: any = Buffer.alloc(12);\n    const leEventMask: any = Buffer.from(\"1f00000000000000\", \"hex\");\n\n    // header\n    cmd.writeUInt8(HCI_COMMAND_PKT, 0);\n    cmd.writeUInt16LE(LE_SET_EVENT_MASK_CMD, 1);\n\n    // length\n    cmd.writeUInt8(leEventMask.length, 3);\n\n    leEventMask.copy(cmd, 4);\n\n    debug(\"set le event mask - writing: \" + cmd.toString(\"hex\"));\n    this._socket.write(cmd);\n  }\n\n  public readLeHostSupported() {\n    const cmd: any = Buffer.alloc(4);\n\n    // header\n    cmd.writeUInt8(HCI_COMMAND_PKT, 0);\n    cmd.writeUInt16LE(READ_LE_HOST_SUPPORTED_CMD, 1);\n\n    // length\n    cmd.writeUInt8(0x00, 3);\n\n    debug(\"read LE host supported - writing: \" + cmd.toString(\"hex\"));\n    this._socket.write(cmd);\n  }\n\n  public writeLeHostSupported() {\n    const cmd: any = Buffer.alloc(6);\n\n    // header\n    cmd.writeUInt8(HCI_COMMAND_PKT, 0);\n    cmd.writeUInt16LE(WRITE_LE_HOST_SUPPORTED_CMD, 1);\n\n    // length\n    cmd.writeUInt8(0x02, 3);\n\n    // data\n    cmd.writeUInt8(0x01, 4); // le\n    cmd.writeUInt8(0x00, 5); // simul\n\n    debug(\"write LE host supported - writing: \" + cmd.toString(\"hex\"));\n    this._socket.write(cmd);\n  }\n\n  public setScanParameters() {\n    const cmd: any = Buffer.alloc(11);\n\n    // header\n    cmd.writeUInt8(HCI_COMMAND_PKT, 0);\n    cmd.writeUInt16LE(LE_SET_SCAN_PARAMETERS_CMD, 1);\n\n    // length\n    cmd.writeUInt8(0x07, 3);\n\n    // data\n    cmd.writeUInt8(0x01, 4); // type: 0 -> passive, 1 -> active\n    cmd.writeUInt16LE(0x0010, 5); // internal, ms * 1.6\n    cmd.writeUInt16LE(0x0010, 7); // window, ms * 1.6\n    cmd.writeUInt8(0x00, 9); // own address type: 0 -> public, 1 -> random\n    cmd.writeUInt8(0x00, 10); // filter: 0 -> all event types\n\n    debug(\"set scan parameters - writing: \" + cmd.toString(\"hex\"));\n    this._socket.write(cmd);\n  }\n\n  public setScanEnabled(enabled: boolean, filterDuplicates: boolean) {\n    const cmd: any = Buffer.alloc(6);\n\n    // header\n    cmd.writeUInt8(HCI_COMMAND_PKT, 0);\n    cmd.writeUInt16LE(LE_SET_SCAN_ENABLE_CMD, 1);\n\n    // length\n    cmd.writeUInt8(0x02, 3);\n\n    // data\n    cmd.writeUInt8(enabled ? 0x01 : 0x00, 4); // enable: 0 -> disabled, 1 -> enabled\n    cmd.writeUInt8(filterDuplicates ? 0x01 : 0x00, 5); // duplicates: 0 -> duplicates, 0 -> duplicates\n\n    debug(\"set scan enabled - writing: \" + cmd.toString(\"hex\"));\n    this._socket.write(cmd);\n  }\n\n  public createLeConn(address: any, addressType: any) {\n    const cmd: any = Buffer.alloc(29);\n\n    // header\n    cmd.writeUInt8(HCI_COMMAND_PKT, 0);\n    cmd.writeUInt16LE(LE_CREATE_CONN_CMD, 1);\n\n    // length\n    cmd.writeUInt8(0x19, 3);\n\n    // data\n    cmd.writeUInt16LE(0x0060, 4); // interval\n    cmd.writeUInt16LE(0x0030, 6); // window\n    cmd.writeUInt8(0x00, 8); // initiator filter\n\n    cmd.writeUInt8(addressType === \"random\" ? 0x01 : 0x00, 9); // peer address type\n    Buffer.from(\n      address\n        .split(\":\")\n        .reverse()\n        .join(\"\"),\n      \"hex\",\n    ).copy(cmd, 10); // peer address\n\n    cmd.writeUInt8(0x00, 16); // own address type\n\n    cmd.writeUInt16LE(0x0006, 17); // min interval\n    cmd.writeUInt16LE(0x000c, 19); // max interval\n    cmd.writeUInt16LE(0x0000, 21); // latency\n    cmd.writeUInt16LE(0x00c8, 23); // supervision timeout\n    cmd.writeUInt16LE(0x0004, 25); // min ce length\n    cmd.writeUInt16LE(0x0006, 27); // max ce length\n\n    debug(\"create le conn - writing: \" + cmd.toString(\"hex\"));\n    this._socket.write(cmd);\n  }\n\n  public connUpdateLe(handle: any, minInterval: any, maxInterval: any, latency: any, supervisionTimeout: any) {\n    const cmd: any = Buffer.alloc(18);\n\n    // header\n    cmd.writeUInt8(HCI_COMMAND_PKT, 0);\n    cmd.writeUInt16LE(LE_CONN_UPDATE_CMD, 1);\n\n    // length\n    cmd.writeUInt8(0x0e, 3);\n\n    // data\n    cmd.writeUInt16LE(handle, 4);\n    cmd.writeUInt16LE(Math.floor(minInterval / 1.25), 6); // min interval\n    cmd.writeUInt16LE(Math.floor(maxInterval / 1.25), 8); // max interval\n    cmd.writeUInt16LE(latency, 10); // latency\n    cmd.writeUInt16LE(Math.floor(supervisionTimeout / 10), 12); // supervision timeout\n    cmd.writeUInt16LE(0x0000, 14); // min ce length\n    cmd.writeUInt16LE(0x0000, 16); // max ce length\n\n    debug(\"conn update le - writing: \" + cmd.toString(\"hex\"));\n    this._socket.write(cmd);\n  }\n\n  public startLeEncryption(handle: any, random: any, diversifier: any, key: any) {\n    const cmd: any = Buffer.alloc(32);\n\n    // header\n    cmd.writeUInt8(HCI_COMMAND_PKT, 0);\n    cmd.writeUInt16LE(LE_START_ENCRYPTION_CMD, 1);\n\n    // length\n    cmd.writeUInt8(0x1c, 3);\n\n    // data\n    cmd.writeUInt16LE(handle, 4); // handle\n    random.copy(cmd, 6);\n    diversifier.copy(cmd, 14);\n    key.copy(cmd, 16);\n\n    debug(\"start le encryption - writing: \" + cmd.toString(\"hex\"));\n    this._socket.write(cmd);\n  }\n\n  public disconnect(handle: any, reason: any) {\n    const cmd: any = Buffer.alloc(7);\n\n    reason = reason || HCI_OE_USER_ENDED_CONNECTION;\n\n    // header\n    cmd.writeUInt8(HCI_COMMAND_PKT, 0);\n    cmd.writeUInt16LE(DISCONNECT_CMD, 1);\n\n    // length\n    cmd.writeUInt8(0x03, 3);\n\n    // data\n    cmd.writeUInt16LE(handle, 4); // handle\n    cmd.writeUInt8(reason, 6); // reason\n\n    debug(\"disconnect - writing: \" + cmd.toString(\"hex\"));\n    this._socket.write(cmd);\n  }\n\n  public readRssi(handle: any) {\n    const cmd: any = Buffer.alloc(6);\n\n    // header\n    cmd.writeUInt8(HCI_COMMAND_PKT, 0);\n    cmd.writeUInt16LE(READ_RSSI_CMD, 1);\n\n    // length\n    cmd.writeUInt8(0x02, 3);\n\n    // data\n    cmd.writeUInt16LE(handle, 4); // handle\n\n    debug(\"read rssi - writing: \" + cmd.toString(\"hex\"));\n    this._socket.write(cmd);\n  }\n\n  public writeAclDataPkt(handle: any, cid: any, data: any) {\n    const pkt: any = Buffer.alloc(9 + data.length);\n\n    // header\n    pkt.writeUInt8(HCI_ACLDATA_PKT, 0);\n    pkt.writeUInt16LE(handle | (ACL_START_NO_FLUSH << 12), 1);\n    pkt.writeUInt16LE(data.length + 4, 3); // data length 1\n    pkt.writeUInt16LE(data.length, 5); // data length 2\n    pkt.writeUInt16LE(cid, 7);\n\n    data.copy(pkt, 9);\n\n    debug(\"write acl data pkt - writing: \" + pkt.toString(\"hex\"));\n    this._socket.write(pkt);\n  }\n\n  public setAdvertisingParameters() {\n    const cmd: any = Buffer.alloc(19);\n\n    // header\n    cmd.writeUInt8(HCI_COMMAND_PKT, 0);\n    cmd.writeUInt16LE(LE_SET_ADVERTISING_PARAMETERS_CMD, 1);\n\n    // length\n    cmd.writeUInt8(15, 3);\n\n    const advertisementInterval: any = Math.floor(\n      (process.env.BLENO_ADVERTISING_INTERVAL\n        ? parseFloat(process.env.BLENO_ADVERTISING_INTERVAL)\n        : 100) * 1.6,\n    );\n\n    // data\n    cmd.writeUInt16LE(advertisementInterval, 4); // min interval\n    cmd.writeUInt16LE(advertisementInterval, 6); // max interval\n    cmd.writeUInt8(0x00, 8); // adv type\n    cmd.writeUInt8(0x00, 9); // own addr typ\n    cmd.writeUInt8(0x00, 10); // direct addr type\n    Buffer.from(\"000000000000\", \"hex\").copy(cmd, 11); // direct addr\n    cmd.writeUInt8(0x07, 17);\n    cmd.writeUInt8(0x00, 18);\n\n    debug(\"set advertisement parameters - writing: \" + cmd.toString(\"hex\"));\n    this._socket.write(cmd);\n  }\n\n  public setAdvertisingData(data: any) {\n    const cmd: any = Buffer.alloc(36);\n\n    cmd.fill(0x00);\n\n    // header\n    cmd.writeUInt8(HCI_COMMAND_PKT, 0);\n    cmd.writeUInt16LE(LE_SET_ADVERTISING_DATA_CMD, 1);\n\n    // length\n    cmd.writeUInt8(32, 3);\n\n    // data\n    cmd.writeUInt8(data.length, 4);\n    data.copy(cmd, 5);\n\n    debug(\"set advertisement data - writing: \" + cmd.toString(\"hex\"));\n    this._socket.write(cmd);\n  }\n\n  public setScanResponseData(data: any) {\n    const cmd: any = Buffer.alloc(36);\n\n    cmd.fill(0x00);\n\n    // header\n    cmd.writeUInt8(HCI_COMMAND_PKT, 0);\n    cmd.writeUInt16LE(LE_SET_SCAN_RESPONSE_DATA_CMD, 1);\n\n    // length\n    cmd.writeUInt8(32, 3);\n\n    // data\n    cmd.writeUInt8(data.length, 4);\n    data.copy(cmd, 5);\n\n    debug(\"set scan response data - writing: \" + cmd.toString(\"hex\"));\n    this._socket.write(cmd);\n  }\n\n  public setAdvertiseEnable(enabled: any) {\n    const cmd: any = Buffer.alloc(5);\n\n    // header\n    cmd.writeUInt8(HCI_COMMAND_PKT, 0);\n    cmd.writeUInt16LE(LE_SET_ADVERTISE_ENABLE_CMD, 1);\n\n    // length\n    cmd.writeUInt8(0x01, 3);\n\n    // data\n    cmd.writeUInt8(enabled ? 0x01 : 0x00, 4); // enable: 0 -> disabled, 1 -> enabled\n\n    debug(\"set advertise enable - writing: \" + cmd.toString(\"hex\"));\n    this._socket.write(cmd);\n  }\n\n  public leReadBufferSize() {\n    const cmd: any = Buffer.alloc(4);\n\n    // header\n    cmd.writeUInt8(HCI_COMMAND_PKT, 0);\n    cmd.writeUInt16LE(LE_READ_BUFFER_SIZE_CMD, 1);\n\n    // length\n    cmd.writeUInt8(0x0, 3);\n\n    debug(\"le read buffer size - writing: \" + cmd.toString(\"hex\"));\n    this._socket.write(cmd);\n  }\n\n  public readBufferSize() {\n    const cmd: any = Buffer.alloc(4);\n\n    // header\n    cmd.writeUInt8(HCI_COMMAND_PKT, 0);\n    cmd.writeUInt16LE(READ_BUFFER_SIZE_CMD, 1);\n\n    // length\n    cmd.writeUInt8(0x0, 3);\n\n    debug(\"read buffer size - writing: \" + cmd.toString(\"hex\"));\n    this._socket.write(cmd);\n  }\n\n  public queueAclDataPkt(handle: any, cid: any, data: any) {\n    let hf: any = handle | (ACL_START_NO_FLUSH << 12);\n    // l2cap pdu may be fragmented on hci level\n    let l2capPdu: any = Buffer.alloc(4 + data.length);\n    l2capPdu.writeUInt16LE(data.length, 0);\n    l2capPdu.writeUInt16LE(cid, 2);\n    data.copy(l2capPdu, 4);\n    let fragId: any = 0;\n\n    while (l2capPdu.length) {\n      const frag: any = l2capPdu.slice(0, this._aclMtu);\n      l2capPdu = l2capPdu.slice(frag.length);\n      const pkt: any = Buffer.alloc(5 + frag.length);\n\n      // hci header\n      pkt.writeUInt8(HCI_ACLDATA_PKT, 0);\n      pkt.writeUInt16LE(hf, 1);\n      hf |= ACL_CONT << 12;\n      pkt.writeUInt16LE(frag.length, 3); // hci pdu length\n\n      frag.copy(pkt, 5);\n\n      this._aclOutQueue.push({\n        handle,\n        pkt,\n        fragId: fragId++,\n      });\n    }\n\n    this.pushAclOutQueue();\n  }\n\n  public pushAclOutQueue() {\n    debug(\"pushAclOutQueue\");\n    let inProgress: any = 0;\n    for (const handle in this._handleAclsInProgress) {\n      inProgress += this._handleAclsInProgress[handle];\n    }\n    debug(inProgress, this._aclMaxInProgress, this._aclOutQueue.length);\n    while (inProgress < this._aclMaxInProgress && this._aclOutQueue.length) {\n      inProgress++;\n      this.writeOneAclDataPkt();\n    }\n\n    if (inProgress >= this._aclMaxInProgress && this._aclOutQueue.length) {\n      debug(\"acl out queue congested\");\n      debug(\"\\tin progress = \" + inProgress);\n      debug(\"\\twaiting = \" + this._aclOutQueue.length);\n    }\n  }\n\n  public writeOneAclDataPkt() {\n    debug(\"writeOneAclDataPkt\");\n    const pkt: any = this._aclOutQueue.shift();\n    this._handleAclsInProgress[pkt.handle]++;\n    debug(\n      \"write acl data pkt frag \" +\n      pkt.fragId +\n      \" handle \" +\n      pkt.handle +\n      \" - writing: \" +\n      pkt.pkt.toString(\"hex\"),\n    );\n    this._socket.write(pkt.pkt);\n  }\n\n  public onSocketData(array: any) {\n    const data: any = Buffer.from(array);\n    debug(\"onSocketData: \" + data.toString(\"hex\"));\n\n    const eventType: any = data.readUInt8(0);\n\n    debug(\"\\tevent type = \" + eventType);\n\n    if (HCI_EVENT_PKT === eventType) {\n      const subEventType: any = data.readUInt8(1);\n\n      debug(\"\\tsub event type = \" + subEventType);\n\n      if (subEventType === EVT_DISCONN_COMPLETE) {\n        const handle: any = data.readUInt16LE(4);\n        const reason: any = data.readUInt8(6);\n\n        debug(\"\\t\\thandle = \" + handle);\n        debug(\"\\t\\treason = \" + reason);\n\n        delete this._handleAclsInProgress[handle];\n        const aclOutQueue: any = [];\n        let discarded: any = 0;\n        for (const i in this._aclOutQueue) {\n          if (this._aclOutQueue[i].handle !== handle) {\n            aclOutQueue.push(this._aclOutQueue[i]);\n          } else {\n            discarded++;\n          }\n        }\n        if (discarded) {\n          debug(\"\\t\\tacls discarded = \" + discarded);\n        }\n        this._aclOutQueue = aclOutQueue;\n        this.pushAclOutQueue();\n\n        this.emit(\"disconnComplete\", handle, reason);\n      } else if (subEventType === EVT_ENCRYPT_CHANGE) {\n        const handle: any = data.readUInt16LE(4);\n        const encrypt: any = data.readUInt8(6);\n\n        debug(\"\\t\\thandle = \" + handle);\n        debug(\"\\t\\tencrypt = \" + encrypt);\n\n        this.emit(\"encryptChange\", handle, encrypt);\n      } else if (subEventType === EVT_CMD_COMPLETE) {\n        const ncmd: any = data.readUInt8(3);\n        const cmd: any = data.readUInt16LE(4);\n        const status: any = data.readUInt8(6);\n        const result: any = data.slice(7);\n\n        debug(\"\\t\\tncmd = \" + ncmd);\n        debug(\"\\t\\tcmd = \" + cmd);\n        debug(\"\\t\\tstatus = \" + status);\n        debug(\"\\t\\tresult = \" + result.toString(\"hex\"));\n\n        this.processCmdCompleteEvent(cmd, status, result);\n      } else if (subEventType === EVT_CMD_STATUS) {\n        const status: any = data.readUInt8(3);\n        const cmd: any = data.readUInt16LE(5);\n\n        debug(\"\\t\\tstatus = \" + status);\n        debug(\"\\t\\tcmd = \" + cmd);\n\n        this.processCmdStatusEvent(cmd, status);\n      } else if (subEventType === EVT_LE_META_EVENT) {\n        const leMetaEventType: any = data.readUInt8(3);\n        const leMetaEventStatus: any = data.readUInt8(4);\n        const leMetaEventData: any = data.slice(5);\n\n        debug(\"\\t\\tLE meta event type = \" + leMetaEventType);\n        debug(\"\\t\\tLE meta event status = \" + leMetaEventStatus);\n        debug(\"\\t\\tLE meta event data = \" + leMetaEventData.toString(\"hex\"));\n\n        this.processLeMetaEvent(\n          leMetaEventType,\n          leMetaEventStatus,\n          leMetaEventData,\n        );\n      } else if (subEventType === EVT_NUMBER_OF_COMPLETED_PACKETS) {\n        const handles: any = data.readUInt8(3);\n        for (let i = 0; i < handles; i++) {\n          const handle: any = data.readUInt16LE(4 + i * 4);\n          const pkts: any = data.readUInt16LE(6 + i * 4);\n          debug(\"\\thandle = \" + handle);\n          debug(\"\\t\\tcompleted = \" + pkts);\n          if (this._handleAclsInProgress[handle] === undefined) {\n            debug(\"\\t\\talready closed\");\n            continue;\n          }\n          if (pkts > this._handleAclsInProgress[handle]) {\n            // Linux kernel may send acl packets by itself, so be ready for underflow\n            this._handleAclsInProgress[handle] = 0;\n          } else {\n            this._handleAclsInProgress[handle] -= pkts;\n          }\n          debug(\"\\t\\tin progress = \" + this._handleAclsInProgress[handle]);\n        }\n        this.pushAclOutQueue();\n      }\n    } else if (HCI_ACLDATA_PKT === eventType) {\n      const flags: any = data.readUInt16LE(1) >> 12;\n      const handle: any = data.readUInt16LE(1) & 0x0fff;\n\n      if (ACL_START === flags) {\n        const cid: any = data.readUInt16LE(7);\n\n        const length: any = data.readUInt16LE(5);\n        const pktData: any = data.slice(9);\n\n        debug(\"\\t\\tcid = \" + cid);\n\n        if (length === pktData.length) {\n          debug(\"\\t\\thandle = \" + handle);\n          debug(\"\\t\\tdata = \" + pktData.toString(\"hex\"));\n\n          this.emit(\"aclDataPkt\", handle, cid, pktData);\n        } else {\n          this._handleBuffers[handle] = {\n            length,\n            cid,\n            data: pktData,\n          };\n        }\n      } else if (ACL_CONT === flags) {\n        if (!this._handleBuffers[handle] || !this._handleBuffers[handle].data) {\n          return;\n        }\n\n        this._handleBuffers[handle].data = Buffer.concat([\n          this._handleBuffers[handle].data,\n          data.slice(5),\n        ]);\n\n        if (\n          this._handleBuffers[handle].data.length ===\n          this._handleBuffers[handle].length\n        ) {\n          this.emit(\n            \"aclDataPkt\",\n            handle,\n            this._handleBuffers[handle].cid,\n            this._handleBuffers[handle].data,\n          );\n\n          delete this._handleBuffers[handle];\n        }\n      }\n    } else if (HCI_COMMAND_PKT === eventType) {\n      const cmd: any = data.readUInt16LE(1);\n      const len: any = data.readUInt8(3);\n\n      debug(\"\\t\\tcmd = \" + cmd);\n      debug(\"\\t\\tdata len = \" + len);\n\n      if (cmd === LE_SET_SCAN_ENABLE_CMD) {\n        const enable: any = data.readUInt8(4) === 0x1;\n        const filterDuplicates: any = data.readUInt8(5) === 0x1;\n\n        debug(\"\\t\\t\\tLE enable scan command\");\n        debug(\"\\t\\t\\tenable scanning = \" + enable);\n        debug(\"\\t\\t\\tfilter duplicates = \" + filterDuplicates);\n\n        this.emit(\"leScanEnableSetCmd\", enable, filterDuplicates);\n      }\n    }\n  }\n\n  public onSocketError(error: any) {\n    debug(\"onSocketError: \" + error.message);\n\n    if (error.message === \"Operation not permitted\") {\n      this.emit(\"stateChange\", \"unauthorized\");\n    } else if (error.message === \"Network is down\") {\n      // no-op\n    }\n  }\n\n  public processCmdCompleteEvent(cmd: any, status: any, result: any) {\n    if (cmd === RESET_CMD) {\n      this.resetBuffers();\n      this.setEventMask();\n      this.setLeEventMask();\n      this.readLocalVersion();\n      this.readBdAddr();\n      this.writeLeHostSupported();\n      this.readLeHostSupported();\n      this.leReadBufferSize();\n    } else if (cmd === READ_LE_HOST_SUPPORTED_CMD) {\n      if (status === 0) {\n        const le: any = result.readUInt8(0);\n        const simul: any = result.readUInt8(1);\n\n        debug(\"\\t\\t\\tle = \" + le);\n        debug(\"\\t\\t\\tsimul = \" + simul);\n      }\n    } else if (cmd === READ_LOCAL_VERSION_CMD) {\n      const hciVer: any = result.readUInt8(0);\n      const hciRev: any = result.readUInt16LE(1);\n      const lmpVer: any = result.readInt8(3);\n      const manufacturer: any = result.readUInt16LE(4);\n      const lmpSubVer: any = result.readUInt16LE(6);\n\n      if (hciVer < 0x06) {\n        this.emit(\"stateChange\", \"unsupported\");\n      } else if (this._state !== \"poweredOn\") {\n        this.setScanEnabled(false, true);\n        this.setScanParameters();\n      }\n\n      this.emit(\n        \"readLocalVersion\",\n        hciVer,\n        hciRev,\n        lmpVer,\n        manufacturer,\n        lmpSubVer,\n      );\n    } else if (cmd === READ_BD_ADDR_CMD) {\n      this.addressType = \"public\";\n      this.address = result\n        .toString(\"hex\")\n        .match(/.{1,2}/g)\n        .reverse()\n        .join(\":\");\n\n      debug(\"address = \" + this.address);\n\n      this.emit(\"addressChange\", this.address);\n    } else if (cmd === LE_SET_SCAN_PARAMETERS_CMD) {\n      this.emit(\"stateChange\", \"poweredOn\");\n\n      this.emit(\"leScanParametersSet\", status);\n    } else if (cmd === LE_SET_SCAN_ENABLE_CMD) {\n      this.emit(\"leScanEnableSet\", status);\n    } else if (cmd === LE_SET_ADVERTISING_PARAMETERS_CMD) {\n      this.emit(\"stateChange\", \"poweredOn\");\n\n      this.emit(\"leAdvertisingParametersSet\", status);\n    } else if (cmd === LE_SET_ADVERTISING_DATA_CMD) {\n      this.emit(\"leAdvertisingDataSet\", status);\n    } else if (cmd === LE_SET_SCAN_RESPONSE_DATA_CMD) {\n      this.emit(\"leScanResponseDataSet\", status);\n    } else if (cmd === LE_SET_ADVERTISE_ENABLE_CMD) {\n      this.emit(\"leAdvertiseEnableSet\", status);\n    } else if (cmd === READ_RSSI_CMD) {\n      const handle: any = result.readUInt16LE(0);\n      const rssi: any = result.readInt8(2);\n\n      debug(\"\\t\\t\\thandle = \" + handle);\n      debug(\"\\t\\t\\trssi = \" + rssi);\n\n      this.emit(\"rssiRead\", handle, rssi);\n    } else if (cmd === LE_LTK_NEG_REPLY_CMD) {\n      const handle: any = result.readUInt16LE(0);\n\n      debug(\"\\t\\t\\thandle = \" + handle);\n      this.emit(\"leLtkNegReply\", handle);\n    } else if (cmd === LE_READ_BUFFER_SIZE_CMD) {\n      if (!status) {\n        this.processLeReadBufferSize(result);\n      }\n    } else if (cmd === READ_BUFFER_SIZE_CMD) {\n      if (!status) {\n        const aclMtu: any = result.readUInt16LE(0);\n        const aclMaxInProgress: any = result.readUInt16LE(3);\n        // sanity\n        if (aclMtu && aclMaxInProgress) {\n          debug(\"br/edr acl mtu = \" + aclMtu);\n          debug(\"br/edr acl max pkts = \" + aclMaxInProgress);\n          this._aclMtu = aclMtu;\n          this._aclMaxInProgress = aclMaxInProgress;\n        }\n      }\n    }\n  }\n\n  public processLeMetaEvent(eventType: any, status: any, data: any) {\n    if (eventType === EVT_LE_CONN_COMPLETE) {\n      this.processLeConnComplete(status, data);\n    } else if (eventType === EVT_LE_ADVERTISING_REPORT) {\n      this.processLeAdvertisingReport(status, data);\n    } else if (eventType === EVT_LE_CONN_UPDATE_COMPLETE) {\n      this.processLeConnUpdateComplete(status, data);\n    }\n  }\n\n  public processLeConnComplete(status: any, data: any) {\n    const handle: any = data.readUInt16LE(0);\n    const role: any = data.readUInt8(2);\n    const addressType: any = data.readUInt8(3) === 0x01 ? \"random\" : \"public\";\n    const address: any = data\n      .slice(4, 10)\n      .toString(\"hex\")\n      .match(/.{1,2}/g)\n      .reverse()\n      .join(\":\");\n    const interval: any = data.readUInt16LE(10) * 1.25;\n    const latency: any = data.readUInt16LE(12); // TODO: multiplier?\n    const supervisionTimeout: any = data.readUInt16LE(14) * 10;\n    const masterClockAccuracy: any = data.readUInt8(16); // TODO: multiplier?\n\n    debug(\"\\t\\t\\thandle = \" + handle);\n    debug(\"\\t\\t\\trole = \" + role);\n    debug(\"\\t\\t\\taddress type = \" + addressType);\n    debug(\"\\t\\t\\taddress = \" + address);\n    debug(\"\\t\\t\\tinterval = \" + interval);\n    debug(\"\\t\\t\\tlatency = \" + latency);\n    debug(\"\\t\\t\\tsupervision timeout = \" + supervisionTimeout);\n    debug(\"\\t\\t\\tmaster clock accuracy = \" + masterClockAccuracy);\n\n    this._handleAclsInProgress[handle] = 0;\n\n    this.emit(\n      \"leConnComplete\",\n      status,\n      handle,\n      role,\n      addressType,\n      address,\n      interval,\n      latency,\n      supervisionTimeout,\n      masterClockAccuracy,\n    );\n  }\n\n  public processLeAdvertisingReport(count: any, data: any) {\n    for (let i = 0; i < count; i++) {\n      const type: any = data.readUInt8(0);\n      const addressType: any = data.readUInt8(1) === 0x01 ? \"random\" : \"public\";\n      const address: any = data\n        .slice(2, 8)\n        .toString(\"hex\")\n        .match(/.{1,2}/g)\n        .reverse()\n        .join(\":\");\n      const eirLength: any = data.readUInt8(8);\n      const eir: any = data.slice(9, eirLength + 9);\n      const rssi: any = data.readInt8(eirLength + 9);\n\n      debug(\"\\t\\t\\ttype = \" + type);\n      debug(\"\\t\\t\\taddress = \" + address);\n      debug(\"\\t\\t\\taddress type = \" + addressType);\n      debug(\"\\t\\t\\teir = \" + eir.toString(\"hex\"));\n      debug(\"\\t\\t\\trssi = \" + rssi);\n\n      this.emit(\n        \"leAdvertisingReport\",\n        0,\n        type,\n        address,\n        addressType,\n        eir,\n        rssi,\n      );\n\n      data = data.slice(eirLength + 10);\n    }\n  }\n\n  public processLeConnUpdateComplete(status: any, data: any) {\n    const handle: any = data.readUInt16LE(0);\n    const interval: any = data.readUInt16LE(2) * 1.25;\n    const latency: any = data.readUInt16LE(4); // TODO: multiplier?\n    const supervisionTimeout: any = data.readUInt16LE(6) * 10;\n\n    debug(\"\\t\\t\\thandle = \" + handle);\n    debug(\"\\t\\t\\tinterval = \" + interval);\n    debug(\"\\t\\t\\tlatency = \" + latency);\n    debug(\"\\t\\t\\tsupervision timeout = \" + supervisionTimeout);\n\n    this.emit(\n      \"leConnUpdateComplete\",\n      status,\n      handle,\n      interval,\n      latency,\n      supervisionTimeout,\n    );\n  }\n\n  public processCmdStatusEvent(cmd: any, status: any) {\n    if (cmd === LE_CREATE_CONN_CMD) {\n      if (status !== 0) {\n        this.emit(\"leConnComplete\", status);\n      }\n    }\n  }\n\n  public processLeReadBufferSize(result: any) {\n    const aclMtu: any = result.readUInt16LE(0);\n    const aclMaxInProgress: any = result.readUInt8(2);\n    if (!aclMtu) {\n      // as per Bluetooth specs\n      debug(\"falling back to br/edr buffer size\");\n      this.readBufferSize();\n    } else {\n      debug(\"le acl mtu = \" + aclMtu);\n      debug(\"le acl max in progress = \" + aclMaxInProgress);\n      this._aclMtu = aclMtu;\n      this._aclMaxInProgress = aclMaxInProgress;\n    }\n  }\n\n  public onStateChange(state: any) {\n    this._state = state;\n  }\n}\n\nHci.STATUS_MAPPER = STATUS_MAPPER;\nexport default Hci;\n"]}