{"version":3,"sources":["../src/obniz/libs/embeds/bleHci/protocol/central/gatt.ts"],"names":[],"mappings":";AAMA,OAAO,MAAM,MAAM,QAAQ,CAAC;AAuD5B,cAAM,IAAK,SAAQ,MAAM,CAAC,YAAY;IAC7B,QAAQ,EAAE,GAAG,CAAC;IACd,UAAU,EAAE,GAAG,CAAC;IAChB,SAAS,EAAE,GAAG,CAAC;IACf,gBAAgB,EAAE,GAAG,CAAC;IACtB,YAAY,EAAE,GAAG,CAAC;IAClB,eAAe,EAAE,GAAG,CAAC;IACrB,aAAa,EAAE,GAAG,CAAC;IACnB,IAAI,EAAE,GAAG,CAAC;IACV,SAAS,EAAE,GAAG,CAAC;IACf,qBAAqB,EAAE,GAAG,CAAC;IAC3B,wBAAwB,EAAE,GAAG,CAAC;IAC9B,4BAA4B,EAAE,GAAG,CAAC;IAClC,oBAAoB,EAAE,GAAG,CAAC;gBAErB,OAAO,EAAE,GAAG,EAAE,SAAS,EAAE,GAAG;IA0BjC,eAAe,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE,GAAG;IAkGpC,kBAAkB,CAAC,OAAO,EAAE,GAAG;IAQ/B,sBAAsB;IAGtB,cAAc;IAUd,QAAQ,CAAC,IAAI,EAAE,GAAG;IAMlB,aAAa,CAAC,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG;IAWnD,aAAa,CAAC,MAAM,EAAE,GAAG,EAAE,QAAQ,EAAE,GAAG,EAAE,aAAa,CAAC,EAAE,GAAG;IAwB7D,UAAU,CAAC,GAAG,EAAE,GAAG;IASnB,kBAAkB,CAAC,WAAW,EAAE,GAAG,EAAE,SAAS,EAAE,GAAG,EAAE,SAAS,EAAE,GAAG;IAWnE,iBAAiB,CAAC,WAAW,EAAE,GAAG,EAAE,SAAS,EAAE,GAAG,EAAE,SAAS,EAAE,GAAG;IAWlE,WAAW,CAAC,MAAM,EAAE,GAAG;IASvB,eAAe,CAAC,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG;IAUxC,eAAe,CAAC,WAAW,EAAE,GAAG,EAAE,SAAS,EAAE,GAAG;IAUhD,YAAY,CAAC,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,eAAe,EAAE,GAAG;IAazD,mBAAmB,CAAC,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG;IAcvD,mBAAmB,CAAC,MAAM,EAAE,GAAG,EAAE,oBAAoB,CAAC,EAAE,GAAG;IAS3D,kBAAkB;IAQlB,WAAW,CAAC,GAAG,EAAE,GAAG;IAmBpB,gBAAgB,CAAC,KAAK,EAAE,GAAG;IA4D3B,wBAAwB,CAAC,WAAW,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG;IA0ErD,uBAAuB,CAAC,WAAW,EAAE,GAAG,EAAE,mBAAmB,EAAE,GAAG;IAiIlE,IAAI,CAAC,WAAW,EAAE,GAAG,EAAE,kBAAkB,EAAE,GAAG;IAoE9C,KAAK,CAAC,WAAW,EAAE,GAAG,EAAE,kBAAkB,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,eAAe,EAAE,GAAG;IA8ChF,SAAS,CAAC,WAAW,EAAE,GAAG,EAAE,kBAAkB,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,eAAe,EAAE,GAAG;IAwDpF,SAAS,CAAC,WAAW,EAAE,GAAG,EAAE,kBAAkB,EAAE,GAAG,EAAE,SAAS,EAAE,GAAG;IA8CnE,MAAM,CAAC,WAAW,EAAE,GAAG,EAAE,kBAAkB,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG;IA2D7D,mBAAmB,CAAC,WAAW,EAAE,GAAG,EAAE,kBAAkB,EAAE,GAAG;IA6D7D,SAAS,CAAC,WAAW,EAAE,GAAG,EAAE,kBAAkB,EAAE,GAAG,EAAE,cAAc,EAAE,GAAG;IA0CxE,UAAU,CAAC,WAAW,EAAE,GAAG,EAAE,kBAAkB,EAAE,GAAG,EAAE,cAAc,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG;IAwCpF,UAAU,CAAC,MAAM,EAAE,GAAG;IAatB,WAAW,CAAC,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,eAAe,EAAE,GAAG;CAsBhE;AAED,eAAe,IAAI,CAAC","file":"gatt.d.ts","sourcesContent":["// let debug = require('debug')('att');\nconst debug: any = () => {\n};\n\n/* eslint-disable no-unused-vars */\n\nimport events from \"events\";\n\nconst ATT_OP_ERROR: any = 0x01;\nconst ATT_OP_MTU_REQ: any = 0x02;\nconst ATT_OP_MTU_RESP: any = 0x03;\nconst ATT_OP_FIND_INFO_REQ: any = 0x04;\nconst ATT_OP_FIND_INFO_RESP: any = 0x05;\nconst ATT_OP_READ_BY_TYPE_REQ: any = 0x08;\nconst ATT_OP_READ_BY_TYPE_RESP: any = 0x09;\nconst ATT_OP_READ_REQ: any = 0x0a;\nconst ATT_OP_READ_RESP: any = 0x0b;\nconst ATT_OP_READ_BLOB_REQ: any = 0x0c;\nconst ATT_OP_READ_BLOB_RESP: any = 0x0d;\nconst ATT_OP_READ_BY_GROUP_REQ: any = 0x10;\nconst ATT_OP_READ_BY_GROUP_RESP: any = 0x11;\nconst ATT_OP_WRITE_REQ: any = 0x12;\nconst ATT_OP_WRITE_RESP: any = 0x13;\nconst ATT_OP_PREPARE_WRITE_REQ: any = 0x16;\nconst ATT_OP_PREPARE_WRITE_RESP: any = 0x17;\nconst ATT_OP_EXECUTE_WRITE_REQ: any = 0x18;\nconst ATT_OP_EXECUTE_WRITE_RESP: any = 0x19;\nconst ATT_OP_HANDLE_NOTIFY: any = 0x1b;\nconst ATT_OP_HANDLE_IND: any = 0x1d;\nconst ATT_OP_HANDLE_CNF: any = 0x1e;\nconst ATT_OP_WRITE_CMD: any = 0x52;\n\nconst ATT_ECODE_SUCCESS: any = 0x00;\nconst ATT_ECODE_INVALID_HANDLE: any = 0x01;\nconst ATT_ECODE_READ_NOT_PERM: any = 0x02;\nconst ATT_ECODE_WRITE_NOT_PERM: any = 0x03;\nconst ATT_ECODE_INVALID_PDU: any = 0x04;\nconst ATT_ECODE_AUTHENTICATION: any = 0x05;\nconst ATT_ECODE_REQ_NOT_SUPP: any = 0x06;\nconst ATT_ECODE_INVALID_OFFSET: any = 0x07;\nconst ATT_ECODE_AUTHORIZATION: any = 0x08;\nconst ATT_ECODE_PREP_QUEUE_FULL: any = 0x09;\nconst ATT_ECODE_ATTR_NOT_FOUND: any = 0x0a;\nconst ATT_ECODE_ATTR_NOT_LONG: any = 0x0b;\nconst ATT_ECODE_INSUFF_ENCR_KEY_SIZE: any = 0x0c;\nconst ATT_ECODE_INVAL_ATTR_VALUE_LEN: any = 0x0d;\nconst ATT_ECODE_UNLIKELY: any = 0x0e;\nconst ATT_ECODE_INSUFF_ENC: any = 0x0f;\nconst ATT_ECODE_UNSUPP_GRP_TYPE: any = 0x10;\nconst ATT_ECODE_INSUFF_RESOURCES: any = 0x11;\n\nconst GATT_PRIM_SVC_UUID: any = 0x2800;\nconst GATT_INCLUDE_UUID: any = 0x2802;\nconst GATT_CHARAC_UUID: any = 0x2803;\n\nconst GATT_CLIENT_CHARAC_CFG_UUID: any = 0x2902;\nconst GATT_SERVER_CHARAC_CFG_UUID: any = 0x2903;\n\nconst ATT_CID: any = 0x0004;\n\n/* eslint-enable no-unused-vars */\nclass Gatt extends events.EventEmitter {\n  public _address: any;\n  public _aclStream: any;\n  public _services: any;\n  public _characteristics: any;\n  public _descriptors: any;\n  public _currentCommand: any;\n  public _commandQueue: any;\n  public _mtu: any;\n  public _security: any;\n  public onAclStreamDataBinded: any;\n  public onAclStreamEncryptBinded: any;\n  public onAclStreamEncryptFailBinded: any;\n  public onAclStreamEndBinded: any;\n\n  constructor(address: any, aclStream: any) {\n    super();\n    this._address = address;\n    this._aclStream = aclStream;\n\n    this._services = {};\n    this._characteristics = {};\n    this._descriptors = {};\n\n    this._currentCommand = null;\n    this._commandQueue = [];\n\n    this._mtu = 23;\n    this._security = \"low\";\n\n    this.onAclStreamDataBinded = this.onAclStreamData.bind(this);\n    this.onAclStreamEncryptBinded = this.onAclStreamEncrypt.bind(this);\n    this.onAclStreamEncryptFailBinded = this.onAclStreamEncryptFail.bind(this);\n    this.onAclStreamEndBinded = this.onAclStreamEnd.bind(this);\n\n    this._aclStream.on(\"data\", this.onAclStreamDataBinded);\n    this._aclStream.on(\"encrypt\", this.onAclStreamEncryptBinded);\n    this._aclStream.on(\"encryptFail\", this.onAclStreamEncryptFailBinded);\n    this._aclStream.on(\"end\", this.onAclStreamEndBinded);\n  }\n\n  public onAclStreamData(cid: any, data?: any) {\n    if (cid !== ATT_CID) {\n      return;\n    }\n\n    if (\n      this._currentCommand &&\n      data.toString(\"hex\") === this._currentCommand.buffer.toString(\"hex\")\n    ) {\n      debug(this._address + \": echo ... echo ... echo ...\");\n    } else if (data[0] % 2 === 0) {\n      if (process.env.NOBLE_MULTI_ROLE) {\n        debug(\n          this._address +\n          \": multi-role flag in use, ignoring command meant for peripheral role.\",\n        );\n      } else {\n        const requestType: any = data[0];\n        debug(\n          this._address +\n          \": replying with REQ_NOT_SUPP to 0x\" +\n          requestType.toString(16),\n        );\n        this.writeAtt(\n          this.errorResponse(requestType, 0x0000, ATT_ECODE_REQ_NOT_SUPP),\n        );\n      }\n    } else if (\n      data[0] === ATT_OP_HANDLE_NOTIFY ||\n      data[0] === ATT_OP_HANDLE_IND\n    ) {\n      const valueHandle: any = data.readUInt16LE(1);\n      const valueData: any = data.slice(3);\n\n      this.emit(\"handleNotify\", this._address, valueHandle, valueData);\n\n      if (data[0] === ATT_OP_HANDLE_IND) {\n        this._queueCommand(\n          this.handleConfirmation(),\n          null,\n          () => {\n            this.emit(\"handleConfirmation\", this._address, valueHandle);\n          },\n        );\n      }\n\n      for (const serviceUuid in this._services) {\n        for (const characteristicUuid in this._characteristics[serviceUuid]) {\n          if (\n            this._characteristics[serviceUuid][characteristicUuid]\n              .valueHandle === valueHandle\n          ) {\n            this.emit(\n              \"notification\",\n              this._address,\n              serviceUuid,\n              characteristicUuid,\n              valueData,\n            );\n          }\n        }\n      }\n    } else if (!this._currentCommand) {\n      debug(this._address + \": uh oh, no current command\");\n    } else {\n      if (\n        data[0] === ATT_OP_ERROR &&\n        (data[4] === ATT_ECODE_AUTHENTICATION ||\n          data[4] === ATT_ECODE_AUTHORIZATION ||\n          data[4] === ATT_ECODE_INSUFF_ENC) &&\n        this._security !== \"medium\"\n      ) {\n        this._aclStream.encrypt();\n        return;\n      }\n\n      debug(this._address + \": read: \" + data.toString(\"hex\"));\n\n      this._currentCommand.callback(data);\n\n      this._currentCommand = null;\n\n      while (this._commandQueue.length) {\n        this._currentCommand = this._commandQueue.shift();\n\n        this.writeAtt(this._currentCommand.buffer);\n\n        if (this._currentCommand.callback) {\n          break;\n        } else if (this._currentCommand.writeCallback) {\n          this._currentCommand.writeCallback();\n\n          this._currentCommand = null;\n        }\n      }\n    }\n  }\n\n  public onAclStreamEncrypt(encrypt: any) {\n    if (encrypt) {\n      this._security = \"medium\";\n\n      this.writeAtt(this._currentCommand.buffer);\n    }\n  }\n\n  public onAclStreamEncryptFail() {\n  }\n\n  public onAclStreamEnd() {\n    this._aclStream.removeListener(\"data\", this.onAclStreamDataBinded);\n    this._aclStream.removeListener(\"encrypt\", this.onAclStreamEncryptBinded);\n    this._aclStream.removeListener(\n      \"encryptFail\",\n      this.onAclStreamEncryptFailBinded,\n    );\n    this._aclStream.removeListener(\"end\", this.onAclStreamEndBinded);\n  }\n\n  public writeAtt(data: any) {\n    debug(this._address + \": write: \" + data.toString(\"hex\"));\n\n    this._aclStream.write(ATT_CID, data);\n  }\n\n  public errorResponse(opcode: any, handle: any, status: any) {\n    const buf: any = Buffer.alloc(5);\n\n    buf.writeUInt8(ATT_OP_ERROR, 0);\n    buf.writeUInt8(opcode, 1);\n    buf.writeUInt16LE(handle, 2);\n    buf.writeUInt8(status, 4);\n\n    return buf;\n  }\n\n  public _queueCommand(buffer: any, callback: any, writeCallback?: any) {\n    this._commandQueue.push({\n      buffer,\n      callback,\n      writeCallback,\n    });\n\n    if (this._currentCommand === null) {\n      while (this._commandQueue.length) {\n        this._currentCommand = this._commandQueue.shift();\n\n        this.writeAtt(this._currentCommand.buffer);\n\n        if (this._currentCommand.callback) {\n          break;\n        } else if (this._currentCommand.writeCallback) {\n          this._currentCommand.writeCallback();\n\n          this._currentCommand = null;\n        }\n      }\n    }\n  }\n\n  public mtuRequest(mtu: any) {\n    const buf: any = Buffer.alloc(3);\n\n    buf.writeUInt8(ATT_OP_MTU_REQ, 0);\n    buf.writeUInt16LE(mtu, 1);\n\n    return buf;\n  }\n\n  public readByGroupRequest(startHandle: any, endHandle: any, groupUuid: any) {\n    const buf: any = Buffer.alloc(7);\n\n    buf.writeUInt8(ATT_OP_READ_BY_GROUP_REQ, 0);\n    buf.writeUInt16LE(startHandle, 1);\n    buf.writeUInt16LE(endHandle, 3);\n    buf.writeUInt16LE(groupUuid, 5);\n\n    return buf;\n  }\n\n  public readByTypeRequest(startHandle: any, endHandle: any, groupUuid: any) {\n    const buf: any = Buffer.alloc(7);\n\n    buf.writeUInt8(ATT_OP_READ_BY_TYPE_REQ, 0);\n    buf.writeUInt16LE(startHandle, 1);\n    buf.writeUInt16LE(endHandle, 3);\n    buf.writeUInt16LE(groupUuid, 5);\n\n    return buf;\n  }\n\n  public readRequest(handle: any) {\n    const buf: any = Buffer.alloc(3);\n\n    buf.writeUInt8(ATT_OP_READ_REQ, 0);\n    buf.writeUInt16LE(handle, 1);\n\n    return buf;\n  }\n\n  public readBlobRequest(handle: any, offset: any) {\n    const buf: any = Buffer.alloc(5);\n\n    buf.writeUInt8(ATT_OP_READ_BLOB_REQ, 0);\n    buf.writeUInt16LE(handle, 1);\n    buf.writeUInt16LE(offset, 3);\n\n    return buf;\n  }\n\n  public findInfoRequest(startHandle: any, endHandle: any) {\n    const buf: any = Buffer.alloc(5);\n\n    buf.writeUInt8(ATT_OP_FIND_INFO_REQ, 0);\n    buf.writeUInt16LE(startHandle, 1);\n    buf.writeUInt16LE(endHandle, 3);\n\n    return buf;\n  }\n\n  public writeRequest(handle: any, data: any, withoutResponse: any) {\n    const buf: any = Buffer.alloc(3 + data.length);\n\n    buf.writeUInt8(withoutResponse ? ATT_OP_WRITE_CMD : ATT_OP_WRITE_REQ, 0);\n    buf.writeUInt16LE(handle, 1);\n\n    for (let i = 0; i < data.length; i++) {\n      buf.writeUInt8(data.readUInt8(i), i + 3);\n    }\n\n    return buf;\n  }\n\n  public prepareWriteRequest(handle: any, offset: any, data: any) {\n    const buf: any = Buffer.alloc(5 + data.length);\n\n    buf.writeUInt8(ATT_OP_PREPARE_WRITE_REQ, 0);\n    buf.writeUInt16LE(handle, 1);\n    buf.writeUInt16LE(offset, 3);\n\n    for (let i = 0; i < data.length; i++) {\n      buf.writeUInt8(data.readUInt8(i), i + 5);\n    }\n\n    return buf;\n  }\n\n  public executeWriteRequest(handle: any, cancelPreparedWrites?: any) {\n    const buf: any = Buffer.alloc(2);\n\n    buf.writeUInt8(ATT_OP_EXECUTE_WRITE_REQ, 0);\n    buf.writeUInt8(cancelPreparedWrites ? 0 : 1, 1);\n\n    return buf;\n  }\n\n  public handleConfirmation() {\n    const buf: any = Buffer.alloc(1);\n\n    buf.writeUInt8(ATT_OP_HANDLE_CNF, 0);\n\n    return buf;\n  }\n\n  public exchangeMtu(mtu: any) {\n    this._queueCommand(\n      this.mtuRequest(mtu),\n      (data: any ) => {\n        const opcode: any = data[0];\n\n        if (opcode === ATT_OP_MTU_RESP) {\n          const newMtu: any = data.readUInt16LE(1);\n\n          debug(this._address + \": new MTU is \" + newMtu);\n\n          this._mtu = newMtu;\n        }\n\n        this.emit(\"mtu\", this._address, this._mtu);\n      },\n    );\n  }\n\n  public discoverServices(uuids: any) {\n    const services: any = [];\n\n    const callback: any = (data: any ) => {\n      const opcode: any = data[0];\n      let i: any = 0;\n\n      if (opcode === ATT_OP_READ_BY_GROUP_RESP) {\n        const type: any = data[1];\n        const num: any = (data.length - 2) / type;\n\n        for (i = 0; i < num; i++) {\n          services.push({\n            startHandle: data.readUInt16LE(2 + i * type + 0),\n            endHandle: data.readUInt16LE(2 + i * type + 2),\n            uuid:\n              type === 6\n                ? data.readUInt16LE(2 + i * type + 4).toString(16)\n                : data\n                  .slice(2 + i * type + 4)\n                  .slice(0, 16)\n                  .toString(\"hex\")\n                  .match(/.{1,2}/g)\n                  .reverse()\n                  .join(\"\"),\n          });\n        }\n      }\n\n      if (\n        opcode !== ATT_OP_READ_BY_GROUP_RESP ||\n        services[services.length - 1].endHandle === 0xffff\n      ) {\n        const serviceUuids: any = [];\n        for (i = 0; i < services.length; i++) {\n          if (uuids.length === 0 || uuids.indexOf(services[i].uuid) !== -1) {\n            serviceUuids.push(services[i].uuid);\n          }\n\n          this._services[services[i].uuid] = services[i];\n        }\n        this.emit(\"servicesDiscover\", this._address, serviceUuids);\n      } else {\n        this._queueCommand(\n          this.readByGroupRequest(\n            services[services.length - 1].endHandle + 1,\n            0xffff,\n            GATT_PRIM_SVC_UUID,\n          ),\n          callback,\n        );\n      }\n    };\n\n    this._queueCommand(\n      this.readByGroupRequest(0x0001, 0xffff, GATT_PRIM_SVC_UUID),\n      callback,\n    );\n  }\n\n  public discoverIncludedServices(serviceUuid: any, uuids: any) {\n    const service: any = this._services[serviceUuid];\n    const includedServices: any = [];\n\n    const callback: any = (data: any ) => {\n      const opcode: any = data[0];\n      let i: any = 0;\n\n      if (opcode === ATT_OP_READ_BY_TYPE_RESP) {\n        const type: any = data[1];\n        const num: any = (data.length - 2) / type;\n\n        for (i = 0; i < num; i++) {\n          includedServices.push({\n            endHandle: data.readUInt16LE(2 + i * type + 0),\n            startHandle: data.readUInt16LE(2 + i * type + 2),\n            uuid:\n              type === 8\n                ? data.readUInt16LE(2 + i * type + 6).toString(16)\n                : data\n                  .slice(2 + i * type + 6)\n                  .slice(0, 16)\n                  .toString(\"hex\")\n                  .match(/.{1,2}/g)\n                  .reverse()\n                  .join(\"\"),\n          });\n        }\n      }\n\n      if (\n        opcode !== ATT_OP_READ_BY_TYPE_RESP ||\n        includedServices[includedServices.length - 1].endHandle ===\n        service.endHandle\n      ) {\n        const includedServiceUuids: any = [];\n\n        for (i = 0; i < includedServices.length; i++) {\n          if (\n            uuids.length === 0 ||\n            uuids.indexOf(includedServices[i].uuid) !== -1\n          ) {\n            includedServiceUuids.push(includedServices[i].uuid);\n          }\n        }\n\n        this.emit(\n          \"includedServicesDiscover\",\n          this._address,\n          service.uuid,\n          includedServiceUuids,\n        );\n      } else {\n        this._queueCommand(\n          this.readByTypeRequest(\n            includedServices[includedServices.length - 1].endHandle + 1,\n            service.endHandle,\n            GATT_INCLUDE_UUID,\n          ),\n          callback,\n        );\n      }\n    };\n\n    this._queueCommand(\n      this.readByTypeRequest(\n        service.startHandle,\n        service.endHandle,\n        GATT_INCLUDE_UUID,\n      ),\n      callback,\n    );\n  }\n\n  public discoverCharacteristics(serviceUuid: any, characteristicUuids: any) {\n    const service: any = this._services[serviceUuid];\n    const characteristics: any = [];\n\n    this._characteristics[serviceUuid] =\n      this._characteristics[serviceUuid] || {};\n    this._descriptors[serviceUuid] = this._descriptors[serviceUuid] || {};\n\n    const callback: any = (data: any ) => {\n      const opcode: any = data[0];\n      let i: any = 0;\n\n      if (opcode === ATT_OP_READ_BY_TYPE_RESP) {\n        const type: any = data[1];\n        const num: any = (data.length - 2) / type;\n\n        for (i = 0; i < num; i++) {\n          characteristics.push({\n            startHandle: data.readUInt16LE(2 + i * type + 0),\n            properties: data.readUInt8(2 + i * type + 2),\n            valueHandle: data.readUInt16LE(2 + i * type + 3),\n            uuid:\n              type === 7\n                ? data.readUInt16LE(2 + i * type + 5).toString(16)\n                : data\n                  .slice(2 + i * type + 5)\n                  .slice(0, 16)\n                  .toString(\"hex\")\n                  .match(/.{1,2}/g)\n                  .reverse()\n                  .join(\"\"),\n          });\n        }\n      }\n\n      if (\n        opcode !== ATT_OP_READ_BY_TYPE_RESP ||\n        characteristics[characteristics.length - 1].valueHandle ===\n        service.endHandle\n      ) {\n        const characteristicsDiscovered: any = [];\n        for (i = 0; i < characteristics.length; i++) {\n          const properties: any = characteristics[i].properties;\n\n          const characteristic: any = {\n            properties: [],\n            uuid: characteristics[i].uuid,\n          };\n\n          if (i !== 0) {\n            characteristics[i - 1].endHandle =\n              characteristics[i].startHandle - 1;\n          }\n\n          if (i === characteristics.length - 1) {\n            characteristics[i].endHandle = service.endHandle;\n          }\n\n          this._characteristics[serviceUuid][characteristics[i].uuid] =\n            characteristics[i];\n\n          if (properties & 0x01) {\n            characteristic.properties.push(\"broadcast\");\n          }\n\n          if (properties & 0x02) {\n            characteristic.properties.push(\"read\");\n          }\n\n          if (properties & 0x04) {\n            characteristic.properties.push(\"writeWithoutResponse\");\n          }\n\n          if (properties & 0x08) {\n            characteristic.properties.push(\"write\");\n          }\n\n          if (properties & 0x10) {\n            characteristic.properties.push(\"notify\");\n          }\n\n          if (properties & 0x20) {\n            characteristic.properties.push(\"indicate\");\n          }\n\n          if (properties & 0x40) {\n            characteristic.properties.push(\"authenticatedSignedWrites\");\n          }\n\n          if (properties & 0x80) {\n            characteristic.properties.push(\"extendedProperties\");\n          }\n\n          if (\n            characteristicUuids.length === 0 ||\n            characteristicUuids.indexOf(characteristic.uuid) !== -1\n          ) {\n            characteristicsDiscovered.push(characteristic);\n          }\n        }\n\n        this.emit(\n          \"characteristicsDiscover\",\n          this._address,\n          serviceUuid,\n          characteristicsDiscovered,\n        );\n      } else {\n        this._queueCommand(\n          this.readByTypeRequest(\n            characteristics[characteristics.length - 1].valueHandle + 1,\n            service.endHandle,\n            GATT_CHARAC_UUID,\n          ),\n          callback,\n        );\n      }\n    };\n\n    this._queueCommand(\n      this.readByTypeRequest(\n        service.startHandle,\n        service.endHandle,\n        GATT_CHARAC_UUID,\n      ),\n      callback,\n    );\n  }\n\n  public read(serviceUuid: any, characteristicUuid: any) {\n    if (\n      !this._characteristics[serviceUuid] ||\n      !this._characteristics[serviceUuid][characteristicUuid]\n    ) {\n      this.emit(\n        \"read\",\n        this._address,\n        serviceUuid,\n        characteristicUuid,\n        Buffer.alloc(0),\n        false,\n      );\n      return;\n    }\n\n    const characteristic: any = this._characteristics[serviceUuid][characteristicUuid];\n\n    let readData: any = Buffer.alloc(0);\n\n    const callback: any = (data: any ) => {\n      const opcode: any = data[0];\n\n      if (opcode === ATT_OP_READ_RESP || opcode === ATT_OP_READ_BLOB_RESP) {\n        readData = Buffer.from(\n          readData.toString(\"hex\") + data.slice(1).toString(\"hex\"),\n          \"hex\",\n        );\n\n        if (data.length === this._mtu) {\n          this._queueCommand(\n            this.readBlobRequest(characteristic.valueHandle, readData.length),\n            callback,\n          );\n        } else {\n          this.emit(\n            \"read\",\n            this._address,\n            serviceUuid,\n            characteristicUuid,\n            readData,\n            true,\n          );\n        }\n      } else if (opcode === ATT_OP_ERROR) {\n        this.emit(\n          \"read\",\n          this._address,\n          serviceUuid,\n          characteristicUuid,\n          Buffer.alloc(0),\n          false,\n        );\n      } else {\n        this.emit(\n          \"read\",\n          this._address,\n          serviceUuid,\n          characteristicUuid,\n          readData,\n          true,\n        );\n      }\n    };\n\n    this._queueCommand(this.readRequest(characteristic.valueHandle), callback);\n  }\n\n  public write(serviceUuid: any, characteristicUuid: any, data: any, withoutResponse: any) {\n    if (\n      !this._characteristics[serviceUuid] ||\n      !this._characteristics[serviceUuid][characteristicUuid]\n    ) {\n      this.emit(\"write\", this._address, serviceUuid, characteristicUuid, false);\n      return;\n    }\n\n    const characteristic: any = this._characteristics[serviceUuid][characteristicUuid];\n    if (withoutResponse) {\n      this._queueCommand(\n        this.writeRequest(characteristic.valueHandle, data, true),\n        null,\n        () => {\n          this.emit(\"write\", this._address, serviceUuid, characteristicUuid);\n        },\n      );\n    } else if (data.length + 3 > this._mtu) {\n      return this.longWrite(\n        serviceUuid,\n        characteristicUuid,\n        data,\n        withoutResponse,\n      );\n    } else {\n      this._queueCommand(\n        this.writeRequest(characteristic.valueHandle, data, false),\n        (_data: any) => {\n          const opcode: any = _data[0];\n\n          if (opcode === ATT_OP_WRITE_RESP || opcode === ATT_OP_ERROR) {\n            this.emit(\n              \"write\",\n              this._address,\n              serviceUuid,\n              characteristicUuid,\n              opcode === ATT_OP_WRITE_RESP,\n            );\n          }\n        },\n      );\n    }\n  }\n\n  /* Perform a \"long write\" as described Bluetooth Spec section 4.9.4 \"Write Long Characteristic Values\" */\n  public longWrite(serviceUuid: any, characteristicUuid: any, data: any, withoutResponse: any) {\n    const characteristic: any = this._characteristics[serviceUuid][characteristicUuid];\n    const limit: any = this._mtu - 5;\n\n    const prepareWriteCallback: any = (data_chunk: any ) => {\n      return (resp: any) => {\n        const opcode: any = resp[0];\n\n        if (opcode !== ATT_OP_PREPARE_WRITE_RESP) {\n          debug(\n            this._address +\n            \": unexpected reply opcode %d (expecting ATT_OP_PREPARE_WRITE_RESP)\",\n            opcode,\n          );\n        } else {\n          const expected_length: any = data_chunk.length + 5;\n\n          if (resp.length !== expected_length) {\n            /* the response should contain the data packet echoed back to the caller */\n            debug(\n              this._address +\n              \": unexpected prepareWriteResponse length %d (expecting %d)\",\n              resp.length,\n              expected_length,\n            );\n          }\n        }\n      };\n    };\n\n    /* split into prepare-write chunks and queue them */\n    let offset: any = 0;\n\n    while (offset < data.length) {\n      const end: any = offset + limit;\n      const chunk: any = data.slice(offset, end);\n      this._queueCommand(\n        this.prepareWriteRequest(characteristic.valueHandle, offset, chunk),\n        prepareWriteCallback(chunk),\n      );\n      offset = end;\n    }\n\n    /* queue the execute command with a callback to emit the write signal when done */\n    this._queueCommand(\n      this.executeWriteRequest(characteristic.valueHandle),\n      (resp: any) => {\n        const opcode: any = resp[0];\n\n        if (opcode === ATT_OP_EXECUTE_WRITE_RESP && !withoutResponse) {\n          this.emit(\"write\", this._address, serviceUuid, characteristicUuid);\n        }\n      },\n    );\n  }\n\n  public broadcast(serviceUuid: any, characteristicUuid: any, broadcast: any) {\n    const characteristic: any = this._characteristics[serviceUuid][characteristicUuid];\n\n    this._queueCommand(\n      this.readByTypeRequest(\n        characteristic.startHandle,\n        characteristic.endHandle,\n        GATT_SERVER_CHARAC_CFG_UUID,\n      ),\n      (data: any) => {\n        const opcode: any = data[0];\n        if (opcode === ATT_OP_READ_BY_TYPE_RESP) {\n          // let type = data[1];\n          const handle: any = data.readUInt16LE(2);\n          let value: any = data.readUInt16LE(4);\n\n          if (broadcast) {\n            value |= 0x0001;\n          } else {\n            value &= 0xfffe;\n          }\n\n          const valueBuffer: any = Buffer.alloc(2);\n          valueBuffer.writeUInt16LE(value, 0);\n\n          this._queueCommand(\n            this.writeRequest(handle, valueBuffer, false),\n            (_data: any ) => {\n              const _opcode: any = _data[0];\n\n              if (_opcode === ATT_OP_WRITE_RESP) {\n                this.emit(\n                  \"broadcast\",\n                  this._address,\n                  serviceUuid,\n                  characteristicUuid,\n                  broadcast,\n                );\n              }\n            },\n          );\n        }\n      },\n    );\n  }\n\n  public notify(serviceUuid: any, characteristicUuid: any, notify: any) {\n    const characteristic: any = this._characteristics[serviceUuid][characteristicUuid];\n\n    this._queueCommand(\n      this.readByTypeRequest(\n        characteristic.startHandle,\n        characteristic.endHandle,\n        GATT_CLIENT_CHARAC_CFG_UUID,\n      ),\n      (data: any ) => {\n        const opcode: any = data[0];\n        if (opcode === ATT_OP_READ_BY_TYPE_RESP) {\n          // let type = data[1];\n          const handle: any = data.readUInt16LE(2);\n          let value: any = data.readUInt16LE(4);\n\n          const useNotify: any = characteristic.properties & 0x10;\n          const useIndicate: any = characteristic.properties & 0x20;\n\n          if (notify) {\n            if (useNotify) {\n              value |= 0x0001;\n            } else if (useIndicate) {\n              value |= 0x0002;\n            }\n          } else {\n            if (useNotify) {\n              value &= 0xfffe;\n            } else if (useIndicate) {\n              value &= 0xfffd;\n            }\n          }\n\n          const valueBuffer: any = Buffer.alloc(2);\n          valueBuffer.writeUInt16LE(value, 0);\n\n          this._queueCommand(\n            this.writeRequest(handle, valueBuffer, false),\n            (_data: any ) => {\n              const _opcode: any = _data[0];\n              debug(\n                \"set notify write results: \" + (_opcode === ATT_OP_WRITE_RESP),\n              );\n              // if (opcode === ATT_OP_WRITE_RESP) {\n              this.emit(\n                \"notify\",\n                this._address,\n                serviceUuid,\n                characteristicUuid,\n                notify,\n              );\n              // }\n            },\n          );\n        }\n      },\n    );\n  }\n\n  public discoverDescriptors(serviceUuid: any, characteristicUuid: any) {\n    const characteristic: any = this._characteristics[serviceUuid][characteristicUuid];\n    const descriptors: any = [];\n\n    this._descriptors[serviceUuid][characteristicUuid] = {};\n\n    const callback: any = (data: any) => {\n      const opcode: any = data[0];\n      let i: any = 0;\n\n      if (opcode === ATT_OP_FIND_INFO_RESP) {\n        const num: any = data[1];\n\n        for (i = 0; i < num; i++) {\n          descriptors.push({\n            handle: data.readUInt16LE(2 + i * 4 + 0),\n            uuid: data.readUInt16LE(2 + i * 4 + 2).toString(16),\n          });\n        }\n      }\n\n      if (\n        opcode !== ATT_OP_FIND_INFO_RESP ||\n        descriptors[descriptors.length - 1].handle === characteristic.endHandle\n      ) {\n        const descriptorUuids: any = [];\n        for (i = 0; i < descriptors.length; i++) {\n          descriptorUuids.push(descriptors[i].uuid);\n\n          this._descriptors[serviceUuid][characteristicUuid][\n            descriptors[i].uuid\n            ] = descriptors[i];\n        }\n\n        this.emit(\n          \"descriptorsDiscover\",\n          this._address,\n          serviceUuid,\n          characteristicUuid,\n          descriptorUuids,\n        );\n      } else {\n        this._queueCommand(\n          this.findInfoRequest(\n            descriptors[descriptors.length - 1].handle + 1,\n            characteristic.endHandle,\n          ),\n          callback,\n        );\n      }\n    };\n\n    this._queueCommand(\n      this.findInfoRequest(\n        characteristic.valueHandle + 1,\n        characteristic.endHandle,\n      ),\n      callback,\n    );\n  }\n\n  public readValue(serviceUuid: any, characteristicUuid: any, descriptorUuid: any) {\n    if (\n      !this._descriptors[serviceUuid] ||\n      !this._descriptors[serviceUuid][characteristicUuid] ||\n      !this._descriptors[serviceUuid][characteristicUuid][descriptorUuid]\n    ) {\n      this.emit(\n        \"valueRead\",\n        this._address,\n        serviceUuid,\n        characteristicUuid,\n        descriptorUuid,\n        Buffer.alloc(0),\n        false,\n      );\n      return;\n    }\n\n    const descriptor: any = this._descriptors[serviceUuid][characteristicUuid][\n      descriptorUuid\n      ];\n\n    this._queueCommand(\n      this.readRequest(descriptor.handle),\n      (data: any ) => {\n        const opcode: any = data[0];\n\n        if (opcode === ATT_OP_READ_RESP || opcode === ATT_OP_ERROR) {\n          this.emit(\n            \"valueRead\",\n            this._address,\n            serviceUuid,\n            characteristicUuid,\n            descriptorUuid,\n            data.slice(1),\n            opcode === ATT_OP_READ_RESP,\n          );\n        }\n      },\n    );\n  }\n\n  public writeValue(serviceUuid: any, characteristicUuid: any, descriptorUuid: any, data: any) {\n    if (\n      !this._descriptors[serviceUuid] ||\n      !this._descriptors[serviceUuid][characteristicUuid] ||\n      !this._descriptors[serviceUuid][characteristicUuid][descriptorUuid]\n    ) {\n      this.emit(\n        \"valueWrite\",\n        this._address,\n        serviceUuid,\n        characteristicUuid,\n        descriptorUuid,\n        false,\n      );\n      return;\n    }\n\n    const descriptor: any = this._descriptors[serviceUuid][characteristicUuid][\n      descriptorUuid\n      ];\n\n    this._queueCommand(\n      this.writeRequest(descriptor.handle, data, false),\n      (_data: any ) => {\n        const opcode: any = _data[0];\n\n        if (opcode === ATT_OP_WRITE_RESP || opcode === ATT_OP_ERROR) {\n          this.emit(\n            \"valueWrite\",\n            this._address,\n            serviceUuid,\n            characteristicUuid,\n            descriptorUuid,\n            opcode === ATT_OP_WRITE_RESP,\n          );\n        }\n      },\n    );\n  }\n\n  public readHandle(handle: any) {\n    this._queueCommand(\n      this.readRequest(handle),\n      (data: any ) => {\n        const opcode: any = data[0];\n\n        if (opcode === ATT_OP_READ_RESP) {\n          this.emit(\"handleRead\", this._address, handle, data.slice(1));\n        }\n      },\n    );\n  }\n\n  public writeHandle(handle: any, data: any, withoutResponse: any) {\n    if (withoutResponse) {\n      this._queueCommand(\n        this.writeRequest(handle, data, true),\n        null,\n        () => {\n          this.emit(\"handleWrite\", this._address, handle);\n        },\n      );\n    } else {\n      this._queueCommand(\n        this.writeRequest(handle, data, false),\n        (_data: any ) => {\n          const opcode: any = _data[0];\n\n          if (opcode === ATT_OP_WRITE_RESP) {\n            this.emit(\"handleWrite\", this._address, handle);\n          }\n        },\n      );\n    }\n  }\n}\n\nexport default Gatt;\n"]}