{"version":3,"sources":["../src/obniz/libs/wscommand/WSCommand.ts"],"names":[],"mappings":";AAAA,OAAO,QAAQ,MAAM,YAAY,CAAC;AAIlC,MAAM,CAAC,OAAO,CAAC,QAAQ,OAAO,SAAS;IAErC,MAAM,KAAK,MAAM,iBAEhB;IAED,MAAM,KAAK,cAAc,QAExB;IAED,IAAI,sBAAsB,kCAEzB;WAEa,eAAe,CAAC,IAAI,EAAE,GAAG,EAAE,QAAQ,EAAE,GAAG;WAIxC,MAAM,CAAC,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,GAAG,UAAU;WAmCxD,UAAU,CAAC,GAAG,EAAE,GAAG;;;;;;WAqCnB,QAAQ,CAAC,UAAU,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,UAAU,GAAG,IAAI;IAsB9D,GAAG,EAAE,GAAG,CAAC;IACT,SAAS,EAAE,MAAM,CAAC;IAClB,qBAAqB,EAAE,MAAM,CAAC;IAErC,SAAS,CAAC,QAAQ,CAAC,MAAM,EAAE,MAAM,CAAC;IAClC,OAAO,CAAC,MAAM,CAAC,CAA8D;;IAatE,KAAK,CAAC,GAAG,EAAE,GAAG;IAId,WAAW,CAAC,IAAI,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG;IAMnC,aAAa,CAAC,IAAI,EAAE,GAAG;IAIvB,gBAAgB,CAAC,SAAS,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG;IA0BxD,cAAc,CAAC,SAAS,EAAE,GAAG,EAAE,UAAU,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG;IAOxD,YAAY,CAAC,SAAS,EAAE,GAAG,EAAE,UAAU,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG;IAOtD,SAAS,CAAC,EAAE,EAAE,GAAG;IAIjB,SAAS,CAAC,GAAG,EAAE,GAAG;IAMlB,qBAAqB,CAAC,OAAO,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,QAAQ,EAAE,GAAG,EAAE,SAAS,EAAE,GAAG;IAsB5E,QAAQ,CAAC,UAAU,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,QAAQ,CAAC,WAAW;IAM1D,oBAAoB,CAAC,aAAa,EAAE,GAAG,EAAE,QAAQ,EAAE,GAAG;IAuCtD,MAAM,CAAC,UAAU,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG;IAKjC,aAAa,CAAC,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,GAAG;CAmDlD;AAGD,cAAM,sBAAuB,SAAQ,KAAK;CACzC","file":"WSCommand.d.ts","sourcesContent":["import WSSchema from \"./WSSchema\";\r\n\r\nconst commandClasses: any = {};\r\n\r\nexport default abstract class WSCommand {\r\n\r\n  static get schema() {\r\n    return WSSchema;\r\n  }\r\n\r\n  static get CommandClasses() {\r\n    return commandClasses;\r\n  }\r\n\r\n  get WSCommandNotFoundError() {\r\n    return WSCommandNotFoundError;\r\n  }\r\n\r\n  public static addCommandClass(name: any, classObj: any) {\r\n    commandClasses[name] = classObj;\r\n  }\r\n\r\n  public static framed(module: any, func: any, payload: any): Uint8Array {\r\n    let payload_length: any = 0;\r\n    if (payload) {\r\n      payload_length = payload.length;\r\n    }\r\n    let length_type: any;\r\n    if (payload_length <= 0x3f) {\r\n      length_type = 0;\r\n    } else if (payload_length <= 0x3fff) {\r\n      length_type = 1;\r\n    } else if (payload_length <= 0x3fffffff) {\r\n      length_type = 2;\r\n    } else {\r\n      throw new Error(\"too big payload\");\r\n    }\r\n    let length_extra_bytse: any = length_type === 0 ? 0 : length_type === 1 ? 1 : 3;\r\n    const header_length: any = 3 + length_extra_bytse;\r\n    const result: any = new Uint8Array(header_length + payload_length);\r\n    let index: any = 0;\r\n    result[index++] = module & 0x7f;\r\n    result[index++] = func;\r\n    result[index++] =\r\n      (length_type << 6) | (payload_length >> (length_extra_bytse * 8));\r\n    while (length_extra_bytse > 0) {\r\n      length_extra_bytse--;\r\n      result[index++] = payload_length >> (length_extra_bytse * 8);\r\n    }\r\n    if (payload_length === 0) {\r\n      return result;\r\n    } else {\r\n      result.set(payload, header_length);\r\n      return result;\r\n    }\r\n  }\r\n\r\n  public static dequeueOne(buf: any) {\r\n    if (!buf || buf.byteLength === 0) {\r\n      return null;\r\n    }\r\n    if (buf.byteLength < 3) {\r\n      throw new Error(\"something wrong. buf less than 3\");\r\n    }\r\n    if (buf[0] & 0x80) {\r\n      throw new Error(\"reserved bit 1\");\r\n    }\r\n    const module: any = 0x7f & buf[0];\r\n    const func: any = buf[1];\r\n    const length_type: any = (buf[2] >> 6) & 0x3;\r\n    const length_extra_bytse: any = length_type === 0 ? 0 : length_type === 1 ? 1 : 3;\r\n    if (length_type === 4) {\r\n      throw new Error(\"invalid length\");\r\n    }\r\n    let length: any = (buf[2] & 0x3f) << (length_extra_bytse * 8);\r\n    let index: any = 3;\r\n    let shift: any = length_extra_bytse;\r\n    while (shift > 0) {\r\n      shift--;\r\n      length += buf[index] << (shift * 8);\r\n      index++;\r\n    }\r\n\r\n    return {\r\n      module,\r\n      func,\r\n      payload: buf.slice(\r\n        3 + length_extra_bytse,\r\n        3 + length_extra_bytse + length,\r\n      ),\r\n      next: buf.slice(3 + length_extra_bytse + length),\r\n    };\r\n  }\r\n\r\n  public static compress(wscommands: any, json: any): Uint8Array | null {\r\n    let ret: any = null;\r\n\r\n    function append(module: any, func: any, payload: any) {\r\n      const frame: any = WSCommand.framed(module, func, payload);\r\n      if (ret) {\r\n        const combined: any = new Uint8Array(ret.length + frame.length);\r\n        combined.set(ret, 0);\r\n        combined.set(frame, ret.length);\r\n        ret = combined;\r\n      } else {\r\n        ret = frame;\r\n      }\r\n    }\r\n\r\n    for (const wscommand of wscommands) {\r\n      wscommand.parsed = append;\r\n      wscommand.parseFromJson(json);\r\n    }\r\n    return ret;\r\n  }\r\n\r\n  public _hw: any;\r\n  public ioNotUsed: number;\r\n  public COMMAND_FUNC_ID_ERROR: number;\r\n\r\n  protected abstract module: number;\r\n  private parsed?: (module: number, func: number, payload: Uint8Array) => void;\r\n\r\n  constructor() {\r\n    this._hw = {\r\n      hw: undefined,\r\n      firmware: undefined,\r\n    };\r\n\r\n    // constants\r\n    this.COMMAND_FUNC_ID_ERROR = 0xff;\r\n    this.ioNotUsed = 0xff;\r\n  }\r\n\r\n  public setHw(obj: any) {\r\n    this._hw = obj;\r\n  }\r\n\r\n  public sendCommand(func: any, payload: any) {\r\n    if (this.parsed) {\r\n      this.parsed(this.module, func, payload);\r\n    }\r\n  }\r\n\r\n  public parseFromJson(json: any) {\r\n    // abstract\r\n  }\r\n\r\n  public notifyFromBinary(objToSend: any, func: any, payload: any) {\r\n    if (func === this.COMMAND_FUNC_ID_ERROR) {\r\n      if (!objToSend.debug) {\r\n        objToSend.debug = {};\r\n      }\r\n      const err: any = {\r\n        module: this.module,\r\n        _args: [...payload],\r\n      };\r\n\r\n      if (payload.byteLength === 3) {\r\n        err.err0 = payload[0];\r\n        err.err1 = payload[1];\r\n        err.function = payload[2];\r\n        err.message = `Error module=${this.module} func=${err.function} err0=${\r\n          err.err0\r\n        } returned=${err.err1}`;\r\n      } else {\r\n        err.message = `Error module=${this.module} with + ${err._args}`;\r\n      }\r\n      objToSend.debug.error = err;\r\n    } else {\r\n      // unknown\r\n    }\r\n  }\r\n\r\n  public envelopWarning(objToSend: any, module_key: any, obj: any) {\r\n    if (!objToSend[module_key]) {\r\n      objToSend[module_key] = {};\r\n    }\r\n    objToSend[module_key].warning = obj;\r\n  }\r\n\r\n  public envelopError(objToSend: any, module_key: any, obj: any) {\r\n    if (!objToSend[module_key]) {\r\n      objToSend[module_key] = {};\r\n    }\r\n    objToSend[module_key].error = obj;\r\n  }\r\n\r\n  public isValidIO(io: any) {\r\n    return typeof io === \"number\" && 0 <= io && io <= 11;\r\n  }\r\n\r\n  public getSchema(uri: any) {\r\n    // chack isFirst\r\n\r\n    return WSSchema.getSchema(uri);\r\n  }\r\n\r\n  public validateCommandSchema(uriList: any, json: any, rootPath: any, customArg: any) {\r\n    const res: any = {valid: 0, invalid: 0, results: [], invalidButLike: []};\r\n    for (const oneRow of uriList) {\r\n      const errors: any = this.validate(oneRow.uri, json);\r\n      res.results.push(errors);\r\n      if (errors.valid) {\r\n        res.valid++;\r\n        if (oneRow.onValid) {\r\n          oneRow.onValid.bind(this)(this.filter(oneRow.uri, json), customArg);\r\n        }\r\n      } else {\r\n        res.invalid++;\r\n        const message: any = this.onlyTypeErrorMessage(errors, rootPath);\r\n        if (message) {\r\n          res.invalidButLike.push({uri: oneRow.uri, message});\r\n        }\r\n      }\r\n    }\r\n\r\n    return res;\r\n  }\r\n\r\n  public validate(commandUri: any, json: any): WSSchema.MultiResult {\r\n    const schema: any = this.getSchema(commandUri);\r\n    const results: any = WSSchema.validateMultiple(json, schema);\r\n    return results;\r\n  }\r\n\r\n  public onlyTypeErrorMessage(validateError: any, rootPath: any) {\r\n    if (validateError.valid) {\r\n      return true;\r\n    }\r\n    if (validateError.missing && validateError.missing.length > 0) {\r\n      return false;\r\n    }\r\n\r\n    const badErrorCodes: any = [\r\n      WSSchema.errorCodes.ANY_OF_MISSING,\r\n      WSSchema.errorCodes.ONE_OF_MISSING,\r\n      WSSchema.errorCodes.ONE_OF_MULTIPLE,\r\n      WSSchema.errorCodes.NOT_PASSED,\r\n      WSSchema.errorCodes.OBJECT_REQUIRED,\r\n      WSSchema.errorCodes.OBJECT_ADDITIONAL_PROPERTIES,\r\n      WSSchema.errorCodes.CIRCULAR_REFERENCE,\r\n      WSSchema.errorCodes.FORMAT_CUSTOM,\r\n      WSSchema.errorCodes.KEYWORD_CUSTOM,\r\n      WSSchema.errorCodes.UNKNOWN_PROPERTY,\r\n    ];\r\n    const messages: any = [];\r\n    for (const error of validateError.errors) {\r\n      if (error.code === WSSchema.errorCodes.INVALID_TYPE) {\r\n        if (\r\n          (error as any).params.type === \"object\" ||\r\n          (error as any).params.expected === \"object\"\r\n        ) {\r\n          return false;\r\n        }\r\n      } else if (badErrorCodes.includes(error.code)) {\r\n        return false;\r\n      }\r\n\r\n      const path: any = rootPath + (error.dataPath || \"\").replace(/\\//g, \".\");\r\n      messages.push(`[${path}]${error.message}`);\r\n    }\r\n    return messages.join(\";\");\r\n  }\r\n\r\n  public filter(commandUri: any, json: any) {\r\n    const schema: any = this.getSchema(commandUri);\r\n    return this._filterSchema(schema, json);\r\n  }\r\n\r\n  public _filterSchema(schema: any, json: any): any {\r\n    if (schema.$ref) {\r\n      const refSchema: any = WSSchema.getSchema(schema.$ref);\r\n      return this._filterSchema(refSchema, json);\r\n    }\r\n\r\n    if (json === undefined) {\r\n      return schema.default;\r\n    }\r\n\r\n    if (\r\n      schema.type === \"string\" ||\r\n      schema.type === \"integer\" ||\r\n      schema.type === \"boolean\" ||\r\n      schema.type === \"number\" ||\r\n      schema.type === \"null\" ||\r\n      schema.filter === \"pass_all\"\r\n    ) {\r\n      return json;\r\n    }\r\n\r\n    if (schema.type === \"array\") {\r\n      const results: any = [];\r\n      for (const key in json) {\r\n        results[key] = this._filterSchema(schema.items, json[key]);\r\n      }\r\n      return results;\r\n    }\r\n\r\n    if (schema.type === \"object\") {\r\n      const results: any = {};\r\n      for (const key in schema.properties) {\r\n        results[key] = this._filterSchema(schema.properties[key], json[key]);\r\n      }\r\n\r\n      for (const pattern in schema.patternProperties) {\r\n        const reg: any = new RegExp(pattern);\r\n        for (const key of Object.keys(json)) {\r\n          if (reg.test(key)) {\r\n            results[key] = this._filterSchema(\r\n              schema.patternProperties[pattern],\r\n              json[key],\r\n            );\r\n          }\r\n        }\r\n      }\r\n      return results;\r\n    }\r\n\r\n    throw Error(\"unknown json schema type\");\r\n  }\r\n}\r\n\r\n// tslint:disable-next-line:max-classes-per-file\r\nclass WSCommandNotFoundError extends Error {\r\n}\r\n"]}