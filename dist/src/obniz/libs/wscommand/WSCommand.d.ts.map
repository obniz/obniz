{"version":3,"sources":["../src/obniz/libs/wscommand/WSCommand.ts"],"names":[],"mappings":";AAAA,OAAO,QAAQ,MAAM,YAAY,CAAC;AAKlC;;GAEG;AACH,MAAM,CAAC,OAAO,CAAC,QAAQ,OAAO,SAAS;IAErC,MAAM,KAAK,MAAM,iBAEhB;IAED,MAAM,KAAK,cAAc,QAExB;IAED,IAAI,sBAAsB,kCAEzB;WAEa,eAAe,CAAC,IAAI,EAAE,GAAG,EAAE,QAAQ,EAAE,GAAG;WAIxC,MAAM,CAAC,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,GAAG,UAAU;WAmCxD,UAAU,CAAC,GAAG,EAAE,GAAG;;;;;;WAqCnB,QAAQ,CAAC,UAAU,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,UAAU,GAAG,IAAI;IAsB9D,GAAG,EAAE,GAAG,CAAC;IACT,SAAS,EAAE,MAAM,CAAC;IAClB,qBAAqB,EAAE,MAAM,CAAC;IAErC,SAAS,CAAC,QAAQ,CAAC,MAAM,EAAE,MAAM,CAAC;IAClC,OAAO,CAAC,MAAM,CAAC,CAA8D;;IAatE,KAAK,CAAC,GAAG,EAAE,GAAG;IAId,WAAW,CAAC,IAAI,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG;IAMnC,aAAa,CAAC,IAAI,EAAE,GAAG;IAIvB,gBAAgB,CAAC,SAAS,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG;IA0BxD,cAAc,CAAC,SAAS,EAAE,GAAG,EAAE,UAAU,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG;IAOxD,YAAY,CAAC,SAAS,EAAE,GAAG,EAAE,UAAU,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG;IAOtD,SAAS,CAAC,EAAE,EAAE,GAAG;IAIjB,SAAS,CAAC,GAAG,EAAE,GAAG;IAMlB,qBAAqB,CAAC,OAAO,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,QAAQ,EAAE,GAAG,EAAE,SAAS,EAAE,GAAG;IAsB5E,QAAQ,CAAC,UAAU,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,QAAQ,CAAC,WAAW;IAM1D,oBAAoB,CAAC,aAAa,EAAE,GAAG,EAAE,QAAQ,EAAE,GAAG;IAuCtD,MAAM,CAAC,UAAU,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG;IAKjC,aAAa,CAAC,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,GAAG;CAmDlD;AAGD;;GAEG;AACH,cAAM,sBAAuB,SAAQ,KAAK;CACzC","file":"WSCommand.d.ts","sourcesContent":["import WSSchema from \"./WSSchema\";\n/**\n * @ignore\n */\nconst commandClasses: any = {};\n/**\n * @ignore\n */\nexport default abstract class WSCommand {\n\n  static get schema() {\n    return WSSchema;\n  }\n\n  static get CommandClasses() {\n    return commandClasses;\n  }\n\n  get WSCommandNotFoundError() {\n    return WSCommandNotFoundError;\n  }\n\n  public static addCommandClass(name: any, classObj: any) {\n    commandClasses[name] = classObj;\n  }\n\n  public static framed(module: any, func: any, payload: any): Uint8Array {\n    let payload_length: any = 0;\n    if (payload) {\n      payload_length = payload.length;\n    }\n    let length_type: any;\n    if (payload_length <= 0x3f) {\n      length_type = 0;\n    } else if (payload_length <= 0x3fff) {\n      length_type = 1;\n    } else if (payload_length <= 0x3fffffff) {\n      length_type = 2;\n    } else {\n      throw new Error(\"too big payload\");\n    }\n    let length_extra_bytse: any = length_type === 0 ? 0 : length_type === 1 ? 1 : 3;\n    const header_length: any = 3 + length_extra_bytse;\n    const result: any = new Uint8Array(header_length + payload_length);\n    let index: any = 0;\n    result[index++] = module & 0x7f;\n    result[index++] = func;\n    result[index++] =\n      (length_type << 6) | (payload_length >> (length_extra_bytse * 8));\n    while (length_extra_bytse > 0) {\n      length_extra_bytse--;\n      result[index++] = payload_length >> (length_extra_bytse * 8);\n    }\n    if (payload_length === 0) {\n      return result;\n    } else {\n      result.set(payload, header_length);\n      return result;\n    }\n  }\n\n  public static dequeueOne(buf: any) {\n    if (!buf || buf.byteLength === 0) {\n      return null;\n    }\n    if (buf.byteLength < 3) {\n      throw new Error(\"something wrong. buf less than 3\");\n    }\n    if (buf[0] & 0x80) {\n      throw new Error(\"reserved bit 1\");\n    }\n    const module: any = 0x7f & buf[0];\n    const func: any = buf[1];\n    const length_type: any = (buf[2] >> 6) & 0x3;\n    const length_extra_bytse: any = length_type === 0 ? 0 : length_type === 1 ? 1 : 3;\n    if (length_type === 4) {\n      throw new Error(\"invalid length\");\n    }\n    let length: any = (buf[2] & 0x3f) << (length_extra_bytse * 8);\n    let index: any = 3;\n    let shift: any = length_extra_bytse;\n    while (shift > 0) {\n      shift--;\n      length += buf[index] << (shift * 8);\n      index++;\n    }\n\n    return {\n      module,\n      func,\n      payload: buf.slice(\n        3 + length_extra_bytse,\n        3 + length_extra_bytse + length,\n      ),\n      next: buf.slice(3 + length_extra_bytse + length),\n    };\n  }\n\n  public static compress(wscommands: any, json: any): Uint8Array | null {\n    let ret: any = null;\n\n    function append(module: any, func: any, payload: any) {\n      const frame: any = WSCommand.framed(module, func, payload);\n      if (ret) {\n        const combined: any = new Uint8Array(ret.length + frame.length);\n        combined.set(ret, 0);\n        combined.set(frame, ret.length);\n        ret = combined;\n      } else {\n        ret = frame;\n      }\n    }\n\n    for (const wscommand of wscommands) {\n      wscommand.parsed = append;\n      wscommand.parseFromJson(json);\n    }\n    return ret;\n  }\n\n  public _hw: any;\n  public ioNotUsed: number;\n  public COMMAND_FUNC_ID_ERROR: number;\n\n  protected abstract module: number;\n  private parsed?: (module: number, func: number, payload: Uint8Array) => void;\n\n  constructor() {\n    this._hw = {\n      hw: undefined,\n      firmware: undefined,\n    };\n\n    // constants\n    this.COMMAND_FUNC_ID_ERROR = 0xff;\n    this.ioNotUsed = 0xff;\n  }\n\n  public setHw(obj: any) {\n    this._hw = obj;\n  }\n\n  public sendCommand(func: any, payload: any) {\n    if (this.parsed) {\n      this.parsed(this.module, func, payload);\n    }\n  }\n\n  public parseFromJson(json: any) {\n    // abstract\n  }\n\n  public notifyFromBinary(objToSend: any, func: any, payload: any) {\n    if (func === this.COMMAND_FUNC_ID_ERROR) {\n      if (!objToSend.debug) {\n        objToSend.debug = {};\n      }\n      const err: any = {\n        module: this.module,\n        _args: [...payload],\n      };\n\n      if (payload.byteLength === 3) {\n        err.err0 = payload[0];\n        err.err1 = payload[1];\n        err.function = payload[2];\n        err.message = `Error module=${this.module} func=${err.function} err0=${\n          err.err0\n        } returned=${err.err1}`;\n      } else {\n        err.message = `Error module=${this.module} with + ${err._args}`;\n      }\n      objToSend.debug.error = err;\n    } else {\n      // unknown\n    }\n  }\n\n  public envelopWarning(objToSend: any, module_key: any, obj: any) {\n    if (!objToSend[module_key]) {\n      objToSend[module_key] = {};\n    }\n    objToSend[module_key].warning = obj;\n  }\n\n  public envelopError(objToSend: any, module_key: any, obj: any) {\n    if (!objToSend[module_key]) {\n      objToSend[module_key] = {};\n    }\n    objToSend[module_key].error = obj;\n  }\n\n  public isValidIO(io: any) {\n    return typeof io === \"number\" && 0 <= io && io <= 11;\n  }\n\n  public getSchema(uri: any) {\n    // chack isFirst\n\n    return WSSchema.getSchema(uri);\n  }\n\n  public validateCommandSchema(uriList: any, json: any, rootPath: any, customArg: any) {\n    const res: any = {valid: 0, invalid: 0, results: [], invalidButLike: []};\n    for (const oneRow of uriList) {\n      const errors: any = this.validate(oneRow.uri, json);\n      res.results.push(errors);\n      if (errors.valid) {\n        res.valid++;\n        if (oneRow.onValid) {\n          oneRow.onValid.bind(this)(this.filter(oneRow.uri, json), customArg);\n        }\n      } else {\n        res.invalid++;\n        const message: any = this.onlyTypeErrorMessage(errors, rootPath);\n        if (message) {\n          res.invalidButLike.push({uri: oneRow.uri, message});\n        }\n      }\n    }\n\n    return res;\n  }\n\n  public validate(commandUri: any, json: any): WSSchema.MultiResult {\n    const schema: any = this.getSchema(commandUri);\n    const results: any = WSSchema.validateMultiple(json, schema);\n    return results;\n  }\n\n  public onlyTypeErrorMessage(validateError: any, rootPath: any) {\n    if (validateError.valid) {\n      return true;\n    }\n    if (validateError.missing && validateError.missing.length > 0) {\n      return false;\n    }\n\n    const badErrorCodes: any = [\n      WSSchema.errorCodes.ANY_OF_MISSING,\n      WSSchema.errorCodes.ONE_OF_MISSING,\n      WSSchema.errorCodes.ONE_OF_MULTIPLE,\n      WSSchema.errorCodes.NOT_PASSED,\n      WSSchema.errorCodes.OBJECT_REQUIRED,\n      WSSchema.errorCodes.OBJECT_ADDITIONAL_PROPERTIES,\n      WSSchema.errorCodes.CIRCULAR_REFERENCE,\n      WSSchema.errorCodes.FORMAT_CUSTOM,\n      WSSchema.errorCodes.KEYWORD_CUSTOM,\n      WSSchema.errorCodes.UNKNOWN_PROPERTY,\n    ];\n    const messages: any = [];\n    for (const error of validateError.errors) {\n      if (error.code === WSSchema.errorCodes.INVALID_TYPE) {\n        if (\n          (error as any).params.type === \"object\" ||\n          (error as any).params.expected === \"object\"\n        ) {\n          return false;\n        }\n      } else if (badErrorCodes.includes(error.code)) {\n        return false;\n      }\n\n      const path: any = rootPath + (error.dataPath || \"\").replace(/\\//g, \".\");\n      messages.push(`[${path}]${error.message}`);\n    }\n    return messages.join(\";\");\n  }\n\n  public filter(commandUri: any, json: any) {\n    const schema: any = this.getSchema(commandUri);\n    return this._filterSchema(schema, json);\n  }\n\n  public _filterSchema(schema: any, json: any): any {\n    if (schema.$ref) {\n      const refSchema: any = WSSchema.getSchema(schema.$ref);\n      return this._filterSchema(refSchema, json);\n    }\n\n    if (json === undefined) {\n      return schema.default;\n    }\n\n    if (\n      schema.type === \"string\" ||\n      schema.type === \"integer\" ||\n      schema.type === \"boolean\" ||\n      schema.type === \"number\" ||\n      schema.type === \"null\" ||\n      schema.filter === \"pass_all\"\n    ) {\n      return json;\n    }\n\n    if (schema.type === \"array\") {\n      const results: any = [];\n      for (const key in json) {\n        results[key] = this._filterSchema(schema.items, json[key]);\n      }\n      return results;\n    }\n\n    if (schema.type === \"object\") {\n      const results: any = {};\n      for (const key in schema.properties) {\n        results[key] = this._filterSchema(schema.properties[key], json[key]);\n      }\n\n      for (const pattern in schema.patternProperties) {\n        const reg: any = new RegExp(pattern);\n        for (const key of Object.keys(json)) {\n          if (reg.test(key)) {\n            results[key] = this._filterSchema(\n              schema.patternProperties[pattern],\n              json[key],\n            );\n          }\n        }\n      }\n      return results;\n    }\n\n    throw Error(\"unknown json schema type\");\n  }\n}\n\n// tslint:disable:max-classes-per-file\n/**\n * @ignore\n */\nclass WSCommandNotFoundError extends Error {\n}\n"]}