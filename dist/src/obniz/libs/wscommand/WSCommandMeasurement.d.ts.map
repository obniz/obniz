{"version":3,"sources":["../src/obniz/libs/wscommand/WSCommandMeasurement.ts"],"names":[],"mappings":"AAAA,OAAO,SAAS,MAAM,aAAa,CAAC;AAEpC;;GAEG;AACH,cAAM,oBAAqB,SAAQ,SAAS;IACnC,MAAM,EAAE,GAAG,CAAC;IACZ,uBAAuB,EAAE,GAAG,CAAC;IAC7B,WAAW,EAAE,GAAG,CAAC;IACjB,qBAAqB,EAAE,GAAG,CAAC;IAC3B,sBAAsB,EAAE,GAAG,CAAC;;IAW5B,IAAI,CAAC,MAAM,EAAE,GAAG;IA0BhB,aAAa,CAAC,IAAI,EAAE,GAAG;IAiBvB,gBAAgB,CAAC,SAAS,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG;CAyBhE;AAED,eAAe,oBAAoB,CAAC","file":"WSCommandMeasurement.d.ts","sourcesContent":["import WSCommand from \"./WSCommand\";\n\n/**\n * @ignore\n */\nclass WSCommandMeasurement extends WSCommand {\n  public module: any;\n  public _CommandMeasurementEcho: any;\n  public sendCommand: any;\n  public validateCommandSchema: any;\n  public WSCommandNotFoundError: any;\n\n  constructor() {\n    super();\n    this.module = 12;\n\n    this._CommandMeasurementEcho = 0;\n  }\n\n  // Commands\n\n  public echo(params: any) {\n    const triggerIO: any = params.echo.io_pulse;\n    const triggerPosNeg: any = params.echo.pulse === \"negative\" ? false : true;\n    const triggerWidthUs: any = Math.floor(params.echo.pulse_width * 1000);\n    const echoIO: any = params.echo.io_echo;\n    const responseCount: any = params.echo.measure_edges;\n    let timeoutUs: any = params.echo.timeout * 1000;\n    timeoutUs = parseInt(timeoutUs);\n\n    const buf: any = new Uint8Array(13);\n    buf[0] = 0;\n    buf[1] = triggerIO;\n    buf[2] = triggerPosNeg ? 1 : 0;\n    buf[3] = triggerWidthUs >> (8 * 3);\n    buf[4] = triggerWidthUs >> (8 * 2);\n    buf[5] = triggerWidthUs >> 8;\n    buf[6] = triggerWidthUs;\n    buf[7] = echoIO;\n    buf[8] = responseCount;\n    buf[9] = timeoutUs >> (8 * 3);\n    buf[10] = timeoutUs >> (8 * 2);\n    buf[11] = timeoutUs >> 8;\n    buf[12] = timeoutUs;\n    this.sendCommand(this._CommandMeasurementEcho, buf);\n  }\n\n  public parseFromJson(json: any) {\n    const module: any = json.measure;\n    if (module === undefined) {\n      return;\n    }\n    const schemaData: any = [{uri: \"/request/measure/echo\", onValid: this.echo}];\n    const res: any = this.validateCommandSchema(schemaData, module, \"measure\");\n\n    if (res.valid === 0) {\n      if (res.invalidButLike.length > 0) {\n        throw new Error(res.invalidButLike[0].message);\n      } else {\n        throw new this.WSCommandNotFoundError(`[measure]unknown command`);\n      }\n    }\n  }\n\n  public notifyFromBinary(objToSend: any, func: any, payload: any) {\n    if (func === this._CommandMeasurementEcho) {\n      let index: any = 0;\n      const count: any = parseInt(payload[index++]);\n      const array: any = [];\n      for (let i = 0; i < count; i++) {\n        let timing: any;\n        const edge: any = payload[index++] > 0 ? true : false;\n        timing = payload[index++] << (8 * 3);\n        timing += payload[index++] << (8 * 2);\n        timing += payload[index++] << 8;\n        timing += payload[index++];\n        timing = timing / 1000;\n        array.push({\n          edge,\n          timing,\n        });\n      }\n      objToSend.measure = {\n        echo: array,\n      };\n    } else {\n      super.notifyFromBinary(objToSend, func, payload);\n    }\n  }\n}\n\nexport default WSCommandMeasurement;\n"]}